(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.mx-auto{margin-left:auto;margin-right:auto}.flex{display:flex}.h-full{height:100%}.w-full{width:100%}.min-w-28{min-width:7rem}.flex-1{flex:1 1 0%}.flex-grow{flex-grow:1}.flex-col{flex-direction:column}.flex-nowrap{flex-wrap:nowrap}.\\!items-start{align-items:flex-start!important}.items-start{align-items:flex-start}.items-center{align-items:center}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-5{gap:1.25rem}.border{border-width:1px}.border-2{border-width:2px}.border-solid{border-style:solid}.p-2{padding:.5rem}.p-5{padding:1.25rem}.text-2xl{font-size:1.5rem;line-height:2rem}.font-bold{font-weight:700}.text-blue-600{--tw-text-opacity: 1;color:rgb(37 99 235 / var(--tw-text-opacity, 1))}.text-red-600{--tw-text-opacity: 1;color:rgb(220 38 38 / var(--tw-text-opacity, 1))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.\\[\\&\\>div\\>div\\:before\\]\\:\\!border-solid>div>div:before{border-style:solid!important}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
import { computed as d, markRaw as Qo, defineComponent as Nn, reactive as kn, h as v, withDirectives as At, getCurrentInstance as we, unref as pl, ref as J, onBeforeUnmount as ot, Transition as Mt, onDeactivated as xn, nextTick as De, watch as ce, onMounted as jt, onUnmounted as Vi, Teleport as Ai, openBlock as Le, createBlock as st, withCtx as Me, createVNode as ke, mergeProps as Qt, createElementVNode as Ke, toDisplayString as Dn, renderSlot as mt, createCommentVNode as ze, provide as Di, onActivated as Sl, createElementBlock as Ft, onBeforeUpdate as Xo, inject as Li, onBeforeMount as zn, onUpdated as Fi, toRaw as Yt, useSlots as Jo, Fragment as Rn, createSlots as ta, createTextVNode as $i, renderList as ll, normalizeProps as La, mergeModels as Fa, useModel as Hi } from "vue";
const na = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
}, _n = {
  size: String
};
function Cn(e, t = na) {
  return d(() => e.size !== void 0 ? { fontSize: e.size in t ? `${t[e.size]}px` : e.size } : null);
}
function _t(e, t, n, l) {
  return Object.defineProperty(e, t, {
    get: n,
    set: l,
    enumerable: !0
  }), e;
}
function Ii(e, t) {
  for (const n in t)
    _t(e, n, t[n]);
  return e;
}
function Ce(e) {
  return Qo(Nn(e));
}
function pa(e) {
  return Qo(e);
}
const ji = (e, t) => {
  const n = kn(e);
  for (const l in e)
    _t(
      t,
      l,
      () => n[l],
      (a) => {
        n[l] = a;
      }
    );
  return t;
};
function We(e, t) {
  return e !== void 0 && e() || t;
}
function Zo(e, t) {
  if (e !== void 0) {
    const n = e();
    if (n != null)
      return n.slice();
  }
  return t;
}
function Vt(e, t) {
  return e !== void 0 ? t.concat(e()) : t;
}
function Ni(e, t) {
  return e === void 0 ? t : t !== void 0 ? t.concat(e()) : e();
}
function zi(e, t, n, l, a, o) {
  t.key = l + a;
  const r = v(e, t, n);
  return a === !0 ? At(r, o()) : r;
}
const $a = "0 0 24 24", Ha = (e) => e, Bl = (e) => `ionicons ${e}`, Go = {
  "mdi-": (e) => `mdi ${e}`,
  "icon-": Ha,
  // fontawesome equiv
  "bt-": (e) => `bt ${e}`,
  "eva-": (e) => `eva ${e}`,
  "ion-md": Bl,
  "ion-ios": Bl,
  "ion-logo": Bl,
  "iconfont ": Ha,
  "ti-": (e) => `themify-icon ${e}`,
  "bi-": (e) => `bootstrap-icons ${e}`
}, er = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
}, tr = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
}, Ui = new RegExp("^(" + Object.keys(Go).join("|") + ")"), Yi = new RegExp("^(" + Object.keys(er).join("|") + ")"), Ia = new RegExp("^(" + Object.keys(tr).join("|") + ")"), Ki = /^[Mm]\s?[-+]?\.?\d/, Wi = /^img:/, Qi = /^svguse:/, Xi = /^ion-/, Ji = /^(fa-(classic|sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /, pt = Ce({
  name: "QIcon",
  props: {
    ..._n,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: n } } = we(), l = Cn(e), a = d(
      () => "q-icon" + (e.left === !0 ? " on-left" : "") + (e.right === !0 ? " on-right" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")
    ), o = d(() => {
      let r, i = e.name;
      if (i === "none" || !i)
        return { none: !0 };
      if (n.iconMapFn !== null) {
        const u = n.iconMapFn(i);
        if (u !== void 0)
          if (u.icon !== void 0) {
            if (i = u.icon, i === "none" || !i)
              return { none: !0 };
          } else
            return {
              cls: u.cls,
              content: u.content !== void 0 ? u.content : " "
            };
      }
      if (Ki.test(i) === !0) {
        const [u, f = $a] = i.split("|");
        return {
          svg: !0,
          viewBox: f,
          nodes: u.split("&&").map((S) => {
            const [b, h, x] = S.split("@@");
            return v("path", { style: h, d: b, transform: x });
          })
        };
      }
      if (Wi.test(i) === !0)
        return {
          img: !0,
          src: i.substring(4)
        };
      if (Qi.test(i) === !0) {
        const [u, f = $a] = i.split("|");
        return {
          svguse: !0,
          src: u.substring(7),
          viewBox: f
        };
      }
      let c = " ";
      const s = i.match(Ui);
      if (s !== null)
        r = Go[s[1]](i);
      else if (Ji.test(i) === !0)
        r = i;
      else if (Xi.test(i) === !0)
        r = `ionicons ion-${n.platform.is.ios === !0 ? "ios" : "md"}${i.substring(3)}`;
      else if (Ia.test(i) === !0) {
        r = "notranslate material-symbols";
        const u = i.match(Ia);
        u !== null && (i = i.substring(6), r += tr[u[1]]), c = i;
      } else {
        r = "notranslate material-icons";
        const u = i.match(Yi);
        u !== null && (i = i.substring(2), r += er[u[1]]), c = i;
      }
      return {
        cls: r,
        content: c
      };
    });
    return () => {
      const r = {
        class: a.value,
        style: l.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      return o.value.none === !0 ? v(e.tag, r, We(t.default)) : o.value.img === !0 ? v(e.tag, r, Vt(t.default, [
        v("img", { src: o.value.src })
      ])) : o.value.svg === !0 ? v(e.tag, r, Vt(t.default, [
        v("svg", {
          viewBox: o.value.viewBox || "0 0 24 24"
        }, o.value.nodes)
      ])) : o.value.svguse === !0 ? v(e.tag, r, Vt(t.default, [
        v("svg", {
          viewBox: o.value.viewBox
        }, [
          v("use", { "xlink:href": o.value.src })
        ])
      ])) : (o.value.cls !== void 0 && (r.class += " " + o.value.cls), v(e.tag, r, Vt(t.default, [
        o.value.content
      ])));
    };
  }
}), nr = {
  size: {
    type: [String, Number],
    default: "1em"
  },
  color: String
};
function lr(e) {
  return {
    cSize: d(() => e.size in na ? `${na[e.size]}px` : e.size),
    classes: d(
      () => "q-spinner" + (e.color ? ` text-${e.color}` : "")
    )
  };
}
const ar = Ce({
  name: "QSpinner",
  props: {
    ...nr,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(e) {
    const { cSize: t, classes: n } = lr(e);
    return () => v("svg", {
      class: n.value + " q-spinner-mat",
      width: t.value,
      height: t.value,
      viewBox: "25 25 50 50"
    }, [
      v("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": e.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function la(e, t) {
  const n = e.style;
  for (const l in t)
    n[l] = t[l];
}
function Zi(e) {
  if (e == null)
    return;
  if (typeof e == "string")
    try {
      return document.querySelector(e) || void 0;
    } catch {
      return;
    }
  const t = pl(e);
  if (t)
    return t.$el || t;
}
function or(e, t) {
  if (e == null || e.contains(t) === !0)
    return !0;
  for (let n = e.nextElementSibling; n !== null; n = n.nextElementSibling)
    if (n.contains(t))
      return !0;
  return !1;
}
const Ze = {
  hasPassive: !1,
  passiveCapture: !0,
  notPassiveCapture: !0
};
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(Ze, {
        hasPassive: !0,
        passive: { passive: !0 },
        notPassive: { passive: !1 },
        passiveCapture: { passive: !0, capture: !0 },
        notPassiveCapture: { passive: !1, capture: !0 }
      });
    }
  });
  window.addEventListener("qtest", null, e), window.removeEventListener("qtest", null, e);
} catch {
}
function rr() {
}
function Gi(e) {
  return e.button === 0;
}
function Sn(e) {
  return e.touches && e.touches[0] ? e = e.touches[0] : e.changedTouches && e.changedTouches[0] ? e = e.changedTouches[0] : e.targetTouches && e.targetTouches[0] && (e = e.targetTouches[0]), {
    top: e.clientY,
    left: e.clientX
  };
}
function eu(e) {
  if (e.path)
    return e.path;
  if (e.composedPath)
    return e.composedPath();
  const t = [];
  let n = e.target;
  for (; n; ) {
    if (t.push(n), n.tagName === "HTML")
      return t.push(document), t.push(window), t;
    n = n.parentElement;
  }
}
function bt(e) {
  e.stopPropagation();
}
function ct(e) {
  e.cancelable !== !1 && e.preventDefault();
}
function Fe(e) {
  e.cancelable !== !1 && e.preventDefault(), e.stopPropagation();
}
function Vl(e, t) {
  if (e === void 0 || t === !0 && e.__dragPrevented === !0)
    return;
  const n = t === !0 ? (l) => {
    l.__dragPrevented = !0, l.addEventListener("dragstart", ct, Ze.notPassiveCapture);
  } : (l) => {
    delete l.__dragPrevented, l.removeEventListener("dragstart", ct, Ze.notPassiveCapture);
  };
  e.querySelectorAll("a, img").forEach(n);
}
function tn(e, t, n) {
  const l = `__q_${t}_evt`;
  e[l] = e[l] !== void 0 ? e[l].concat(n) : n, n.forEach((a) => {
    a[0].addEventListener(a[1], e[a[2]], Ze[a[3]]);
  });
}
function Ln(e, t) {
  const n = `__q_${t}_evt`;
  e[n] !== void 0 && (e[n].forEach((l) => {
    l[0].removeEventListener(l[1], e[l[2]], Ze[l[3]]);
  }), e[n] = void 0);
}
function Sa(e) {
  return e !== Object(e) || e.isComposing === !0 || e.qKeyEvent === !0;
}
function It(e, t) {
  return Sa(e) === !0 ? !1 : [].concat(t).includes(e.keyCode);
}
function tu(e, t = 250) {
  let n = !1, l;
  return function() {
    return n === !1 && (n = !0, setTimeout(() => {
      n = !1;
    }, t), l = e.apply(this, arguments)), l;
  };
}
function ja(e, t, n, l) {
  n.modifiers.stop === !0 && bt(e);
  const a = n.modifiers.color;
  let o = n.modifiers.center;
  o = o === !0 || l === !0;
  const r = document.createElement("span"), i = document.createElement("span"), c = Sn(e), { left: s, top: u, width: f, height: S } = t.getBoundingClientRect(), b = Math.sqrt(f * f + S * S), h = b / 2, x = `${(f - b) / 2}px`, g = o ? x : `${c.left - s - h}px`, T = `${(S - b) / 2}px`, P = o ? T : `${c.top - u - h}px`;
  i.className = "q-ripple__inner", la(i, {
    height: `${b}px`,
    width: `${b}px`,
    transform: `translate3d(${g},${P},0) scale3d(.2,.2,1)`,
    opacity: 0
  }), r.className = `q-ripple${a ? " text-" + a : ""}`, r.setAttribute("dir", "ltr"), r.appendChild(i), t.appendChild(r);
  const _ = () => {
    r.remove(), clearTimeout(y);
  };
  n.abort.push(_);
  let y = setTimeout(() => {
    i.classList.add("q-ripple__inner--enter"), i.style.transform = `translate3d(${x},${T},0) scale3d(1,1,1)`, i.style.opacity = 0.2, y = setTimeout(() => {
      i.classList.remove("q-ripple__inner--enter"), i.classList.add("q-ripple__inner--leave"), i.style.opacity = 0, y = setTimeout(() => {
        r.remove(), n.abort.splice(n.abort.indexOf(_), 1);
      }, 275);
    }, 250);
  }, 50);
}
function Na(e, { modifiers: t, value: n, arg: l }) {
  const a = Object.assign({}, e.cfg.ripple, t, n);
  e.modifiers = {
    early: a.early === !0,
    stop: a.stop === !0,
    center: a.center === !0,
    color: a.color || l,
    keyCodes: [].concat(a.keyCodes || 13)
  };
}
const ir = pa(
  {
    name: "ripple",
    beforeMount(e, t) {
      const n = t.instance.$.appContext.config.globalProperties.$q.config || {};
      if (n.ripple === !1) return;
      const l = {
        cfg: n,
        enabled: t.value !== !1,
        modifiers: {},
        abort: [],
        start(a) {
          l.enabled === !0 && a.qSkipRipple !== !0 && a.type === (l.modifiers.early === !0 ? "pointerdown" : "click") && ja(a, e, l, a.qKeyEvent === !0);
        },
        keystart: tu((a) => {
          l.enabled === !0 && a.qSkipRipple !== !0 && It(a, l.modifiers.keyCodes) === !0 && a.type === `key${l.modifiers.early === !0 ? "down" : "up"}` && ja(a, e, l, !0);
        }, 300)
      };
      Na(l, t), e.__qripple = l, tn(l, "main", [
        [e, "pointerdown", "start", "passive"],
        [e, "click", "start", "passive"],
        [e, "keydown", "keystart", "passive"],
        [e, "keyup", "keystart", "passive"]
      ]);
    },
    updated(e, t) {
      if (t.oldValue !== t.value) {
        const n = e.__qripple;
        n !== void 0 && (n.enabled = t.value !== !1, n.enabled === !0 && Object(t.value) === t.value && Na(n, t));
      }
    },
    beforeUnmount(e) {
      const t = e.__qripple;
      t !== void 0 && (t.abort.forEach((n) => {
        n();
      }), Ln(t, "main"), delete e._qripple);
    }
  }
), ur = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
}, nu = Object.keys(ur), lu = {
  align: {
    type: String,
    validator: (e) => nu.includes(e)
  }
};
function au(e) {
  return d(() => {
    const t = e.align === void 0 ? e.vertical === !0 ? "stretch" : "left" : e.align;
    return `${e.vertical === !0 ? "items" : "justify"}-${ur[t]}`;
  });
}
function al(e) {
  if (Object(e.$parent) === e.$parent)
    return e.$parent;
  let { parent: t } = e.$;
  for (; Object(t) === t; ) {
    if (Object(t.proxy) === t.proxy)
      return t.proxy;
    t = t.parent;
  }
}
function wa(e) {
  return e.appContext.config.globalProperties.$router !== void 0;
}
function wl(e) {
  return e.isUnmounted === !0 || e.isDeactivated === !0;
}
function za(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
}
function Ua(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function ou(e, t) {
  for (const n in t) {
    const l = t[n], a = e[n];
    if (typeof l == "string") {
      if (l !== a)
        return !1;
    } else if (Array.isArray(a) === !1 || a.length !== l.length || l.some((o, r) => o !== a[r]))
      return !1;
  }
  return !0;
}
function Ya(e, t) {
  return Array.isArray(t) === !0 ? e.length === t.length && e.every((n, l) => n === t[l]) : e.length === 1 && e[0] === t;
}
function ru(e, t) {
  return Array.isArray(e) === !0 ? Ya(e, t) : Array.isArray(t) === !0 ? Ya(t, e) : e === t;
}
function iu(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (ru(e[n], t[n]) === !1)
      return !1;
  return !0;
}
const sr = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
}, uu = {
  ...sr,
  // router-link
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  }
};
function cr({ fallbackTag: e, useDisableForRouterLinkProps: t = !0 } = {}) {
  const n = we(), { props: l, proxy: a, emit: o } = n, r = wa(n), i = d(() => l.disable !== !0 && l.href !== void 0), c = t === !0 ? d(
    () => r === !0 && l.disable !== !0 && i.value !== !0 && l.to !== void 0 && l.to !== null && l.to !== ""
  ) : d(
    () => r === !0 && i.value !== !0 && l.to !== void 0 && l.to !== null && l.to !== ""
  ), s = d(() => c.value === !0 ? P(l.to) : null), u = d(() => s.value !== null), f = d(() => i.value === !0 || u.value === !0), S = d(() => l.type === "a" || f.value === !0 ? "a" : l.tag || e || "div"), b = d(() => i.value === !0 ? {
    href: l.href,
    target: l.target
  } : u.value === !0 ? {
    href: s.value.href,
    target: l.target
  } : {}), h = d(() => {
    if (u.value === !1)
      return -1;
    const { matched: p } = s.value, { length: F } = p, A = p[F - 1];
    if (A === void 0)
      return -1;
    const U = a.$route.matched;
    if (U.length === 0)
      return -1;
    const D = U.findIndex(
      Ua.bind(null, A)
    );
    if (D !== -1)
      return D;
    const L = za(p[F - 2]);
    return (
      // we are dealing with nested routes
      F > 1 && za(A) === L && U[U.length - 1].path !== L ? U.findIndex(
        Ua.bind(null, p[F - 2])
      ) : D
    );
  }), x = d(
    () => u.value === !0 && h.value !== -1 && ou(a.$route.params, s.value.params)
  ), g = d(
    () => x.value === !0 && h.value === a.$route.matched.length - 1 && iu(a.$route.params, s.value.params)
  ), T = d(() => u.value === !0 ? g.value === !0 ? ` ${l.exactActiveClass} ${l.activeClass}` : l.exact === !0 ? "" : x.value === !0 ? ` ${l.activeClass}` : "" : "");
  function P(p) {
    try {
      return a.$router.resolve(p);
    } catch {
    }
    return null;
  }
  function _(p, { returnRouterError: F, to: A = l.to, replace: U = l.replace } = {}) {
    if (l.disable === !0)
      return p.preventDefault(), Promise.resolve(!1);
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      p.metaKey || p.altKey || p.ctrlKey || p.shiftKey || p.button !== void 0 && p.button !== 0 || l.target === "_blank"
    )
      return Promise.resolve(!1);
    p.preventDefault();
    const D = a.$router[U === !0 ? "replace" : "push"](A);
    return F === !0 ? D : D.then(() => {
    }).catch(() => {
    });
  }
  function y(p) {
    if (u.value === !0) {
      const F = (A) => _(p, A);
      o("click", p, F), p.defaultPrevented !== !0 && F();
    } else
      o("click", p);
  }
  return {
    hasRouterLink: u,
    hasHrefLink: i,
    hasLink: f,
    linkTag: S,
    resolvedLink: s,
    linkIsActive: x,
    linkIsExactActive: g,
    linkClass: T,
    linkAttrs: b,
    getLink: P,
    navigateToRouterLink: _,
    navigateOnClick: y
  };
}
const sl = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
}, su = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
}, cu = ["button", "submit", "reset"], du = /[^\s]\/[^\s]/, dr = ["flat", "outline", "push", "unelevated"];
function fr(e, t) {
  return e.flat === !0 ? "flat" : e.outline === !0 ? "outline" : e.push === !0 ? "push" : e.unelevated === !0 ? "unelevated" : t;
}
const fu = {
  ..._n,
  ...sr,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...dr.reduce(
    (e, t) => (e[t] = Boolean) && e,
    {}
  ),
  square: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  align: {
    ...lu.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
}, mu = {
  ...fu,
  round: Boolean
};
function vu(e) {
  const t = Cn(e, su), n = au(e), { hasRouterLink: l, hasLink: a, linkTag: o, linkAttrs: r, navigateOnClick: i } = cr({
    fallbackTag: "button"
  }), c = d(() => {
    const g = e.fab === !1 && e.fabMini === !1 ? t.value : {};
    return e.padding !== void 0 ? Object.assign({}, g, {
      padding: e.padding.split(/\s+/).map((T) => T in sl ? sl[T] + "px" : T).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : g;
  }), s = d(
    () => e.rounded === !0 || e.fab === !0 || e.fabMini === !0
  ), u = d(
    () => e.disable !== !0 && e.loading !== !0
  ), f = d(() => u.value === !0 ? e.tabindex || 0 : -1), S = d(() => fr(e, "standard")), b = d(() => {
    const g = { tabindex: f.value };
    return a.value === !0 ? Object.assign(g, r.value) : cu.includes(e.type) === !0 && (g.type = e.type), o.value === "a" ? (e.disable === !0 ? g["aria-disabled"] = "true" : g.href === void 0 && (g.role = "button"), l.value !== !0 && du.test(e.type) === !0 && (g.type = e.type)) : e.disable === !0 && (g.disabled = "", g["aria-disabled"] = "true"), e.loading === !0 && e.percentage !== void 0 && Object.assign(g, {
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": e.percentage
    }), g;
  }), h = d(() => {
    let g;
    e.color !== void 0 ? e.flat === !0 || e.outline === !0 ? g = `text-${e.textColor || e.color}` : g = `bg-${e.color} text-${e.textColor || "white"}` : e.textColor && (g = `text-${e.textColor}`);
    const T = e.round === !0 ? "round" : `rectangle${s.value === !0 ? " q-btn--rounded" : e.square === !0 ? " q-btn--square" : ""}`;
    return `q-btn--${S.value} q-btn--${T}` + (g !== void 0 ? " " + g : "") + (u.value === !0 ? " q-btn--actionable q-focusable q-hoverable" : e.disable === !0 ? " disabled" : "") + (e.fab === !0 ? " q-btn--fab" : e.fabMini === !0 ? " q-btn--fab-mini" : "") + (e.noCaps === !0 ? " q-btn--no-uppercase" : "") + (e.dense === !0 ? " q-btn--dense" : "") + (e.stretch === !0 ? " no-border-radius self-stretch" : "") + (e.glossy === !0 ? " glossy" : "") + (e.square ? " q-btn--square" : "");
  }), x = d(
    () => n.value + (e.stack === !0 ? " column" : " row") + (e.noWrap === !0 ? " no-wrap text-no-wrap" : "") + (e.loading === !0 ? " q-btn__content--hidden" : "")
  );
  return {
    classes: h,
    style: c,
    innerClasses: x,
    attributes: b,
    hasLink: a,
    linkTag: o,
    navigateOnClick: i,
    isActionable: u
  };
}
const { passiveCapture: xt } = Ze;
let fn = null, mn = null, vn = null;
const Te = Ce({
  name: "QBtn",
  props: {
    ...mu,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(e, { slots: t, emit: n }) {
    const { proxy: l } = we(), {
      classes: a,
      style: o,
      innerClasses: r,
      attributes: i,
      hasLink: c,
      linkTag: s,
      navigateOnClick: u,
      isActionable: f
    } = vu(e), S = J(null), b = J(null);
    let h = null, x, g = null;
    const T = d(
      () => e.label !== void 0 && e.label !== null && e.label !== ""
    ), P = d(() => e.disable === !0 || e.ripple === !1 ? !1 : {
      keyCodes: c.value === !0 ? [13, 32] : [13],
      ...e.ripple === !0 ? {} : e.ripple
    }), _ = d(() => ({ center: e.round })), y = d(() => {
      const M = Math.max(0, Math.min(100, e.percentage));
      return M > 0 ? { transition: "transform 0.6s", transform: `translateX(${M - 100}%)` } : {};
    }), p = d(() => {
      if (e.loading === !0)
        return {
          onMousedown: $,
          onTouchstart: $,
          onClick: $,
          onKeydown: $,
          onKeyup: $
        };
      if (f.value === !0) {
        const M = {
          onClick: A,
          onKeydown: U,
          onMousedown: L
        };
        if (l.$q.platform.has.touch === !0) {
          const K = e.onTouchstart !== void 0 ? "" : "Passive";
          M[`onTouchstart${K}`] = D;
        }
        return M;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: Fe
      };
    }), F = d(() => ({
      ref: S,
      class: "q-btn q-btn-item non-selectable no-outline " + a.value,
      style: o.value,
      ...i.value,
      ...p.value
    }));
    function A(M) {
      if (S.value !== null) {
        if (M !== void 0) {
          if (M.defaultPrevented === !0) return;
          const K = document.activeElement;
          if (e.type === "submit" && K !== document.body && S.value.contains(K) === !1 && K.contains(S.value) === !1) {
            S.value.focus();
            const Q = () => {
              document.removeEventListener("keydown", Fe, !0), document.removeEventListener("keyup", Q, xt), S.value !== null && S.value.removeEventListener("blur", Q, xt);
            };
            document.addEventListener("keydown", Fe, !0), document.addEventListener("keyup", Q, xt), S.value.addEventListener("blur", Q, xt);
          }
        }
        u(M);
      }
    }
    function U(M) {
      S.value !== null && (n("keydown", M), It(M, [13, 32]) === !0 && mn !== S.value && (mn !== null && E(), M.defaultPrevented !== !0 && (S.value.focus(), mn = S.value, S.value.classList.add("q-btn--active"), document.addEventListener("keyup", H, !0), S.value.addEventListener("blur", H, xt)), Fe(M)));
    }
    function D(M) {
      S.value !== null && (n("touchstart", M), M.defaultPrevented !== !0 && (fn !== S.value && (fn !== null && E(), fn = S.value, h = M.target, h.addEventListener("touchcancel", H, xt), h.addEventListener("touchend", H, xt)), x = !0, g !== null && clearTimeout(g), g = setTimeout(() => {
        g = null, x = !1;
      }, 200)));
    }
    function L(M) {
      S.value !== null && (M.qSkipRipple = x === !0, n("mousedown", M), M.defaultPrevented !== !0 && vn !== S.value && (vn !== null && E(), vn = S.value, S.value.classList.add("q-btn--active"), document.addEventListener("mouseup", H, xt)));
    }
    function H(M) {
      if (S.value !== null && !(M !== void 0 && M.type === "blur" && document.activeElement === S.value)) {
        if (M !== void 0 && M.type === "keyup") {
          if (mn === S.value && It(M, [13, 32]) === !0) {
            const K = new MouseEvent("click", M);
            K.qKeyEvent = !0, M.defaultPrevented === !0 && ct(K), M.cancelBubble === !0 && bt(K), S.value.dispatchEvent(K), Fe(M), M.qKeyEvent = !0;
          }
          n("keyup", M);
        }
        E();
      }
    }
    function E(M) {
      const K = b.value;
      M !== !0 && (fn === S.value || vn === S.value) && K !== null && K !== document.activeElement && (K.setAttribute("tabindex", -1), K.focus()), fn === S.value && (h !== null && (h.removeEventListener("touchcancel", H, xt), h.removeEventListener("touchend", H, xt)), fn = h = null), vn === S.value && (document.removeEventListener("mouseup", H, xt), vn = null), mn === S.value && (document.removeEventListener("keyup", H, !0), S.value !== null && S.value.removeEventListener("blur", H, xt), mn = null), S.value !== null && S.value.classList.remove("q-btn--active");
    }
    function $(M) {
      Fe(M), M.qSkipRipple = !0;
    }
    return ot(() => {
      E(!0);
    }), Object.assign(l, {
      click: (M) => {
        f.value === !0 && A(M);
      }
    }), () => {
      let M = [];
      e.icon !== void 0 && M.push(
        v(pt, {
          name: e.icon,
          left: e.stack !== !0 && T.value === !0,
          role: "img"
        })
      ), T.value === !0 && M.push(
        v("span", { class: "block" }, [e.label])
      ), M = Vt(t.default, M), e.iconRight !== void 0 && e.round === !1 && M.push(
        v(pt, {
          name: e.iconRight,
          right: e.stack !== !0 && T.value === !0,
          role: "img"
        })
      );
      const K = [
        v("span", {
          class: "q-focus-helper",
          ref: b
        })
      ];
      return e.loading === !0 && e.percentage !== void 0 && K.push(
        v("span", {
          class: "q-btn__progress absolute-full overflow-hidden" + (e.darkPercentage === !0 ? " q-btn__progress--dark" : "")
        }, [
          v("span", {
            class: "q-btn__progress-indicator fit block",
            style: y.value
          })
        ])
      ), K.push(
        v("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + r.value
        }, M)
      ), e.loading !== null && K.push(
        v(Mt, {
          name: "q-transition--fade"
        }, () => e.loading === !0 ? [
          v("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, t.loading !== void 0 ? t.loading() : [v(ar)])
        ] : null)
      ), At(
        v(
          s.value,
          F.value,
          K
        ),
        [[
          ir,
          P.value,
          void 0,
          _.value
        ]]
      );
    };
  }
}), bn = Ce({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(e, { slots: t }) {
    const n = d(
      () => `q-card__section q-card__section--${e.horizontal === !0 ? "horiz row no-wrap" : "vert"}`
    );
    return () => v(e.tag, { class: n.value }, We(t.default));
  }
}), rt = {
  dark: {
    type: Boolean,
    default: null
  }
};
function it(e, t) {
  return d(() => e.dark === null ? t.dark.isActive : e.dark);
}
const hu = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
}, Al = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
}, ka = Ce({
  name: "QSeparator",
  props: {
    ...rt,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(e) {
    const t = we(), n = it(e, t.proxy.$q), l = d(() => e.vertical === !0 ? "vertical" : "horizontal"), a = d(() => ` q-separator--${l.value}`), o = d(() => e.inset !== !1 ? `${a.value}-${hu[e.inset]}` : ""), r = d(
      () => `q-separator${a.value}${o.value}` + (e.color !== void 0 ? ` bg-${e.color}` : "") + (n.value === !0 ? " q-separator--dark" : "")
    ), i = d(() => {
      const c = {};
      if (e.size !== void 0 && (c[e.vertical === !0 ? "width" : "height"] = e.size), e.spaced !== !1) {
        const s = e.spaced === !0 ? `${Al.md}px` : e.spaced in Al ? `${Al[e.spaced]}px` : e.spaced, u = e.vertical === !0 ? ["Left", "Right"] : ["Top", "Bottom"];
        c[`margin${u[0]}`] = c[`margin${u[1]}`] = s;
      }
      return c;
    });
    return () => v("hr", {
      class: r.value,
      style: i.value,
      "aria-orientation": l.value
    });
  }
}), $n = J(
  !1
);
let aa;
function gu(e, t) {
  const n = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(vivaldi)[\/]([\w.]+)/.exec(e) || /(chrome|crios)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(firefox|fxios)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(e) || [];
  return {
    browser: n[5] || n[3] || n[1] || "",
    version: n[4] || n[2] || "0",
    platform: t[0] || ""
  };
}
function bu(e) {
  return /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(silk)/.exec(e) || /(android)/.exec(e) || /(win)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || /(playbook)/.exec(e) || /(bb)/.exec(e) || /(blackberry)/.exec(e) || [];
}
const mr = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function yu(e) {
  const t = e.toLowerCase(), n = bu(t), l = gu(t, n), a = {
    mobile: !1,
    desktop: !1,
    cordova: !1,
    capacitor: !1,
    nativeMobile: !1,
    // nativeMobileWrapper: void 0,
    electron: !1,
    bex: !1,
    linux: !1,
    mac: !1,
    win: !1,
    cros: !1,
    chrome: !1,
    firefox: !1,
    opera: !1,
    safari: !1,
    vivaldi: !1,
    edge: !1,
    edgeChromium: !1,
    ie: !1,
    webkit: !1,
    android: !1,
    ios: !1,
    ipad: !1,
    iphone: !1,
    ipod: !1,
    kindle: !1,
    winphone: !1,
    blackberry: !1,
    playbook: !1,
    silk: !1
  };
  l.browser && (a[l.browser] = !0, a.version = l.version, a.versionNumber = parseInt(l.version, 10)), l.platform && (a[l.platform] = !0);
  const o = a.android || a.ios || a.bb || a.blackberry || a.ipad || a.iphone || a.ipod || a.kindle || a.playbook || a.silk || a["windows phone"];
  if (o === !0 || t.indexOf("mobile") !== -1 ? a.mobile = !0 : a.desktop = !0, a["windows phone"] && (a.winphone = !0, delete a["windows phone"]), a.edga || a.edgios || a.edg ? (a.edge = !0, l.browser = "edge") : a.crios ? (a.chrome = !0, l.browser = "chrome") : a.fxios && (a.firefox = !0, l.browser = "firefox"), (a.ipod || a.ipad || a.iphone) && (a.ios = !0), a.vivaldi && (l.browser = "vivaldi", a.vivaldi = !0), // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
  (a.chrome || a.opr || a.safari || a.vivaldi || a.mobile === !0 && a.ios !== !0 && o !== !0) && (a.webkit = !0), a.opr && (l.browser = "opera", a.opera = !0), a.safari && (a.blackberry || a.bb ? (l.browser = "blackberry", a.blackberry = !0) : a.playbook ? (l.browser = "playbook", a.playbook = !0) : a.android ? (l.browser = "android", a.android = !0) : a.kindle ? (l.browser = "kindle", a.kindle = !0) : a.silk && (l.browser = "silk", a.silk = !0)), a.name = l.browser, a.platform = l.platform, t.indexOf("electron") !== -1)
    a.electron = !0;
  else if (document.location.href.indexOf("-extension://") !== -1)
    a.bex = !0;
  else {
    if (window.Capacitor !== void 0 ? (a.capacitor = !0, a.nativeMobile = !0, a.nativeMobileWrapper = "capacitor") : (window._cordovaNative !== void 0 || window.cordova !== void 0) && (a.cordova = !0, a.nativeMobile = !0, a.nativeMobileWrapper = "cordova"), $n.value === !0 && (aa = { is: { ...a } }), mr === !0 && a.mac === !0 && (a.desktop === !0 && a.safari === !0 || a.nativeMobile === !0 && a.android !== !0 && a.ios !== !0 && a.ipad !== !0)) {
      delete a.mac, delete a.desktop;
      const r = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
      Object.assign(a, {
        mobile: !0,
        ios: !0,
        platform: r,
        [r]: !0
      });
    }
    a.mobile !== !0 && window.navigator.userAgentData && window.navigator.userAgentData.mobile && (delete a.desktop, a.mobile = !0);
  }
  return a;
}
const Ka = navigator.userAgent || navigator.vendor || window.opera, pu = {
  has: {
    touch: !1,
    webStorage: !1
  },
  within: { iframe: !1 }
}, Ge = {
  userAgent: Ka,
  is: yu(Ka),
  has: {
    touch: mr
  },
  within: {
    iframe: window.self !== window.top
  }
}, oa = {
  install(e) {
    const { $q: t } = e;
    $n.value === !0 ? (e.onSSRHydrated.push(() => {
      Object.assign(t.platform, Ge), $n.value = !1;
    }), t.platform = kn(this)) : t.platform = this;
  }
};
{
  let e;
  _t(Ge.has, "webStorage", () => {
    if (e !== void 0)
      return e;
    try {
      if (window.localStorage)
        return e = !0, !0;
    } catch {
    }
    return e = !1, !1;
  }), Object.assign(oa, Ge), $n.value === !0 && (Object.assign(oa, aa, pu), aa = null);
}
function Su(e, t, n) {
  function l() {
  }
  return ot(() => {
    e.value === !0 && void 0;
  }), {
    removeFromHistory: l,
    addToHistory() {
    }
  };
}
function vr() {
  let e = null;
  const t = we();
  function n() {
    e !== null && (clearTimeout(e), e = null);
  }
  return xn(n), ot(n), {
    removeTimeout: n,
    registerTimeout(l, a) {
      n(), wl(t) === !1 && (e = setTimeout(() => {
        e = null, l();
      }, a));
    }
  };
}
function hr() {
  let e;
  const t = we();
  function n() {
    e = void 0;
  }
  return xn(n), ot(n), {
    removeTick: n,
    registerTick(l) {
      e = l, De(() => {
        e === l && (wl(t) === !1 && e(), e = void 0);
      });
    }
  };
}
const gr = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
}, br = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function yr({
  showing: e,
  canShow: t,
  // optional
  hideOnRouteChange: n,
  // optional
  handleShow: l,
  // optional
  handleHide: a,
  // optional
  processOnMount: o
  // optional
}) {
  const r = we(), { props: i, emit: c, proxy: s } = r;
  let u;
  function f(P) {
    e.value === !0 ? h(P) : S(P);
  }
  function S(P) {
    if (i.disable === !0 || P !== void 0 && P.qAnchorHandled === !0 || t !== void 0 && t(P) !== !0) return;
    const _ = i["onUpdate:modelValue"] !== void 0;
    _ === !0 && (c("update:modelValue", !0), u = P, De(() => {
      u === P && (u = void 0);
    })), (i.modelValue === null || _ === !1) && b(P);
  }
  function b(P) {
    e.value !== !0 && (e.value = !0, c("beforeShow", P), l !== void 0 ? l(P) : c("show", P));
  }
  function h(P) {
    if (i.disable === !0) return;
    const _ = i["onUpdate:modelValue"] !== void 0;
    _ === !0 && (c("update:modelValue", !1), u = P, De(() => {
      u === P && (u = void 0);
    })), (i.modelValue === null || _ === !1) && x(P);
  }
  function x(P) {
    e.value !== !1 && (e.value = !1, c("beforeHide", P), a !== void 0 ? a(P) : c("hide", P));
  }
  function g(P) {
    i.disable === !0 && P === !0 ? i["onUpdate:modelValue"] !== void 0 && c("update:modelValue", !1) : P === !0 !== e.value && (P === !0 ? b : x)(u);
  }
  ce(() => i.modelValue, g), n !== void 0 && wa(r) === !0 && ce(() => s.$route.fullPath, () => {
    n.value === !0 && e.value === !0 && h();
  }), o === !0 && jt(() => {
    g(i.modelValue);
  });
  const T = { show: S, hide: h, toggle: f };
  return Object.assign(s, T), T;
}
const pr = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function Sr(e, t = () => {
}, n = () => {
}) {
  return {
    transitionProps: d(() => {
      const l = `q-transition--${e.transitionShow || t()}`, a = `q-transition--${e.transitionHide || n()}`;
      return {
        appear: !0,
        enterFromClass: `${l}-enter-from`,
        enterActiveClass: `${l}-enter-active`,
        enterToClass: `${l}-enter-to`,
        leaveFromClass: `${a}-leave-from`,
        leaveActiveClass: `${a}-leave-active`,
        leaveToClass: `${a}-leave-to`
      };
    }),
    transitionStyle: d(() => `--q-transition-duration: ${e.transitionDuration}ms`)
  };
}
let nn = [], Hn = [];
function wr(e) {
  Hn = Hn.filter((t) => t !== e);
}
function wu(e) {
  wr(e), Hn.push(e);
}
function Wa(e) {
  wr(e), Hn.length === 0 && nn.length !== 0 && (nn[nn.length - 1](), nn = []);
}
function Un(e) {
  Hn.length === 0 ? e() : nn.push(e);
}
function ku(e) {
  nn = nn.filter((t) => t !== e);
}
const Qa = {};
let xu = 1, _u = document.body;
function Cu(e, t) {
  const n = document.createElement("div");
  if (n.id = t !== void 0 ? `q-portal--${t}--${xu++}` : e, Qa.globalNodes !== void 0) {
    const l = Qa.globalNodes.class;
    l !== void 0 && (n.className = l);
  }
  return _u.appendChild(n), n;
}
function qu(e) {
  e.remove();
}
const yn = [];
function Eu(e) {
  return yn.find(
    (t) => t.contentEl !== null && t.contentEl.contains(e)
  );
}
function kr(e, t) {
  do {
    if (e.$options.name === "QMenu") {
      if (e.hide(t), e.$props.separateClosePopup === !0)
        return al(e);
    } else if (e.__qPortal === !0) {
      const n = al(e);
      return n !== void 0 && n.$options.name === "QPopupProxy" ? (e.hide(t), n) : e;
    }
    e = al(e);
  } while (e != null);
}
function Mu(e, t, n) {
  for (; n !== 0 && e !== void 0 && e !== null; ) {
    if (e.__qPortal === !0) {
      if (n--, e.$options.name === "QMenu") {
        e = kr(e, t);
        continue;
      }
      e.hide(t);
    }
    e = al(e);
  }
}
const Ru = Ce({
  name: "QPortal",
  setup(e, { slots: t }) {
    return () => t.default();
  }
});
function Tu(e) {
  for (e = e.parent; e != null; ) {
    if (e.type.name === "QGlobalDialog")
      return !0;
    if (e.type.name === "QDialog" || e.type.name === "QMenu")
      return !1;
    e = e.parent;
  }
  return !1;
}
function xr(e, t, n, l) {
  const a = J(!1), o = J(!1);
  let r = null;
  const i = {}, c = l === "dialog" && Tu(e);
  function s(f) {
    if (f === !0) {
      Wa(i), o.value = !0;
      return;
    }
    o.value = !1, a.value === !1 && (c === !1 && r === null && (r = Cu(!1, l)), a.value = !0, yn.push(e.proxy), wu(i));
  }
  function u(f) {
    if (o.value = !1, f !== !0) return;
    Wa(i), a.value = !1;
    const S = yn.indexOf(e.proxy);
    S !== -1 && yn.splice(S, 1), r !== null && (qu(r), r = null);
  }
  return Vi(() => {
    u(!0);
  }), e.proxy.__qPortal = !0, _t(e.proxy, "contentEl", () => t.value), {
    showPortal: s,
    hidePortal: u,
    portalIsActive: a,
    portalIsAccessible: o,
    renderPortal: () => c === !0 ? n() : a.value === !0 ? [v(Ai, { to: r }, v(Ru, n))] : void 0
  };
}
const _r = [Element, String], Pu = [null, document, document.body, document.scrollingElement, document.documentElement];
function Cr(e, t) {
  let n = Zi(t);
  if (n === void 0) {
    if (e == null)
      return window;
    n = e.closest(".scroll,.scroll-y,.overflow-auto");
  }
  return Pu.includes(n) ? window : n;
}
function Ou(e) {
  return e === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : e.scrollTop;
}
function Bu(e) {
  return e === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : e.scrollLeft;
}
let Wn;
function Vu() {
  if (Wn !== void 0)
    return Wn;
  const e = document.createElement("p"), t = document.createElement("div");
  la(e, {
    width: "100%",
    height: "200px"
  }), la(t, {
    position: "absolute",
    top: "0px",
    left: "0px",
    visibility: "hidden",
    width: "200px",
    height: "150px",
    overflow: "hidden"
  }), t.appendChild(e), document.body.appendChild(t);
  const n = e.offsetWidth;
  t.style.overflow = "scroll";
  let l = e.offsetWidth;
  return n === l && (l = t.clientWidth), t.remove(), Wn = n - l, Wn;
}
function Au(e, t = !0) {
  return !e || e.nodeType !== Node.ELEMENT_NODE ? !1 : t ? e.scrollHeight > e.clientHeight && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-y"])) : e.scrollWidth > e.clientWidth && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-x"]));
}
let Tn = 0, Dl, Ll, Vn, Fl = !1, Xa, Ja, Za, Zt = null;
function Du(e) {
  Lu(e) && Fe(e);
}
function Lu(e) {
  if (e.target === document.body || e.target.classList.contains("q-layout__backdrop"))
    return !0;
  const t = eu(e), n = e.shiftKey && !e.deltaX, l = !n && Math.abs(e.deltaX) <= Math.abs(e.deltaY), a = n || l ? e.deltaY : e.deltaX;
  for (let o = 0; o < t.length; o++) {
    const r = t[o];
    if (Au(r, l))
      return l ? a < 0 && r.scrollTop === 0 ? !0 : a > 0 && r.scrollTop + r.clientHeight === r.scrollHeight : a < 0 && r.scrollLeft === 0 ? !0 : a > 0 && r.scrollLeft + r.clientWidth === r.scrollWidth;
  }
  return !0;
}
function Ga(e) {
  e.target === document && (document.scrollingElement.scrollTop = document.scrollingElement.scrollTop);
}
function Qn(e) {
  Fl !== !0 && (Fl = !0, requestAnimationFrame(() => {
    Fl = !1;
    const { height: t } = e.target, { clientHeight: n, scrollTop: l } = document.scrollingElement;
    (Vn === void 0 || t !== window.innerHeight) && (Vn = n - t, document.scrollingElement.scrollTop = l), l > Vn && (document.scrollingElement.scrollTop -= Math.ceil((l - Vn) / 8));
  }));
}
function eo(e) {
  const t = document.body, n = window.visualViewport !== void 0;
  if (e === "add") {
    const { overflowY: l, overflowX: a } = window.getComputedStyle(t);
    Dl = Bu(window), Ll = Ou(window), Xa = t.style.left, Ja = t.style.top, Za = window.location.href, t.style.left = `-${Dl}px`, t.style.top = `-${Ll}px`, a !== "hidden" && (a === "scroll" || t.scrollWidth > window.innerWidth) && t.classList.add("q-body--force-scrollbar-x"), l !== "hidden" && (l === "scroll" || t.scrollHeight > window.innerHeight) && t.classList.add("q-body--force-scrollbar-y"), t.classList.add("q-body--prevent-scroll"), document.qScrollPrevented = !0, Ge.is.ios === !0 && (n === !0 ? (window.scrollTo(0, 0), window.visualViewport.addEventListener("resize", Qn, Ze.passiveCapture), window.visualViewport.addEventListener("scroll", Qn, Ze.passiveCapture), window.scrollTo(0, 0)) : window.addEventListener("scroll", Ga, Ze.passiveCapture));
  }
  Ge.is.desktop === !0 && Ge.is.mac === !0 && window[`${e}EventListener`]("wheel", Du, Ze.notPassive), e === "remove" && (Ge.is.ios === !0 && (n === !0 ? (window.visualViewport.removeEventListener("resize", Qn, Ze.passiveCapture), window.visualViewport.removeEventListener("scroll", Qn, Ze.passiveCapture)) : window.removeEventListener("scroll", Ga, Ze.passiveCapture)), t.classList.remove("q-body--prevent-scroll"), t.classList.remove("q-body--force-scrollbar-x"), t.classList.remove("q-body--force-scrollbar-y"), document.qScrollPrevented = !1, t.style.left = Xa, t.style.top = Ja, window.location.href === Za && window.scrollTo(Dl, Ll), Vn = void 0);
}
function Fu(e) {
  let t = "add";
  if (e === !0) {
    if (Tn++, Zt !== null) {
      clearTimeout(Zt), Zt = null;
      return;
    }
    if (Tn > 1) return;
  } else {
    if (Tn === 0 || (Tn--, Tn > 0)) return;
    if (t = "remove", Ge.is.ios === !0 && Ge.is.nativeMobile === !0) {
      Zt !== null && clearTimeout(Zt), Zt = setTimeout(() => {
        eo(t), Zt = null;
      }, 100);
      return;
    }
  }
  eo(t);
}
function $u() {
  let e;
  return {
    preventBodyScroll(t) {
      t !== e && (e !== void 0 || t === !0) && (e = t, Fu(t));
    }
  };
}
const an = [];
let wn;
function Hu(e) {
  wn = e.keyCode === 27;
}
function Iu() {
  wn === !0 && (wn = !1);
}
function ju(e) {
  wn === !0 && (wn = !1, It(e, 27) === !0 && an[an.length - 1](e));
}
function qr(e) {
  window[e]("keydown", Hu), window[e]("blur", Iu), window[e]("keyup", ju), wn = !1;
}
function Er(e) {
  Ge.is.desktop === !0 && (an.push(e), an.length === 1 && qr("addEventListener"));
}
function cl(e) {
  const t = an.indexOf(e);
  t !== -1 && (an.splice(t, 1), an.length === 0 && qr("removeEventListener"));
}
const on = [];
function Mr(e) {
  on[on.length - 1](e);
}
function Rr(e) {
  Ge.is.desktop === !0 && (on.push(e), on.length === 1 && document.body.addEventListener("focusin", Mr));
}
function ra(e) {
  const t = on.indexOf(e);
  t !== -1 && (on.splice(t, 1), on.length === 0 && document.body.removeEventListener("focusin", Mr));
}
let Xn = 0;
const Nu = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
}, to = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
}, kl = Ce({
  name: "QDialog",
  inheritAttrs: !1,
  props: {
    ...gr,
    ...pr,
    transitionShow: String,
    // override useTransitionProps
    transitionHide: String,
    // override useTransitionProps
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    backdropFilter: String,
    position: {
      type: String,
      default: "standard",
      validator: (e) => ["standard", "top", "bottom", "left", "right"].includes(e)
    }
  },
  emits: [
    ...br,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(e, { slots: t, emit: n, attrs: l }) {
    const a = we(), o = J(null), r = J(!1), i = J(!1);
    let c = null, s = null, u, f;
    const S = d(
      () => e.persistent !== !0 && e.noRouteDismiss !== !0 && e.seamless !== !0
    ), { preventBodyScroll: b } = $u(), { registerTimeout: h } = vr(), { registerTick: x, removeTick: g } = hr(), { transitionProps: T, transitionStyle: P } = Sr(
      e,
      () => to[e.position][0],
      () => to[e.position][1]
    ), _ = d(() => P.value + (e.backdropFilter !== void 0 ? `;backdrop-filter:${e.backdropFilter};-webkit-backdrop-filter:${e.backdropFilter}` : "")), { showPortal: y, hidePortal: p, portalIsAccessible: F, renderPortal: A } = xr(
      a,
      o,
      me,
      "dialog"
    ), { hide: U } = yr({
      showing: r,
      hideOnRouteChange: S,
      handleShow: K,
      handleHide: Q,
      processOnMount: !0
    }), { addToHistory: D, removeFromHistory: L } = Su(r), H = d(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${e.maximized === !0 ? "maximized" : "minimized"} q-dialog__inner--${e.position} ${Nu[e.position]}` + (i.value === !0 ? " q-dialog__inner--animating" : "") + (e.fullWidth === !0 ? " q-dialog__inner--fullwidth" : "") + (e.fullHeight === !0 ? " q-dialog__inner--fullheight" : "") + (e.square === !0 ? " q-dialog__inner--square" : "")
    ), E = d(() => r.value === !0 && e.seamless !== !0), $ = d(() => e.autoClose === !0 ? { onClick: C } : {}), M = d(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${E.value === !0 ? "modal" : "seamless"}`,
      l.class
    ]);
    ce(() => e.maximized, (j) => {
      r.value === !0 && q(j);
    }), ce(E, (j) => {
      b(j), j === !0 ? (Rr(ie), Er(Z)) : (ra(ie), cl(Z));
    });
    function K(j) {
      D(), s = e.noRefocus === !1 && document.activeElement !== null ? document.activeElement : null, q(e.maximized), y(), i.value = !0, e.noFocus !== !0 ? (document.activeElement !== null && document.activeElement.blur(), x(te)) : g(), h(() => {
        if (a.proxy.$q.platform.is.ios === !0) {
          if (e.seamless !== !0 && document.activeElement) {
            const { top: X, bottom: ge } = document.activeElement.getBoundingClientRect(), { innerHeight: z } = window, qe = window.visualViewport !== void 0 ? window.visualViewport.height : z;
            X > 0 && ge > qe / 2 && (document.scrollingElement.scrollTop = Math.min(
              document.scrollingElement.scrollHeight - qe,
              ge >= z ? 1 / 0 : Math.ceil(document.scrollingElement.scrollTop + ge - qe / 2)
            )), document.activeElement.scrollIntoView();
          }
          f = !0, o.value.click(), f = !1;
        }
        y(!0), i.value = !1, n("show", j);
      }, e.transitionDuration);
    }
    function Q(j) {
      g(), L(), de(!0), i.value = !0, p(), s !== null && (((j && j.type.indexOf("key") === 0 ? s.closest('[tabindex]:not([tabindex^="-"])') : void 0) || s).focus(), s = null), h(() => {
        p(!0), i.value = !1, n("hide", j);
      }, e.transitionDuration);
    }
    function te(j) {
      Un(() => {
        let X = o.value;
        if (X !== null) {
          if (j !== void 0) {
            const ge = X.querySelector(j);
            if (ge !== null) {
              ge.focus({ preventScroll: !0 });
              return;
            }
          }
          X.contains(document.activeElement) !== !0 && (X = X.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || X.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || X.querySelector("[autofocus], [data-autofocus]") || X, X.focus({ preventScroll: !0 }));
        }
      });
    }
    function N(j) {
      j && typeof j.focus == "function" ? j.focus({ preventScroll: !0 }) : te(), n("shake");
      const X = o.value;
      X !== null && (X.classList.remove("q-animate--scale"), X.classList.add("q-animate--scale"), c !== null && clearTimeout(c), c = setTimeout(() => {
        c = null, o.value !== null && (X.classList.remove("q-animate--scale"), te());
      }, 170));
    }
    function Z() {
      e.seamless !== !0 && (e.persistent === !0 || e.noEscDismiss === !0 ? e.maximized !== !0 && e.noShake !== !0 && N() : (n("escapeKey"), U()));
    }
    function de(j) {
      c !== null && (clearTimeout(c), c = null), (j === !0 || r.value === !0) && (q(!1), e.seamless !== !0 && (b(!1), ra(ie), cl(Z))), j !== !0 && (s = null);
    }
    function q(j) {
      j === !0 ? u !== !0 && (Xn < 1 && document.body.classList.add("q-body--dialog"), Xn++, u = !0) : u === !0 && (Xn < 2 && document.body.classList.remove("q-body--dialog"), Xn--, u = !1);
    }
    function C(j) {
      f !== !0 && (U(j), n("click", j));
    }
    function G(j) {
      e.persistent !== !0 && e.noBackdropDismiss !== !0 ? U(j) : e.noShake !== !0 && N();
    }
    function ie(j) {
      e.allowFocusOutside !== !0 && F.value === !0 && or(o.value, j.target) !== !0 && te('[tabindex]:not([tabindex="-1"])');
    }
    Object.assign(a.proxy, {
      // expose public methods
      focus: te,
      shake: N,
      // private but needed by QSelect
      __updateRefocusTarget(j) {
        s = j || null;
      }
    }), ot(de);
    function me() {
      return v("div", {
        role: "dialog",
        "aria-modal": E.value === !0 ? "true" : "false",
        ...l,
        class: M.value
      }, [
        v(Mt, {
          name: "q-transition--fade",
          appear: !0
        }, () => E.value === !0 ? v("div", {
          class: "q-dialog__backdrop fixed-full",
          style: _.value,
          "aria-hidden": "true",
          tabindex: -1,
          onClick: G
        }) : null),
        v(
          Mt,
          T.value,
          () => r.value === !0 ? v("div", {
            ref: o,
            class: H.value,
            style: P.value,
            tabindex: -1,
            ...$.value
          }, We(t.default)) : null
        )
      ]);
    }
    return A;
  }
});
function no(e) {
  if (e === !1)
    return 0;
  if (e === !0 || e === void 0)
    return 1;
  const t = parseInt(e, 10);
  return isNaN(t) ? 0 : t;
}
const rn = pa(
  {
    name: "close-popup",
    beforeMount(e, { value: t }) {
      const n = {
        depth: no(t),
        handler(l) {
          n.depth !== 0 && setTimeout(() => {
            const a = Eu(e);
            a !== void 0 && Mu(a, l, n.depth);
          });
        },
        handlerKey(l) {
          It(l, 13) === !0 && n.handler(l);
        }
      };
      e.__qclosepopup = n, e.addEventListener("click", n.handler), e.addEventListener("keyup", n.handlerKey);
    },
    updated(e, { value: t, oldValue: n }) {
      t !== n && (e.__qclosepopup.depth = no(t));
    },
    beforeUnmount(e) {
      const t = e.__qclosepopup;
      e.removeEventListener("click", t.handler), e.removeEventListener("keyup", t.handlerKey), delete e.__qclosepopup;
    }
  }
), Tr = Ce({
  name: "QCard",
  props: {
    ...rt,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: n } } = we(), l = it(e, n), a = d(
      () => "q-card" + (l.value === !0 ? " q-card--dark q-dark" : "") + (e.bordered === !0 ? " q-card--bordered" : "") + (e.square === !0 ? " q-card--square no-border-radius" : "") + (e.flat === !0 ? " q-card--flat no-shadow" : "")
    );
    return () => v(e.tag, { class: a.value }, We(t.default));
  }
}), zu = { class: "font-bold text-2xl" }, Uu = { class: "flex flex-col" }, Vf = /* @__PURE__ */ Nn({
  __name: "AnModal",
  props: {
    persistent: {
      type: Boolean,
      default: !1
    },
    hideOkBtn: {
      type: Boolean,
      default: !1
    },
    hideActions: {
      type: Boolean,
      default: !1
    },
    okLabel: {
      type: String,
      default: "Ok"
    },
    cancelLabel: {
      type: String,
      default: "Cancel"
    },
    title: {
      type: String,
      default: "Title"
    },
    btnsColor: {
      type: Object,
      default: "primary"
    },
    modalCardProps: {
      type: Object,
      required: !1
    }
  },
  emits: ["okClick", "hide"],
  setup(e, { expose: t, emit: n }) {
    const l = n, a = e, o = kn({
      open: !1
    }), r = () => {
      o.open = !0;
    }, i = () => {
      o.open = !1, l("hide");
    };
    return t({ show: r, hide: i }), (c, s) => (Le(), st(kl, {
      modelValue: o.open,
      "onUpdate:modelValue": s[1] || (s[1] = (u) => o.open = u),
      persistent: a.persistent,
      onHide: i
    }, {
      default: Me(() => {
        var u;
        return [
          ke(pl(Tr), Qt(a.modalCardProps, {
            class: `container ${((u = a.modalCardProps) == null ? void 0 : u.class) || ""}`
          }), {
            default: Me(() => [
              ke(bn, { class: "flex items-center justify-between" }, {
                default: Me(() => [
                  Ke("h2", zu, Dn(a.title), 1),
                  mt(c.$slots, "close-icon-btn", {
                    color: a.btnsColor,
                    disable: a.persistent
                  }, () => [
                    At(ke(Te, {
                      icon: "close",
                      color: a.btnsColor,
                      round: "",
                      flat: "",
                      disable: a.persistent
                    }, null, 8, ["color", "disable"]), [
                      [rn]
                    ])
                  ])
                ]),
                _: 3
              }),
              Ke("div", Uu, [
                ke(bn, { class: "flex flex-col gap-2" }, {
                  default: Me(() => [
                    mt(c.$slots, "content")
                  ]),
                  _: 3
                }),
                e.hideActions ? ze("", !0) : (Le(), st(ka, { key: 0 })),
                e.hideActions ? ze("", !0) : (Le(), st(bn, {
                  key: 1,
                  class: "flex items-center justify-end gap-2"
                }, {
                  default: Me(() => [
                    mt(c.$slots, "cancel-btn", {
                      color: a.btnsColor,
                      disable: a.persistent,
                      label: a.cancelLabel
                    }, () => [
                      At(ke(Te, {
                        color: a.btnsColor,
                        type: "button",
                        unelevated: "",
                        flat: "",
                        class: "border border-solid",
                        disable: a.persistent,
                        label: a.cancelLabel,
                        "no-caps": ""
                      }, null, 8, ["color", "disable", "label"]), [
                        [rn]
                      ])
                    ]),
                    mt(c.$slots, "ok-btn", {
                      click: () => l("okClick"),
                      color: a.btnsColor,
                      label: a.cancelLabel
                    }, () => [
                      e.hideOkBtn ? ze("", !0) : (Le(), st(Te, {
                        key: 0,
                        onClick: s[0] || (s[0] = (f) => l("okClick")),
                        color: a.btnsColor,
                        type: "button",
                        unelevated: "",
                        label: a.okLabel,
                        "no-caps": ""
                      }, null, 8, ["color", "label"]))
                    ])
                  ]),
                  _: 3
                }))
              ])
            ]),
            _: 3
          }, 16, ["class"])
        ];
      }),
      _: 3
    }, 8, ["modelValue", "persistent"]));
  }
}), Pr = "_q_fo_", Yu = Ce({
  name: "QForm",
  props: {
    autofocus: Boolean,
    noErrorFocus: Boolean,
    noResetFocus: Boolean,
    greedy: Boolean,
    onSubmit: Function
  },
  emits: ["reset", "validationSuccess", "validationError"],
  setup(e, { slots: t, emit: n }) {
    const l = we(), a = J(null);
    let o = 0;
    const r = [];
    function i(b) {
      const h = typeof b == "boolean" ? b : e.noErrorFocus !== !0, x = ++o, g = (_, y) => {
        n(`validation${_ === !0 ? "Success" : "Error"}`, y);
      }, T = (_) => {
        const y = _.validate();
        return typeof y.then == "function" ? y.then(
          (p) => ({ valid: p, comp: _ }),
          (p) => ({ valid: !1, comp: _, err: p })
        ) : Promise.resolve({ valid: y, comp: _ });
      };
      return (e.greedy === !0 ? Promise.all(r.map(T)).then((_) => _.filter((y) => y.valid !== !0)) : r.reduce(
        (_, y) => _.then(() => T(y).then((p) => {
          if (p.valid === !1)
            return Promise.reject(p);
        })),
        Promise.resolve()
      ).catch((_) => [_])).then((_) => {
        if (_ === void 0 || _.length === 0)
          return x === o && g(!0), !0;
        if (x === o) {
          const { comp: y, err: p } = _[0];
          if (p !== void 0 && console.error(p), g(!1, y), h === !0) {
            const F = _.find(({ comp: A }) => typeof A.focus == "function" && wl(A.$) === !1);
            F !== void 0 && F.comp.focus();
          }
        }
        return !1;
      });
    }
    function c() {
      o++, r.forEach((b) => {
        typeof b.resetValidation == "function" && b.resetValidation();
      });
    }
    function s(b) {
      b !== void 0 && Fe(b);
      const h = o + 1;
      i().then((x) => {
        h === o && x === !0 && (e.onSubmit !== void 0 ? n("submit", b) : b !== void 0 && b.target !== void 0 && typeof b.target.submit == "function" && b.target.submit());
      });
    }
    function u(b) {
      b !== void 0 && Fe(b), n("reset"), De(() => {
        c(), e.autofocus === !0 && e.noResetFocus !== !0 && f();
      });
    }
    function f() {
      Un(() => {
        if (a.value === null) return;
        const b = a.value.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || a.value.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || a.value.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(a.value.querySelectorAll("[tabindex]"), (h) => h.tabIndex !== -1);
        b != null && b.focus({ preventScroll: !0 });
      });
    }
    Di(Pr, {
      bindComponent(b) {
        r.push(b);
      },
      unbindComponent(b) {
        const h = r.indexOf(b);
        h !== -1 && r.splice(h, 1);
      }
    });
    let S = !1;
    return xn(() => {
      S = !0;
    }), Sl(() => {
      S === !0 && e.autofocus === !0 && f();
    }), jt(() => {
      e.autofocus === !0 && f();
    }), Object.assign(l.proxy, {
      validate: i,
      resetValidation: c,
      submit: s,
      reset: u,
      focus: f,
      getValidationComponents: () => r
    }), () => v("form", {
      class: "q-form",
      ref: a,
      onSubmit: s,
      onReset: u
    }, We(t.default));
  }
}), Ku = { class: "font-bold text-2xl" }, Wu = /* @__PURE__ */ Nn({
  __name: "AnModalForm",
  props: {
    isLoading: {
      type: Boolean,
      default: !1
    },
    formIsLoading: {
      type: Boolean,
      default: !1
    },
    okLabel: {
      type: String,
      default: "Ok"
    },
    cancelLabel: {
      type: String,
      default: "Cancel"
    },
    title: {
      type: String,
      default: "Title"
    },
    btnsColor: {
      type: Object,
      default: "primary"
    },
    modalCardProps: {
      type: Object,
      required: !1
    }
  },
  emits: ["submit", "hide"],
  setup(e, { expose: t, emit: n }) {
    const l = n, a = e, o = kn({
      open: !1
    }), r = () => {
      o.open = !0;
    }, i = () => {
      o.open = !1, l("hide");
    };
    return t({ show: r, hide: i }), (c, s) => (Le(), st(kl, {
      modelValue: o.open,
      "onUpdate:modelValue": s[1] || (s[1] = (u) => o.open = u),
      persistent: a.isLoading || a.formIsLoading,
      onHide: i
    }, {
      default: Me(() => {
        var u;
        return [
          ke(pl(Tr), Qt(a.modalCardProps, {
            class: `container ${((u = a.modalCardProps) == null ? void 0 : u.class) || ""}`
          }), {
            default: Me(() => [
              ke(bn, { class: "flex items-center justify-between" }, {
                default: Me(() => [
                  Ke("h2", Ku, Dn(a.title), 1),
                  mt(c.$slots, "close-icon-btn", {
                    color: a.btnsColor,
                    disable: a.isLoading || a.formIsLoading
                  }, () => [
                    At(ke(Te, {
                      icon: "close",
                      color: a.btnsColor,
                      round: "",
                      flat: "",
                      disable: a.isLoading || a.formIsLoading
                    }, null, 8, ["color", "disable"]), [
                      [rn]
                    ])
                  ])
                ]),
                _: 3
              }),
              ke(Yu, {
                onSubmit: s[0] || (s[0] = (f) => l("submit", f)),
                class: "flex flex-col"
              }, {
                default: Me(() => [
                  ke(bn, { class: "flex flex-col gap-2" }, {
                    default: Me(() => [
                      mt(c.$slots, "content")
                    ]),
                    _: 3
                  }),
                  ke(ka),
                  ke(bn, { class: "flex items-center justify-end gap-2" }, {
                    default: Me(() => [
                      mt(c.$slots, "cancel-btn", {
                        color: a.btnsColor,
                        disable: a.isLoading || a.formIsLoading,
                        label: a.cancelLabel
                      }, () => [
                        At(ke(Te, {
                          color: a.btnsColor,
                          type: "button",
                          unelevated: "",
                          flat: "",
                          class: "border border-solid",
                          disable: a.isLoading || a.formIsLoading,
                          label: a.cancelLabel,
                          "no-caps": ""
                        }, null, 8, ["color", "disable", "label"]), [
                          [rn]
                        ])
                      ]),
                      mt(c.$slots, "ok-btn", {
                        color: a.btnsColor,
                        label: a.okLabel,
                        disable: a.isLoading,
                        loading: a.formIsLoading
                      }, () => [
                        ke(Te, {
                          color: a.btnsColor,
                          type: "submit",
                          unelevated: "",
                          label: a.okLabel,
                          "no-caps": "",
                          disable: a.isLoading,
                          loading: a.formIsLoading
                        }, null, 8, ["color", "label", "disable", "loading"])
                      ])
                    ]),
                    _: 3
                  })
                ]),
                _: 3
              })
            ]),
            _: 3
          }, 16, ["class"])
        ];
      }),
      _: 3
    }, 8, ["modelValue", "persistent"]));
  }
}), Qu = '<defs><linearGradient x1="8.042%" y1="0%" x2="65.682%" y2="23.865%" id="a"><stop stop-color="currentColor" stop-opacity="0" offset="0%"></stop><stop stop-color="currentColor" stop-opacity=".631" offset="63.146%"></stop><stop stop-color="currentColor" offset="100%"></stop></linearGradient></defs><g transform="translate(1 1)" fill="none" fill-rule="evenodd"><path d="M36 18c0-9.94-8.06-18-18-18" stroke="url(#a)" stroke-width="2"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="0.9s" repeatCount="indefinite"></animateTransform></path><circle fill="currentColor" cx="36" cy="18" r="1"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="0.9s" repeatCount="indefinite"></animateTransform></circle></g>', Xu = Ce({
  name: "QSpinnerTail",
  props: nr,
  setup(e) {
    const { cSize: t, classes: n } = lr(e);
    return () => v("svg", {
      class: n.value,
      width: t.value,
      height: t.value,
      viewBox: "0 0 38 38",
      xmlns: "http://www.w3.org/2000/svg",
      innerHTML: Qu
    });
  }
}), Ju = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [l, a] of t)
    n[l] = a;
  return n;
}, Zu = {}, Gu = { class: "flex flex-1 justify-center items-center h-full" };
function es(e, t) {
  return Le(), Ft("div", Gu, [
    ke(Xu, { size: "2rem" })
  ]);
}
const Af = /* @__PURE__ */ Ju(Zu, [["render", es]]);
let $l, Jn = 0;
const tt = new Array(256);
for (let e = 0; e < 256; e++)
  tt[e] = (e + 256).toString(16).substring(1);
const ts = (() => {
  const e = typeof crypto < "u" ? crypto : typeof window < "u" ? window.crypto || window.msCrypto : void 0;
  if (e !== void 0) {
    if (e.randomBytes !== void 0)
      return e.randomBytes;
    if (e.getRandomValues !== void 0)
      return (t) => {
        const n = new Uint8Array(t);
        return e.getRandomValues(n), n;
      };
  }
  return (t) => {
    const n = [];
    for (let l = t; l > 0; l--)
      n.push(Math.floor(Math.random() * 256));
    return n;
  };
})(), lo = 4096;
function ia() {
  ($l === void 0 || Jn + 16 > lo) && (Jn = 0, $l = ts(lo));
  const e = Array.prototype.slice.call($l, Jn, Jn += 16);
  return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, tt[e[0]] + tt[e[1]] + tt[e[2]] + tt[e[3]] + "-" + tt[e[4]] + tt[e[5]] + "-" + tt[e[6]] + tt[e[7]] + "-" + tt[e[8]] + tt[e[9]] + "-" + tt[e[10]] + tt[e[11]] + tt[e[12]] + tt[e[13]] + tt[e[14]] + tt[e[15]];
}
function ns(e) {
  return e ?? null;
}
function ao(e, t) {
  return e ?? (t === !0 ? `f_${ia()}` : null);
}
function ls({ getValue: e, required: t = !0 } = {}) {
  if ($n.value === !0) {
    const n = e !== void 0 ? J(ns(e())) : J(null);
    return t === !0 && n.value === null && jt(() => {
      n.value = `f_${ia()}`;
    }), e !== void 0 && ce(e, (l) => {
      n.value = ao(l, t);
    }), n;
  }
  return e !== void 0 ? d(() => ao(e(), t)) : J(`f_${ia()}`);
}
const oo = /^on[A-Z]/;
function as() {
  const { attrs: e, vnode: t } = we(), n = {
    listeners: J({}),
    attributes: J({})
  };
  function l() {
    const a = {}, o = {};
    for (const r in e)
      r !== "class" && r !== "style" && oo.test(r) === !1 && (a[r] = e[r]);
    for (const r in t.props)
      oo.test(r) === !0 && (o[r] = t.props[r]);
    n.attributes.value = a, n.listeners.value = o;
  }
  return Xo(l), l(), n;
}
function os({ validate: e, resetValidation: t, requiresQForm: n }) {
  const l = Li(Pr, !1);
  if (l !== !1) {
    const { props: a, proxy: o } = we();
    Object.assign(o, { validate: e, resetValidation: t }), ce(() => a.disable, (r) => {
      r === !0 ? (typeof t == "function" && t(), l.unbindComponent(o)) : l.bindComponent(o);
    }), jt(() => {
      a.disable !== !0 && l.bindComponent(o);
    }), ot(() => {
      a.disable !== !0 && l.unbindComponent(o);
    });
  } else n === !0 && console.error("Parent QForm not found on useFormChild()!");
}
const ro = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, io = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, uo = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, Zn = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, Gn = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/, Hl = {
  date: (e) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e),
  time: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(e),
  fulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(e),
  timeOrFulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(e),
  // -- RFC 5322 --
  // -- Added in v2.6.6 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  // eslint-disable-next-line
  email: (e) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e),
  hexColor: (e) => ro.test(e),
  hexaColor: (e) => io.test(e),
  hexOrHexaColor: (e) => uo.test(e),
  rgbColor: (e) => Zn.test(e),
  rgbaColor: (e) => Gn.test(e),
  rgbOrRgbaColor: (e) => Zn.test(e) || Gn.test(e),
  hexOrRgbColor: (e) => ro.test(e) || Zn.test(e),
  hexaOrRgbaColor: (e) => io.test(e) || Gn.test(e),
  anyColor: (e) => uo.test(e) || Zn.test(e) || Gn.test(e)
};
function Or(e, t = 250, n) {
  let l = null;
  function a() {
    const o = arguments, r = () => {
      l = null, e.apply(this, o);
    };
    l !== null && clearTimeout(l), l = setTimeout(r, t);
  }
  return a.cancel = () => {
    l !== null && clearTimeout(l);
  }, a;
}
const rs = [!0, !1, "ondemand"], is = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    default: !1,
    // statement unneeded but avoids future vue implementation changes
    validator: (e) => rs.includes(e)
  }
};
function us(e, t) {
  const { props: n, proxy: l } = we(), a = J(!1), o = J(null), r = J(!1);
  os({ validate: x, resetValidation: h });
  let i = 0, c;
  const s = d(
    () => n.rules !== void 0 && n.rules !== null && n.rules.length !== 0
  ), u = d(() => n.disable !== !0 && s.value === !0 && t.value === !1), f = d(
    () => n.error === !0 || a.value === !0
  ), S = d(() => typeof n.errorMessage == "string" && n.errorMessage.length !== 0 ? n.errorMessage : o.value);
  ce(() => n.modelValue, () => {
    r.value = !0, u.value === !0 && n.lazyRules === !1 && g();
  });
  function b() {
    n.lazyRules !== "ondemand" && u.value === !0 && r.value === !0 && g();
  }
  ce(() => n.reactiveRules, (T) => {
    T === !0 ? c === void 0 && (c = ce(() => n.rules, b, { immediate: !0, deep: !0 })) : c !== void 0 && (c(), c = void 0);
  }, { immediate: !0 }), ce(() => n.lazyRules, b), ce(e, (T) => {
    T === !0 ? r.value = !0 : u.value === !0 && n.lazyRules !== "ondemand" && g();
  });
  function h() {
    i++, t.value = !1, r.value = !1, a.value = !1, o.value = null, g.cancel();
  }
  function x(T = n.modelValue) {
    if (n.disable === !0 || s.value === !1)
      return !0;
    const P = ++i, _ = t.value !== !0 ? () => {
      r.value = !0;
    } : () => {
    }, y = (F, A) => {
      F === !0 && _(), a.value = F, o.value = A || null, t.value = !1;
    }, p = [];
    for (let F = 0; F < n.rules.length; F++) {
      const A = n.rules[F];
      let U;
      if (typeof A == "function" ? U = A(T, Hl) : typeof A == "string" && Hl[A] !== void 0 && (U = Hl[A](T)), U === !1 || typeof U == "string")
        return y(!0, U), !1;
      U !== !0 && U !== void 0 && p.push(U);
    }
    return p.length === 0 ? (y(!1), !0) : (t.value = !0, Promise.all(p).then(
      (F) => {
        if (F === void 0 || Array.isArray(F) === !1 || F.length === 0)
          return P === i && y(!1), !0;
        const A = F.find((U) => U === !1 || typeof U == "string");
        return P === i && y(A !== void 0, A), A === void 0;
      },
      (F) => (P === i && (console.error(F), y(!0)), !1)
    ));
  }
  const g = Or(x, 0);
  return ot(() => {
    c !== void 0 && c(), g.cancel();
  }), Object.assign(l, { resetValidation: h, validate: x }), _t(l, "hasError", () => f.value), {
    isDirtyModel: r,
    hasRules: s,
    hasError: f,
    errorMessage: S,
    validate: x,
    resetValidation: h
  };
}
function In(e) {
  return e != null && ("" + e).length !== 0;
}
const ss = {
  ...rt,
  ...is,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String
}, xl = {
  ...ss,
  maxlength: [Number, String]
}, xa = ["update:modelValue", "clear", "focus", "blur"];
function _a({ requiredForAttr: e = !0, tagProp: t, changeEvent: n = !1 } = {}) {
  const { props: l, proxy: a } = we(), o = it(l, a.$q), r = ls({
    required: e,
    getValue: () => l.for
  });
  return {
    requiredForAttr: e,
    changeEvent: n,
    tag: t === !0 ? d(() => l.tag) : { value: "label" },
    isDark: o,
    editable: d(
      () => l.disable !== !0 && l.readonly !== !0
    ),
    innerLoading: J(!1),
    focused: J(!1),
    hasPopupOpen: !1,
    splitAttrs: as(),
    targetUid: r,
    rootRef: J(null),
    targetRef: J(null),
    controlRef: J(null)
    /**
         * user supplied additionals:
    
         * innerValue - computed
         * floatingLabel - computed
         * inputRef - computed
    
         * fieldClass - computed
         * hasShadow - computed
    
         * controlEvents - Object with fn(e)
    
         * getControl - fn
         * getInnerAppend - fn
         * getControlChild - fn
         * getShadowControl - fn
         * showPopup - fn
         */
  };
}
function Ca(e) {
  const { props: t, emit: n, slots: l, attrs: a, proxy: o } = we(), { $q: r } = o;
  let i = null;
  e.hasValue === void 0 && (e.hasValue = d(() => In(t.modelValue))), e.emitValue === void 0 && (e.emitValue = (N) => {
    n("update:modelValue", N);
  }), e.controlEvents === void 0 && (e.controlEvents = {
    onFocusin: D,
    onFocusout: L
  }), Object.assign(e, {
    clearValue: H,
    onControlFocusin: D,
    onControlFocusout: L,
    focus: A
  }), e.computedCounter === void 0 && (e.computedCounter = d(() => {
    if (t.counter !== !1) {
      const N = typeof t.modelValue == "string" || typeof t.modelValue == "number" ? ("" + t.modelValue).length : Array.isArray(t.modelValue) === !0 ? t.modelValue.length : 0, Z = t.maxlength !== void 0 ? t.maxlength : t.maxValues;
      return N + (Z !== void 0 ? " / " + Z : "");
    }
  }));
  const {
    isDirtyModel: c,
    hasRules: s,
    hasError: u,
    errorMessage: f,
    resetValidation: S
  } = us(e.focused, e.innerLoading), b = e.floatingLabel !== void 0 ? d(() => t.stackLabel === !0 || e.focused.value === !0 || e.floatingLabel.value === !0) : d(() => t.stackLabel === !0 || e.focused.value === !0 || e.hasValue.value === !0), h = d(
    () => t.bottomSlots === !0 || t.hint !== void 0 || s.value === !0 || t.counter === !0 || t.error !== null
  ), x = d(() => t.filled === !0 ? "filled" : t.outlined === !0 ? "outlined" : t.borderless === !0 ? "borderless" : t.standout ? "standout" : "standard"), g = d(
    () => `q-field row no-wrap items-start q-field--${x.value}` + (e.fieldClass !== void 0 ? ` ${e.fieldClass.value}` : "") + (t.rounded === !0 ? " q-field--rounded" : "") + (t.square === !0 ? " q-field--square" : "") + (b.value === !0 ? " q-field--float" : "") + (P.value === !0 ? " q-field--labeled" : "") + (t.dense === !0 ? " q-field--dense" : "") + (t.itemAligned === !0 ? " q-field--item-aligned q-item-type" : "") + (e.isDark.value === !0 ? " q-field--dark" : "") + (e.getControl === void 0 ? " q-field--auto-height" : "") + (e.focused.value === !0 ? " q-field--focused" : "") + (u.value === !0 ? " q-field--error" : "") + (u.value === !0 || e.focused.value === !0 ? " q-field--highlighted" : "") + (t.hideBottomSpace !== !0 && h.value === !0 ? " q-field--with-bottom" : "") + (t.disable === !0 ? " q-field--disabled" : t.readonly === !0 ? " q-field--readonly" : "")
  ), T = d(
    () => "q-field__control relative-position row no-wrap" + (t.bgColor !== void 0 ? ` bg-${t.bgColor}` : "") + (u.value === !0 ? " text-negative" : typeof t.standout == "string" && t.standout.length !== 0 && e.focused.value === !0 ? ` ${t.standout}` : t.color !== void 0 ? ` text-${t.color}` : "")
  ), P = d(
    () => t.labelSlot === !0 || t.label !== void 0
  ), _ = d(
    () => "q-field__label no-pointer-events absolute ellipsis" + (t.labelColor !== void 0 && u.value !== !0 ? ` text-${t.labelColor}` : "")
  ), y = d(() => ({
    id: e.targetUid.value,
    editable: e.editable.value,
    focused: e.focused.value,
    floatingLabel: b.value,
    modelValue: t.modelValue,
    emitValue: e.emitValue
  })), p = d(() => {
    const N = {};
    return e.targetUid.value && (N.for = e.targetUid.value), t.disable === !0 && (N["aria-disabled"] = "true"), N;
  });
  function F() {
    const N = document.activeElement;
    let Z = e.targetRef !== void 0 && e.targetRef.value;
    Z && (N === null || N.id !== e.targetUid.value) && (Z.hasAttribute("tabindex") === !0 || (Z = Z.querySelector("[tabindex]")), Z && Z !== N && Z.focus({ preventScroll: !0 }));
  }
  function A() {
    Un(F);
  }
  function U() {
    ku(F);
    const N = document.activeElement;
    N !== null && e.rootRef.value.contains(N) && N.blur();
  }
  function D(N) {
    i !== null && (clearTimeout(i), i = null), e.editable.value === !0 && e.focused.value === !1 && (e.focused.value = !0, n("focus", N));
  }
  function L(N, Z) {
    i !== null && clearTimeout(i), i = setTimeout(() => {
      i = null, !(document.hasFocus() === !0 && (e.hasPopupOpen === !0 || e.controlRef === void 0 || e.controlRef.value === null || e.controlRef.value.contains(document.activeElement) !== !1)) && (e.focused.value === !0 && (e.focused.value = !1, n("blur", N)), Z !== void 0 && Z());
    });
  }
  function H(N) {
    Fe(N), r.platform.is.mobile !== !0 ? (e.targetRef !== void 0 && e.targetRef.value || e.rootRef.value).focus() : e.rootRef.value.contains(document.activeElement) === !0 && document.activeElement.blur(), t.type === "file" && (e.inputRef.value.value = null), n("update:modelValue", null), e.changeEvent === !0 && n("change", null), n("clear", t.modelValue), De(() => {
      const Z = c.value;
      S(), c.value = Z;
    });
  }
  function E(N) {
    [13, 32].includes(N.keyCode) && H(N);
  }
  function $() {
    const N = [];
    return l.prepend !== void 0 && N.push(
      v("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: ct
      }, l.prepend())
    ), N.push(
      v("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, M())
    ), u.value === !0 && t.noErrorIcon === !1 && N.push(
      Q("error", [
        v(pt, { name: r.iconSet.field.error, color: "negative" })
      ])
    ), t.loading === !0 || e.innerLoading.value === !0 ? N.push(
      Q(
        "inner-loading-append",
        l.loading !== void 0 ? l.loading() : [v(ar, { color: t.color })]
      )
    ) : t.clearable === !0 && e.hasValue.value === !0 && e.editable.value === !0 && N.push(
      Q("inner-clearable-append", [
        v(pt, {
          class: "q-field__focusable-action",
          name: t.clearIcon || r.iconSet.field.clear,
          tabindex: 0,
          role: "button",
          "aria-hidden": "false",
          "aria-label": r.lang.label.clear,
          onKeyup: E,
          onClick: H
        })
      ])
    ), l.append !== void 0 && N.push(
      v("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: ct
      }, l.append())
    ), e.getInnerAppend !== void 0 && N.push(
      Q("inner-append", e.getInnerAppend())
    ), e.getControlChild !== void 0 && N.push(
      e.getControlChild()
    ), N;
  }
  function M() {
    const N = [];
    return t.prefix !== void 0 && t.prefix !== null && N.push(
      v("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, t.prefix)
    ), e.getShadowControl !== void 0 && e.hasShadow.value === !0 && N.push(
      e.getShadowControl()
    ), e.getControl !== void 0 ? N.push(e.getControl()) : l.rawControl !== void 0 ? N.push(l.rawControl()) : l.control !== void 0 && N.push(
      v("div", {
        ref: e.targetRef,
        class: "q-field__native row",
        tabindex: -1,
        ...e.splitAttrs.attributes.value,
        "data-autofocus": t.autofocus === !0 || void 0
      }, l.control(y.value))
    ), P.value === !0 && N.push(
      v("div", {
        class: _.value
      }, We(l.label, t.label))
    ), t.suffix !== void 0 && t.suffix !== null && N.push(
      v("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, t.suffix)
    ), N.concat(We(l.default));
  }
  function K() {
    let N, Z;
    u.value === !0 ? f.value !== null ? (N = [v("div", { role: "alert" }, f.value)], Z = `q--slot-error-${f.value}`) : (N = We(l.error), Z = "q--slot-error") : (t.hideHint !== !0 || e.focused.value === !0) && (t.hint !== void 0 ? (N = [v("div", t.hint)], Z = `q--slot-hint-${t.hint}`) : (N = We(l.hint), Z = "q--slot-hint"));
    const de = t.counter === !0 || l.counter !== void 0;
    if (t.hideBottomSpace === !0 && de === !1 && N === void 0) return;
    const q = v("div", {
      key: Z,
      class: "q-field__messages col"
    }, N);
    return v("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (t.hideBottomSpace !== !0 ? "animated" : "stale"),
      onClick: ct
    }, [
      t.hideBottomSpace === !0 ? q : v(Mt, { name: "q-transition--field-message" }, () => q),
      de === !0 ? v("div", {
        class: "q-field__counter"
      }, l.counter !== void 0 ? l.counter() : e.computedCounter.value) : null
    ]);
  }
  function Q(N, Z) {
    return Z === null ? null : v("div", {
      key: N,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, Z);
  }
  let te = !1;
  return xn(() => {
    te = !0;
  }), Sl(() => {
    te === !0 && t.autofocus === !0 && o.focus();
  }), t.autofocus === !0 && jt(() => {
    o.focus();
  }), ot(() => {
    i !== null && clearTimeout(i);
  }), Object.assign(o, { focus: A, blur: U }), function() {
    const Z = e.getControl === void 0 && l.control === void 0 ? {
      ...e.splitAttrs.attributes.value,
      "data-autofocus": t.autofocus === !0 || void 0,
      ...p.value
    } : p.value;
    return v(e.tag.value, {
      ref: e.rootRef,
      class: [
        g.value,
        a.class
      ],
      style: a.style,
      ...Z
    }, [
      l.before !== void 0 ? v("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: ct
      }, l.before()) : null,
      v("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        v("div", {
          ref: e.controlRef,
          class: T.value,
          tabindex: -1,
          ...e.controlEvents
        }, $()),
        h.value === !0 ? K() : null
      ]),
      l.after !== void 0 ? v("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: ct
      }, l.after()) : null
    ]);
  };
}
const so = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
}, dl = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleLowerCase() }
}, Br = Object.keys(dl);
Br.forEach((e) => {
  dl[e].regex = new RegExp(dl[e].pattern);
});
const cs = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + Br.join("") + "])|(.)", "g"), co = /[.*+?^${}()|[\]\\]/g, Ye = "", ds = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function fs(e, t, n, l) {
  let a, o, r, i, c, s;
  const u = J(null), f = J(b());
  function S() {
    return e.autogrow === !0 || ["textarea", "text", "search", "url", "tel", "password"].includes(e.type);
  }
  ce(() => e.type + e.autogrow, x), ce(() => e.mask, (D) => {
    if (D !== void 0)
      g(f.value, !0);
    else {
      const L = A(f.value);
      x(), e.modelValue !== L && t("update:modelValue", L);
    }
  }), ce(() => e.fillMask + e.reverseFillMask, () => {
    u.value === !0 && g(f.value, !0);
  }), ce(() => e.unmaskedValue, () => {
    u.value === !0 && g(f.value);
  });
  function b() {
    if (x(), u.value === !0) {
      const D = p(A(e.modelValue));
      return e.fillMask !== !1 ? U(D) : D;
    }
    return e.modelValue;
  }
  function h(D) {
    if (D < a.length)
      return a.slice(-D);
    let L = "", H = a;
    const E = H.indexOf(Ye);
    if (E !== -1) {
      for (let $ = D - H.length; $ > 0; $--)
        L += Ye;
      H = H.slice(0, E) + L + H.slice(E);
    }
    return H;
  }
  function x() {
    if (u.value = e.mask !== void 0 && e.mask.length !== 0 && S(), u.value === !1) {
      i = void 0, a = "", o = "";
      return;
    }
    const D = so[e.mask] === void 0 ? e.mask : so[e.mask], L = typeof e.fillMask == "string" && e.fillMask.length !== 0 ? e.fillMask.slice(0, 1) : "_", H = L.replace(co, "\\$&"), E = [], $ = [], M = [];
    let K = e.reverseFillMask === !0, Q = "", te = "";
    D.replace(cs, (q, C, G, ie, me) => {
      if (ie !== void 0) {
        const j = dl[ie];
        M.push(j), te = j.negate, K === !0 && ($.push("(?:" + te + "+)?(" + j.pattern + "+)?(?:" + te + "+)?(" + j.pattern + "+)?"), K = !1), $.push("(?:" + te + "+)?(" + j.pattern + ")?");
      } else if (G !== void 0)
        Q = "\\" + (G === "\\" ? "" : G), M.push(G), E.push("([^" + Q + "]+)?" + Q + "?");
      else {
        const j = C !== void 0 ? C : me;
        Q = j === "\\" ? "\\\\\\\\" : j.replace(co, "\\\\$&"), M.push(j), E.push("([^" + Q + "]+)?" + Q + "?");
      }
    });
    const N = new RegExp(
      "^" + E.join("") + "(" + (Q === "" ? "." : "[^" + Q + "]") + "+)?" + (Q === "" ? "" : "[" + Q + "]*") + "$"
    ), Z = $.length - 1, de = $.map((q, C) => C === 0 && e.reverseFillMask === !0 ? new RegExp("^" + H + "*" + q) : C === Z ? new RegExp(
      "^" + q + "(" + (te === "" ? "." : te) + "+)?" + (e.reverseFillMask === !0 ? "$" : H + "*")
    ) : new RegExp("^" + q));
    r = M, i = (q) => {
      const C = N.exec(e.reverseFillMask === !0 ? q : q.slice(0, M.length + 1));
      C !== null && (q = C.slice(1).join(""));
      const G = [], ie = de.length;
      for (let me = 0, j = q; me < ie; me++) {
        const X = de[me].exec(j);
        if (X === null)
          break;
        j = j.slice(X.shift().length), G.push(...X);
      }
      return G.length !== 0 ? G.join("") : q;
    }, a = M.map((q) => typeof q == "string" ? q : Ye).join(""), o = a.split(Ye).join(L);
  }
  function g(D, L, H) {
    const E = l.value, $ = E.selectionEnd, M = E.value.length - $, K = A(D);
    L === !0 && x();
    const Q = p(K), te = e.fillMask !== !1 ? U(Q) : Q, N = f.value !== te;
    E.value !== te && (E.value = te), N === !0 && (f.value = te), document.activeElement === E && De(() => {
      if (te === o) {
        const de = e.reverseFillMask === !0 ? o.length : 0;
        E.setSelectionRange(de, de, "forward");
        return;
      }
      if (H === "insertFromPaste" && e.reverseFillMask !== !0) {
        const de = E.selectionEnd;
        let q = $ - 1;
        for (let C = c; C <= q && C < de; C++)
          a[C] !== Ye && q++;
        P.right(E, q);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(H) !== -1) {
        const de = e.reverseFillMask === !0 ? $ === 0 ? te.length > Q.length ? 1 : 0 : Math.max(0, te.length - (te === o ? 0 : Math.min(Q.length, M) + 1)) + 1 : $;
        E.setSelectionRange(de, de, "forward");
        return;
      }
      if (e.reverseFillMask === !0)
        if (N === !0) {
          const de = Math.max(0, te.length - (te === o ? 0 : Math.min(Q.length, M + 1)));
          de === 1 && $ === 1 ? E.setSelectionRange(de, de, "forward") : P.rightReverse(E, de);
        } else {
          const de = te.length - M;
          E.setSelectionRange(de, de, "backward");
        }
      else if (N === !0) {
        const de = Math.max(0, a.indexOf(Ye), Math.min(Q.length, $) - 1);
        P.right(E, de);
      } else {
        const de = $ - 1;
        P.right(E, de);
      }
    });
    const Z = e.unmaskedValue === !0 ? A(te) : te;
    String(e.modelValue) !== Z && (e.modelValue !== null || Z !== "") && n(Z, !0);
  }
  function T(D, L, H) {
    const E = p(A(D.value));
    L = Math.max(0, a.indexOf(Ye), Math.min(E.length, L)), c = L, D.setSelectionRange(L, H, "forward");
  }
  const P = {
    left(D, L) {
      const H = a.slice(L - 1).indexOf(Ye) === -1;
      let E = Math.max(0, L - 1);
      for (; E >= 0; E--)
        if (a[E] === Ye) {
          L = E, H === !0 && L++;
          break;
        }
      if (E < 0 && a[L] !== void 0 && a[L] !== Ye)
        return P.right(D, 0);
      L >= 0 && D.setSelectionRange(L, L, "backward");
    },
    right(D, L) {
      const H = D.value.length;
      let E = Math.min(H, L + 1);
      for (; E <= H; E++)
        if (a[E] === Ye) {
          L = E;
          break;
        } else a[E - 1] === Ye && (L = E);
      if (E > H && a[L - 1] !== void 0 && a[L - 1] !== Ye)
        return P.left(D, H);
      D.setSelectionRange(L, L, "forward");
    },
    leftReverse(D, L) {
      const H = h(D.value.length);
      let E = Math.max(0, L - 1);
      for (; E >= 0; E--)
        if (H[E - 1] === Ye) {
          L = E;
          break;
        } else if (H[E] === Ye && (L = E, E === 0))
          break;
      if (E < 0 && H[L] !== void 0 && H[L] !== Ye)
        return P.rightReverse(D, 0);
      L >= 0 && D.setSelectionRange(L, L, "backward");
    },
    rightReverse(D, L) {
      const H = D.value.length, E = h(H), $ = E.slice(0, L + 1).indexOf(Ye) === -1;
      let M = Math.min(H, L + 1);
      for (; M <= H; M++)
        if (E[M - 1] === Ye) {
          L = M, L > 0 && $ === !0 && L--;
          break;
        }
      if (M > H && E[L - 1] !== void 0 && E[L - 1] !== Ye)
        return P.leftReverse(D, H);
      D.setSelectionRange(L, L, "forward");
    }
  };
  function _(D) {
    t("click", D), s = void 0;
  }
  function y(D) {
    if (t("keydown", D), Sa(D) === !0 || D.altKey === !0) return;
    const L = l.value, H = L.selectionStart, E = L.selectionEnd;
    if (D.shiftKey || (s = void 0), D.keyCode === 37 || D.keyCode === 39) {
      D.shiftKey && s === void 0 && (s = L.selectionDirection === "forward" ? H : E);
      const $ = P[(D.keyCode === 39 ? "right" : "left") + (e.reverseFillMask === !0 ? "Reverse" : "")];
      if (D.preventDefault(), $(L, s === H ? E : H), D.shiftKey) {
        const M = L.selectionStart;
        L.setSelectionRange(Math.min(s, M), Math.max(s, M), "forward");
      }
    } else D.keyCode === 8 && e.reverseFillMask !== !0 && H === E ? (P.left(L, H), L.setSelectionRange(L.selectionStart, E, "backward")) : D.keyCode === 46 && e.reverseFillMask === !0 && H === E && (P.rightReverse(L, E), L.setSelectionRange(H, L.selectionEnd, "forward"));
  }
  function p(D) {
    if (D == null || D === "")
      return "";
    if (e.reverseFillMask === !0)
      return F(D);
    const L = r;
    let H = 0, E = "";
    for (let $ = 0; $ < L.length; $++) {
      const M = D[H], K = L[$];
      if (typeof K == "string")
        E += K, M === K && H++;
      else if (M !== void 0 && K.regex.test(M))
        E += K.transform !== void 0 ? K.transform(M) : M, H++;
      else
        return E;
    }
    return E;
  }
  function F(D) {
    const L = r, H = a.indexOf(Ye);
    let E = D.length - 1, $ = "";
    for (let M = L.length - 1; M >= 0 && E !== -1; M--) {
      const K = L[M];
      let Q = D[E];
      if (typeof K == "string")
        $ = K + $, Q === K && E--;
      else if (Q !== void 0 && K.regex.test(Q))
        do
          $ = (K.transform !== void 0 ? K.transform(Q) : Q) + $, E--, Q = D[E];
        while (H === M && Q !== void 0 && K.regex.test(Q));
      else
        return $;
    }
    return $;
  }
  function A(D) {
    return typeof D != "string" || i === void 0 ? typeof D == "number" ? i("" + D) : D : i(D);
  }
  function U(D) {
    return o.length - D.length <= 0 ? D : e.reverseFillMask === !0 && D.length !== 0 ? o.slice(0, -D.length) + D : D + o.slice(D.length);
  }
  return {
    innerValue: f,
    hasMask: u,
    moveCursorForPaste: T,
    updateMaskValue: g,
    onMaskedKeydown: y,
    onMaskedClick: _
  };
}
const qn = {
  name: String
};
function Vr(e) {
  return d(() => ({
    type: "hidden",
    name: e.name,
    value: e.modelValue
  }));
}
function _l(e = {}) {
  return (t, n, l) => {
    t[n](
      v("input", {
        class: "hidden" + (l || ""),
        ...e.value
      })
    );
  };
}
function Ar(e) {
  return d(() => e.name || e.for);
}
function ms(e, t) {
  function n() {
    const l = e.modelValue;
    try {
      const a = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      return Object(l) === l && ("length" in l ? Array.from(l) : [l]).forEach((o) => {
        a.items.add(o);
      }), {
        files: a.files
      };
    } catch {
      return {
        files: void 0
      };
    }
  }
  return d(() => {
    if (e.type === "file")
      return n();
  });
}
const vs = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/, hs = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u, gs = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/, bs = /[a-z0-9_ -]$/i;
function Dr(e) {
  return function(n) {
    if (n.type === "compositionend" || n.type === "change") {
      if (n.target.qComposing !== !0) return;
      n.target.qComposing = !1, e(n);
    } else n.type === "compositionupdate" && n.target.qComposing !== !0 && typeof n.data == "string" && (Ge.is.firefox === !0 ? bs.test(n.data) === !1 : vs.test(n.data) === !0 || hs.test(n.data) === !0 || gs.test(n.data) === !0) === !0 && (n.target.qComposing = !0);
  };
}
const en = Ce({
  name: "QInput",
  inheritAttrs: !1,
  props: {
    ...xl,
    ...ds,
    ...qn,
    // override of useFieldProps > modelValue
    modelValue: [String, Number, FileList],
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...xa,
    "paste",
    "change",
    "keydown",
    "click",
    "animationend"
  ],
  setup(e, { emit: t, attrs: n }) {
    const { proxy: l } = we(), { $q: a } = l, o = {};
    let r = NaN, i, c, s = null, u;
    const f = J(null), S = Ar(e), {
      innerValue: b,
      hasMask: h,
      moveCursorForPaste: x,
      updateMaskValue: g,
      onMaskedKeydown: T,
      onMaskedClick: P
    } = fs(e, t, Q, f), _ = ms(
      e
    ), y = d(() => In(b.value)), p = Dr(M), F = _a({ changeEvent: !0 }), A = d(
      () => e.type === "textarea" || e.autogrow === !0
    ), U = d(
      () => A.value === !0 || ["text", "search", "url", "tel", "password"].includes(e.type)
    ), D = d(() => {
      const C = {
        ...F.splitAttrs.listeners.value,
        onInput: M,
        onPaste: $,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange: N,
        onBlur: Z,
        onFocus: bt
      };
      return C.onCompositionstart = C.onCompositionupdate = C.onCompositionend = p, h.value === !0 && (C.onKeydown = T, C.onClick = P), e.autogrow === !0 && (C.onAnimationend = K), C;
    }), L = d(() => {
      const C = {
        tabindex: 0,
        "data-autofocus": e.autofocus === !0 || void 0,
        rows: e.type === "textarea" ? 6 : void 0,
        "aria-label": e.label,
        name: S.value,
        ...F.splitAttrs.attributes.value,
        id: F.targetUid.value,
        maxlength: e.maxlength,
        disabled: e.disable === !0,
        readonly: e.readonly === !0
      };
      return A.value === !1 && (C.type = e.type), e.autogrow === !0 && (C.rows = 1), C;
    });
    ce(() => e.type, () => {
      f.value && (f.value.value = e.modelValue);
    }), ce(() => e.modelValue, (C) => {
      if (h.value === !0) {
        if (c === !0 && (c = !1, String(C) === r))
          return;
        g(C);
      } else b.value !== C && (b.value = C, e.type === "number" && o.hasOwnProperty("value") === !0 && (i === !0 ? i = !1 : delete o.value));
      e.autogrow === !0 && De(te);
    }), ce(() => e.autogrow, (C) => {
      C === !0 ? De(te) : f.value !== null && n.rows > 0 && (f.value.style.height = "auto");
    }), ce(() => e.dense, () => {
      e.autogrow === !0 && De(te);
    });
    function H() {
      Un(() => {
        const C = document.activeElement;
        f.value !== null && f.value !== C && (C === null || C.id !== F.targetUid.value) && f.value.focus({ preventScroll: !0 });
      });
    }
    function E() {
      f.value !== null && f.value.select();
    }
    function $(C) {
      if (h.value === !0 && e.reverseFillMask !== !0) {
        const G = C.target;
        x(G, G.selectionStart, G.selectionEnd);
      }
      t("paste", C);
    }
    function M(C) {
      if (!C || !C.target) return;
      if (e.type === "file") {
        t("update:modelValue", C.target.files);
        return;
      }
      const G = C.target.value;
      if (C.target.qComposing === !0) {
        o.value = G;
        return;
      }
      if (h.value === !0)
        g(G, !1, C.inputType);
      else if (Q(G), U.value === !0 && C.target === document.activeElement) {
        const { selectionStart: ie, selectionEnd: me } = C.target;
        ie !== void 0 && me !== void 0 && De(() => {
          C.target === document.activeElement && G.indexOf(C.target.value) === 0 && C.target.setSelectionRange(ie, me);
        });
      }
      e.autogrow === !0 && te();
    }
    function K(C) {
      t("animationend", C), te();
    }
    function Q(C, G) {
      u = () => {
        s = null, e.type !== "number" && o.hasOwnProperty("value") === !0 && delete o.value, e.modelValue !== C && r !== C && (r = C, G === !0 && (c = !0), t("update:modelValue", C), De(() => {
          r === C && (r = NaN);
        })), u = void 0;
      }, e.type === "number" && (i = !0, o.value = C), e.debounce !== void 0 ? (s !== null && clearTimeout(s), o.value = C, s = setTimeout(u, e.debounce)) : u();
    }
    function te() {
      requestAnimationFrame(() => {
        const C = f.value;
        if (C !== null) {
          const G = C.parentNode.style, { scrollTop: ie } = C, { overflowY: me, maxHeight: j } = a.platform.is.firefox === !0 ? {} : window.getComputedStyle(C), X = me !== void 0 && me !== "scroll";
          X === !0 && (C.style.overflowY = "hidden"), G.marginBottom = C.scrollHeight - 1 + "px", C.style.height = "1px", C.style.height = C.scrollHeight + "px", X === !0 && (C.style.overflowY = parseInt(j, 10) < C.scrollHeight ? "auto" : "hidden"), G.marginBottom = "", C.scrollTop = ie;
        }
      });
    }
    function N(C) {
      p(C), s !== null && (clearTimeout(s), s = null), u !== void 0 && u(), t("change", C.target.value);
    }
    function Z(C) {
      C !== void 0 && bt(C), s !== null && (clearTimeout(s), s = null), u !== void 0 && u(), i = !1, c = !1, delete o.value, e.type !== "file" && setTimeout(() => {
        f.value !== null && (f.value.value = b.value !== void 0 ? b.value : "");
      });
    }
    function de() {
      return o.hasOwnProperty("value") === !0 ? o.value : b.value !== void 0 ? b.value : "";
    }
    ot(() => {
      Z();
    }), jt(() => {
      e.autogrow === !0 && te();
    }), Object.assign(F, {
      innerValue: b,
      fieldClass: d(
        () => `q-${A.value === !0 ? "textarea" : "input"}` + (e.autogrow === !0 ? " q-textarea--autogrow" : "")
      ),
      hasShadow: d(
        () => e.type !== "file" && typeof e.shadowText == "string" && e.shadowText.length !== 0
      ),
      inputRef: f,
      emitValue: Q,
      hasValue: y,
      floatingLabel: d(
        () => y.value === !0 && (e.type !== "number" || isNaN(b.value) === !1) || In(e.displayValue)
      ),
      getControl: () => v(A.value === !0 ? "textarea" : "input", {
        ref: f,
        class: [
          "q-field__native q-placeholder",
          e.inputClass
        ],
        style: e.inputStyle,
        ...L.value,
        ...D.value,
        ...e.type !== "file" ? { value: de() } : _.value
      }),
      getShadowControl: () => v("div", {
        class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (A.value === !0 ? "" : " text-no-wrap")
      }, [
        v("span", { class: "invisible" }, de()),
        v("span", e.shadowText)
      ])
    });
    const q = Ca(F);
    return Object.assign(l, {
      focus: H,
      select: E,
      getNativeElement: () => f.value
      // deprecated
    }), _t(l, "nativeEl", () => f.value), q;
  }
});
function ys(e, t, n) {
  return n <= t ? t : Math.min(n, Math.max(t, e));
}
function fo(e, t, n) {
  if (n <= t)
    return t;
  const l = n - t + 1;
  let a = t + (e - t) % l;
  return a < t && (a = l + a), a === 0 ? 0 : a;
}
function xe(e, t = 2, n = "0") {
  if (e == null)
    return e;
  const l = "" + e;
  return l.length >= t ? l : new Array(t - l.length + 1).join(n) + l;
}
function el(e, t) {
  return [!0, !1].includes(e) ? e : t;
}
const ps = Ce({
  name: "QPagination",
  props: {
    ...rt,
    modelValue: {
      type: Number,
      required: !0
    },
    min: {
      type: [Number, String],
      default: 1
    },
    max: {
      type: [Number, String],
      required: !0
    },
    maxPages: {
      type: [Number, String],
      default: 0,
      validator: (e) => (typeof e == "string" ? parseInt(e, 10) : e) >= 0
    },
    inputStyle: [Array, String, Object],
    inputClass: [Array, String, Object],
    size: String,
    disable: Boolean,
    input: Boolean,
    iconPrev: String,
    iconNext: String,
    iconFirst: String,
    iconLast: String,
    toFn: Function,
    boundaryLinks: {
      type: Boolean,
      default: null
    },
    boundaryNumbers: {
      type: Boolean,
      default: null
    },
    directionLinks: {
      type: Boolean,
      default: null
    },
    ellipses: {
      type: Boolean,
      default: null
    },
    ripple: {
      type: [Boolean, Object],
      default: null
    },
    round: Boolean,
    rounded: Boolean,
    flat: Boolean,
    outline: Boolean,
    unelevated: Boolean,
    push: Boolean,
    glossy: Boolean,
    color: {
      type: String,
      default: "primary"
    },
    textColor: String,
    activeDesign: {
      type: String,
      default: "",
      values: (e) => e === "" || dr.includes(e)
    },
    activeColor: String,
    activeTextColor: String,
    gutter: String,
    padding: {
      type: String,
      default: "3px 2px"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const { proxy: n } = we(), { $q: l } = n, a = it(e, l), o = d(() => parseInt(e.min, 10)), r = d(() => parseInt(e.max, 10)), i = d(() => parseInt(e.maxPages, 10)), c = d(() => h.value + " / " + r.value), s = d(() => el(e.boundaryLinks, e.input)), u = d(() => el(e.boundaryNumbers, !e.input)), f = d(() => el(e.directionLinks, e.input)), S = d(() => el(e.ellipses, !e.input)), b = J(null), h = d({
      get: () => e.modelValue,
      set: ($) => {
        if ($ = parseInt($, 10), e.disable || isNaN($)) return;
        const M = ys($, o.value, r.value);
        e.modelValue !== M && t("update:modelValue", M);
      }
    });
    ce(() => `${o.value}|${r.value}`, () => {
      h.value = e.modelValue;
    });
    const x = d(
      () => "q-pagination row no-wrap items-center" + (e.disable === !0 ? " disabled" : "")
    ), g = d(() => e.gutter in sl ? `${sl[e.gutter]}px` : e.gutter || null), T = d(() => g.value !== null ? `--q-pagination-gutter-parent:-${g.value};--q-pagination-gutter-child:${g.value}` : null), P = d(() => {
      const $ = [
        e.iconFirst || l.iconSet.pagination.first,
        e.iconPrev || l.iconSet.pagination.prev,
        e.iconNext || l.iconSet.pagination.next,
        e.iconLast || l.iconSet.pagination.last
      ];
      return l.lang.rtl === !0 ? $.reverse() : $;
    }), _ = d(() => ({
      "aria-disabled": e.disable === !0 ? "true" : "false",
      role: "navigation"
    })), y = d(() => fr(e, "flat")), p = d(() => ({
      [y.value]: !0,
      round: e.round,
      rounded: e.rounded,
      padding: e.padding,
      color: e.color,
      textColor: e.textColor,
      size: e.size,
      ripple: e.ripple !== null ? e.ripple : !0
    })), F = d(() => {
      const $ = { [y.value]: !1 };
      return e.activeDesign !== "" && ($[e.activeDesign] = !0), $;
    }), A = d(() => ({
      ...F.value,
      color: e.activeColor || e.color,
      textColor: e.activeTextColor || e.textColor
    })), U = d(() => {
      let $ = Math.max(
        i.value,
        1 + (S.value ? 2 : 0) + (u.value ? 2 : 0)
      );
      const M = {
        pgFrom: o.value,
        pgTo: r.value,
        ellipsesStart: !1,
        ellipsesEnd: !1,
        boundaryStart: !1,
        boundaryEnd: !1,
        marginalStyle: {
          minWidth: `${Math.max(2, String(r.value).length)}em`
        }
      };
      return i.value && $ < r.value - o.value + 1 && ($ = 1 + Math.floor($ / 2) * 2, M.pgFrom = Math.max(o.value, Math.min(r.value - $ + 1, e.modelValue - Math.floor($ / 2))), M.pgTo = Math.min(r.value, M.pgFrom + $ - 1), u.value && (M.boundaryStart = !0, M.pgFrom++), S.value && M.pgFrom > o.value + (u.value ? 1 : 0) && (M.ellipsesStart = !0, M.pgFrom++), u.value && (M.boundaryEnd = !0, M.pgTo--), S.value && M.pgTo < r.value - (u.value ? 1 : 0) && (M.ellipsesEnd = !0, M.pgTo--)), M;
    });
    function D($) {
      h.value = $;
    }
    function L($) {
      h.value = h.value + $;
    }
    const H = d(() => {
      function $() {
        h.value = b.value, b.value = null;
      }
      return {
        "onUpdate:modelValue": (M) => {
          b.value = M;
        },
        onKeyup: (M) => {
          It(M, 13) === !0 && $();
        },
        onBlur: $
      };
    });
    function E($, M, K) {
      const Q = {
        "aria-label": M,
        "aria-current": "false",
        ...p.value,
        ...$
      };
      return K === !0 && Object.assign(Q, {
        "aria-current": "true",
        ...A.value
      }), M !== void 0 && (e.toFn !== void 0 ? Q.to = e.toFn(M) : Q.onClick = () => {
        D(M);
      }), v(Te, Q);
    }
    return Object.assign(n, { set: D, setByOffset: L }), () => {
      const $ = [], M = [];
      let K;
      if (s.value === !0 && ($.push(
        E({
          key: "bls",
          disable: e.disable || e.modelValue <= o.value,
          icon: P.value[0]
        }, o.value)
      ), M.unshift(
        E({
          key: "ble",
          disable: e.disable || e.modelValue >= r.value,
          icon: P.value[3]
        }, r.value)
      )), f.value === !0 && ($.push(
        E({
          key: "bdp",
          disable: e.disable || e.modelValue <= o.value,
          icon: P.value[1]
        }, e.modelValue - 1)
      ), M.unshift(
        E({
          key: "bdn",
          disable: e.disable || e.modelValue >= r.value,
          icon: P.value[2]
        }, e.modelValue + 1)
      )), e.input !== !0) {
        K = [];
        const { pgFrom: Q, pgTo: te, marginalStyle: N } = U.value;
        if (U.value.boundaryStart === !0) {
          const Z = o.value === e.modelValue;
          $.push(
            E({
              key: "bns",
              style: N,
              disable: e.disable,
              label: o.value
            }, o.value, Z)
          );
        }
        if (U.value.boundaryEnd === !0) {
          const Z = r.value === e.modelValue;
          M.unshift(
            E({
              key: "bne",
              style: N,
              disable: e.disable,
              label: r.value
            }, r.value, Z)
          );
        }
        U.value.ellipsesStart === !0 && $.push(
          E({
            key: "bes",
            style: N,
            disable: e.disable,
            label: "…",
            ripple: !1
          }, Q - 1)
        ), U.value.ellipsesEnd === !0 && M.unshift(
          E({
            key: "bee",
            style: N,
            disable: e.disable,
            label: "…",
            ripple: !1
          }, te + 1)
        );
        for (let Z = Q; Z <= te; Z++)
          K.push(
            E({
              key: `bpg${Z}`,
              style: N,
              disable: e.disable,
              label: Z
            }, Z, Z === e.modelValue)
          );
      }
      return v("div", {
        class: x.value,
        ..._.value
      }, [
        v("div", {
          class: "q-pagination__content row no-wrap items-center",
          style: T.value
        }, [
          ...$,
          e.input === !0 ? v(en, {
            class: "inline",
            style: { width: `${c.value.length / 1.5}em` },
            type: "number",
            dense: !0,
            value: b.value,
            disable: e.disable,
            dark: a.value,
            borderless: !0,
            inputClass: e.inputClass,
            inputStyle: e.inputStyle,
            placeholder: c.value,
            min: o.value,
            max: r.value,
            ...H.value
          }) : v("div", {
            class: "q-pagination__middle row justify-center"
          }, K),
          ...M
        ])
      ]);
    };
  }
}), Ss = Ce({
  name: "QTh",
  props: {
    props: Object,
    autoWidth: Boolean
  },
  emits: ["click"],
  setup(e, { slots: t, emit: n }) {
    const l = we(), { proxy: { $q: a } } = l, o = (r) => {
      n("click", r);
    };
    return () => {
      if (e.props === void 0)
        return v("th", {
          class: e.autoWidth === !0 ? "q-table--col-auto-width" : "",
          onClick: o
        }, We(t.default));
      let r, i;
      const c = l.vnode.key;
      if (c) {
        if (r = e.props.colsMap[c], r === void 0) return;
      } else
        r = e.props.col;
      if (r.sortable === !0) {
        const u = r.align === "right" ? "unshift" : "push";
        i = Zo(t.default, []), i[u](
          v(pt, {
            class: r.__iconClass,
            name: a.iconSet.table.arrowUp
          })
        );
      } else
        i = We(t.default);
      const s = {
        class: r.__thClass + (e.autoWidth === !0 ? " q-table--col-auto-width" : ""),
        style: r.headerStyle,
        onClick: (u) => {
          r.sortable === !0 && e.props.sort(r), o(u);
        }
      };
      return v("th", s, i);
    };
  }
}), ws = ["ul", "ol"], ks = Ce({
  name: "QList",
  props: {
    ...rt,
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean,
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(e, { slots: t }) {
    const n = we(), l = it(e, n.proxy.$q), a = d(
      () => ws.includes(e.tag) ? null : "list"
    ), o = d(
      () => "q-list" + (e.bordered === !0 ? " q-list--bordered" : "") + (e.dense === !0 ? " q-list--dense" : "") + (e.separator === !0 ? " q-list--separator" : "") + (l.value === !0 ? " q-list--dark" : "") + (e.padding === !0 ? " q-list--padding" : "")
    );
    return () => v(e.tag, { class: o.value, role: a.value }, We(t.default));
  }
}), xs = ["horizontal", "vertical", "cell", "none"], _s = Ce({
  name: "QMarkupTable",
  props: {
    ...rt,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    wrapCells: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: (e) => xs.includes(e)
    }
  },
  setup(e, { slots: t }) {
    const n = we(), l = it(e, n.proxy.$q), a = d(
      () => `q-markup-table q-table__container q-table__card q-table--${e.separator}-separator` + (l.value === !0 ? " q-table--dark q-table__card--dark q-dark" : "") + (e.dense === !0 ? " q-table--dense" : "") + (e.flat === !0 ? " q-table--flat" : "") + (e.bordered === !0 ? " q-table--bordered" : "") + (e.square === !0 ? " q-table--square" : "") + (e.wrapCells === !1 ? " q-table--no-wrap" : "")
    );
    return () => v("div", {
      class: a.value
    }, [
      v("table", { class: "q-table" }, We(t.default))
    ]);
  }
});
function Lr(e, t) {
  return v("div", e, [
    v("table", { class: "q-table" }, t)
  ]);
}
let fl = !1;
{
  const e = document.createElement("div");
  e.setAttribute("dir", "rtl"), Object.assign(e.style, {
    width: "1px",
    height: "1px",
    overflow: "auto"
  });
  const t = document.createElement("div");
  Object.assign(t.style, {
    width: "1000px",
    height: "1px"
  }), document.body.appendChild(e), e.appendChild(t), e.scrollLeft = -1e3, fl = e.scrollLeft >= 0, e.remove();
}
const Et = 1e3, Cs = [
  "start",
  "center",
  "end",
  "start-force",
  "center-force",
  "end-force"
], Fr = Array.prototype.filter, qs = window.getComputedStyle(document.body).overflowAnchor === void 0 ? rr : function(e, t) {
  e !== null && (e._qOverflowAnimationFrame !== void 0 && cancelAnimationFrame(e._qOverflowAnimationFrame), e._qOverflowAnimationFrame = requestAnimationFrame(() => {
    if (e === null) return;
    e._qOverflowAnimationFrame = void 0;
    const n = e.children || [];
    Fr.call(n, (a) => a.dataset && a.dataset.qVsAnchor !== void 0).forEach((a) => {
      delete a.dataset.qVsAnchor;
    });
    const l = n[t];
    l && l.dataset && (l.dataset.qVsAnchor = "");
  }));
};
function pn(e, t) {
  return e + t;
}
function Il(e, t, n, l, a, o, r, i) {
  const c = e === window ? document.scrollingElement || document.documentElement : e, s = a === !0 ? "offsetWidth" : "offsetHeight", u = {
    scrollStart: 0,
    scrollViewSize: -r - i,
    scrollMaxSize: 0,
    offsetStart: -r,
    offsetEnd: -i
  };
  if (a === !0 ? (e === window ? (u.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, u.scrollViewSize += document.documentElement.clientWidth) : (u.scrollStart = c.scrollLeft, u.scrollViewSize += c.clientWidth), u.scrollMaxSize = c.scrollWidth, o === !0 && (u.scrollStart = (fl === !0 ? u.scrollMaxSize - u.scrollViewSize : 0) - u.scrollStart)) : (e === window ? (u.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0, u.scrollViewSize += document.documentElement.clientHeight) : (u.scrollStart = c.scrollTop, u.scrollViewSize += c.clientHeight), u.scrollMaxSize = c.scrollHeight), n !== null)
    for (let f = n.previousElementSibling; f !== null; f = f.previousElementSibling)
      f.classList.contains("q-virtual-scroll--skip") === !1 && (u.offsetStart += f[s]);
  if (l !== null)
    for (let f = l.nextElementSibling; f !== null; f = f.nextElementSibling)
      f.classList.contains("q-virtual-scroll--skip") === !1 && (u.offsetEnd += f[s]);
  if (t !== e) {
    const f = c.getBoundingClientRect(), S = t.getBoundingClientRect();
    a === !0 ? (u.offsetStart += S.left - f.left, u.offsetEnd -= S.width) : (u.offsetStart += S.top - f.top, u.offsetEnd -= S.height), e !== window && (u.offsetStart += u.scrollStart), u.offsetEnd += u.scrollMaxSize - u.offsetStart;
  }
  return u;
}
function mo(e, t, n, l) {
  t === "end" && (t = (e === window ? document.body : e)[n === !0 ? "scrollWidth" : "scrollHeight"]), e === window ? n === !0 ? (l === !0 && (t = (fl === !0 ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - t), window.scrollTo(t, window.pageYOffset || window.scrollY || document.body.scrollTop || 0)) : window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, t) : n === !0 ? (l === !0 && (t = (fl === !0 ? e.scrollWidth - e.offsetWidth : 0) - t), e.scrollLeft = t) : e.scrollTop = t;
}
function Pn(e, t, n, l) {
  if (n >= l)
    return 0;
  const a = t.length, o = Math.floor(n / Et), r = Math.floor((l - 1) / Et) + 1;
  let i = e.slice(o, r).reduce(pn, 0);
  return n % Et !== 0 && (i -= t.slice(o * Et, n).reduce(pn, 0)), l % Et !== 0 && l !== a && (i -= t.slice(l, r * Et).reduce(pn, 0)), i;
}
const $r = {
  virtualScrollSliceSize: {
    type: [Number, String],
    default: 10
  },
  virtualScrollSliceRatioBefore: {
    type: [Number, String],
    default: 1
  },
  virtualScrollSliceRatioAfter: {
    type: [Number, String],
    default: 1
  },
  virtualScrollItemSize: {
    type: [Number, String],
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: [Number, String],
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: [Number, String],
    default: 0
  },
  tableColspan: [Number, String]
}, Hr = Object.keys($r), ua = {
  virtualScrollHorizontal: Boolean,
  onVirtualScroll: Function,
  ...$r
};
function Ir({
  virtualScrollLength: e,
  getVirtualScrollTarget: t,
  getVirtualScrollEl: n,
  virtualScrollItemSizeComputed: l
  // optional
}) {
  const a = we(), { props: o, emit: r, proxy: i } = a, { $q: c } = i;
  let s, u, f, S = [], b;
  const h = J(0), x = J(0), g = J({}), T = J(null), P = J(null), _ = J(null), y = J({ from: 0, to: 0 }), p = d(() => o.tableColspan !== void 0 ? o.tableColspan : 100);
  l === void 0 && (l = d(() => o.virtualScrollItemSize));
  const F = d(() => l.value + ";" + o.virtualScrollHorizontal), A = d(
    () => F.value + ";" + o.virtualScrollSliceRatioBefore + ";" + o.virtualScrollSliceRatioAfter
  );
  ce(A, () => {
    Q();
  }), ce(F, U);
  function U() {
    K(u, !0);
  }
  function D(q) {
    K(q === void 0 ? u : q);
  }
  function L(q, C) {
    const G = t();
    if (G == null || G.nodeType === 8) return;
    const ie = Il(
      G,
      n(),
      T.value,
      P.value,
      o.virtualScrollHorizontal,
      c.lang.rtl,
      o.virtualScrollStickySizeStart,
      o.virtualScrollStickySizeEnd
    );
    f !== ie.scrollViewSize && Q(ie.scrollViewSize), E(
      G,
      ie,
      Math.min(e.value - 1, Math.max(0, parseInt(q, 10) || 0)),
      0,
      Cs.indexOf(C) !== -1 ? C : u !== -1 && q > u ? "end" : "start"
    );
  }
  function H() {
    const q = t();
    if (q == null || q.nodeType === 8) return;
    const C = Il(
      q,
      n(),
      T.value,
      P.value,
      o.virtualScrollHorizontal,
      c.lang.rtl,
      o.virtualScrollStickySizeStart,
      o.virtualScrollStickySizeEnd
    ), G = e.value - 1, ie = C.scrollMaxSize - C.offsetStart - C.offsetEnd - x.value;
    if (s === C.scrollStart) return;
    if (C.scrollMaxSize <= 0) {
      E(q, C, 0, 0);
      return;
    }
    f !== C.scrollViewSize && Q(C.scrollViewSize), $(y.value.from);
    const me = Math.floor(C.scrollMaxSize - Math.max(C.scrollViewSize, C.offsetEnd) - Math.min(b[G], C.scrollViewSize / 2));
    if (me > 0 && Math.ceil(C.scrollStart) >= me) {
      E(
        q,
        C,
        G,
        C.scrollMaxSize - C.offsetEnd - S.reduce(pn, 0)
      );
      return;
    }
    let j = 0, X = C.scrollStart - C.offsetStart, ge = X;
    if (X <= ie && X + C.scrollViewSize >= h.value)
      X -= h.value, j = y.value.from, ge = X;
    else
      for (let z = 0; X >= S[z] && j < G; z++)
        X -= S[z], j += Et;
    for (; X > 0 && j < G; )
      X -= b[j], X > -C.scrollViewSize ? (j++, ge = X) : ge = b[j] + X;
    E(
      q,
      C,
      j,
      ge
    );
  }
  function E(q, C, G, ie, me) {
    const j = typeof me == "string" && me.indexOf("-force") !== -1, X = j === !0 ? me.replace("-force", "") : me, ge = X !== void 0 ? X : "start";
    let z = Math.max(0, G - g.value[ge]), qe = z + g.value.total;
    qe > e.value && (qe = e.value, z = Math.max(0, qe - g.value.total)), s = C.scrollStart;
    const pe = z !== y.value.from || qe !== y.value.to;
    if (pe === !1 && X === void 0) {
      N(G);
      return;
    }
    const { activeElement: Re } = document, je = _.value;
    pe === !0 && je !== null && je !== Re && je.contains(Re) === !0 && (je.addEventListener("focusout", M), setTimeout(() => {
      je !== null && je.removeEventListener("focusout", M);
    })), qs(je, G - z);
    const ut = X !== void 0 ? b.slice(z, G).reduce(pn, 0) : 0;
    if (pe === !0) {
      const nt = qe >= y.value.from && z <= y.value.to ? y.value.to : qe;
      y.value = { from: z, to: nt }, h.value = Pn(S, b, 0, z), x.value = Pn(S, b, qe, e.value), requestAnimationFrame(() => {
        y.value.to !== qe && s === C.scrollStart && (y.value = { from: y.value.from, to: qe }, x.value = Pn(S, b, qe, e.value));
      });
    }
    requestAnimationFrame(() => {
      if (s !== C.scrollStart) return;
      pe === !0 && $(z);
      const nt = b.slice(z, G).reduce(pn, 0), Qe = nt + C.offsetStart + h.value, $e = Qe + b[G];
      let Ct = Qe + ie;
      if (X !== void 0) {
        const Dt = nt - ut, dt = C.scrollStart + Dt;
        Ct = j !== !0 && dt < Qe && $e < dt + C.scrollViewSize ? dt : X === "end" ? $e - C.scrollViewSize : Qe - (X === "start" ? 0 : Math.round((C.scrollViewSize - b[G]) / 2));
      }
      s = Ct, mo(
        q,
        Ct,
        o.virtualScrollHorizontal,
        c.lang.rtl
      ), N(G);
    });
  }
  function $(q) {
    const C = _.value;
    if (C) {
      const G = Fr.call(
        C.children,
        (z) => z.classList && z.classList.contains("q-virtual-scroll--skip") === !1
      ), ie = G.length, me = o.virtualScrollHorizontal === !0 ? (z) => z.getBoundingClientRect().width : (z) => z.offsetHeight;
      let j = q, X, ge;
      for (let z = 0; z < ie; ) {
        for (X = me(G[z]), z++; z < ie && G[z].classList.contains("q-virtual-scroll--with-prev") === !0; )
          X += me(G[z]), z++;
        ge = X - b[j], ge !== 0 && (b[j] += ge, S[Math.floor(j / Et)] += ge), j++;
      }
    }
  }
  function M() {
    _.value !== null && _.value !== void 0 && _.value.focus();
  }
  function K(q, C) {
    const G = 1 * l.value;
    (C === !0 || Array.isArray(b) === !1) && (b = []);
    const ie = b.length;
    b.length = e.value;
    for (let j = e.value - 1; j >= ie; j--)
      b[j] = G;
    const me = Math.floor((e.value - 1) / Et);
    S = [];
    for (let j = 0; j <= me; j++) {
      let X = 0;
      const ge = Math.min((j + 1) * Et, e.value);
      for (let z = j * Et; z < ge; z++)
        X += b[z];
      S.push(X);
    }
    u = -1, s = void 0, h.value = Pn(S, b, 0, y.value.from), x.value = Pn(S, b, y.value.to, e.value), q >= 0 ? ($(y.value.from), De(() => {
      L(q);
    })) : Z();
  }
  function Q(q) {
    if (q === void 0 && typeof window < "u") {
      const X = t();
      X != null && X.nodeType !== 8 && (q = Il(
        X,
        n(),
        T.value,
        P.value,
        o.virtualScrollHorizontal,
        c.lang.rtl,
        o.virtualScrollStickySizeStart,
        o.virtualScrollStickySizeEnd
      ).scrollViewSize);
    }
    f = q;
    const C = parseFloat(o.virtualScrollSliceRatioBefore) || 0, G = parseFloat(o.virtualScrollSliceRatioAfter) || 0, ie = 1 + C + G, me = q === void 0 || q <= 0 ? 1 : Math.ceil(q / l.value), j = Math.max(
      1,
      me,
      Math.ceil((o.virtualScrollSliceSize > 0 ? o.virtualScrollSliceSize : 10) / ie)
    );
    g.value = {
      total: Math.ceil(j * ie),
      start: Math.ceil(j * C),
      center: Math.ceil(j * (0.5 + C)),
      end: Math.ceil(j * (1 + C)),
      view: me
    };
  }
  function te(q, C) {
    const G = o.virtualScrollHorizontal === !0 ? "width" : "height", ie = {
      ["--q-virtual-scroll-item-" + G]: l.value + "px"
    };
    return [
      q === "tbody" ? v(q, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: T
      }, [
        v("tr", [
          v("td", {
            style: { [G]: `${h.value}px`, ...ie },
            colspan: p.value
          })
        ])
      ]) : v(q, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: T,
        style: { [G]: `${h.value}px`, ...ie }
      }),
      v(q, {
        class: "q-virtual-scroll__content",
        key: "content",
        ref: _,
        tabindex: -1
      }, C.flat()),
      q === "tbody" ? v(q, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: P
      }, [
        v("tr", [
          v("td", {
            style: { [G]: `${x.value}px`, ...ie },
            colspan: p.value
          })
        ])
      ]) : v(q, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: P,
        style: { [G]: `${x.value}px`, ...ie }
      })
    ];
  }
  function N(q) {
    u !== q && (o.onVirtualScroll !== void 0 && r("virtualScroll", {
      index: q,
      from: y.value.from,
      to: y.value.to - 1,
      direction: q < u ? "decrease" : "increase",
      ref: i
    }), u = q);
  }
  Q();
  const Z = Or(
    H,
    c.platform.is.ios === !0 ? 120 : 35
  );
  zn(() => {
    Q();
  });
  let de = !1;
  return xn(() => {
    de = !0;
  }), Sl(() => {
    if (de !== !0) return;
    const q = t();
    s !== void 0 && q !== void 0 && q !== null && q.nodeType !== 8 ? mo(
      q,
      s,
      o.virtualScrollHorizontal,
      c.lang.rtl
    ) : L(u);
  }), ot(() => {
    Z.cancel();
  }), Object.assign(i, { scrollTo: L, reset: U, refresh: D }), {
    virtualScrollSliceRange: y,
    virtualScrollSliceSizeComputed: g,
    setVirtualScrollSize: Q,
    onVirtualScrollEvt: Z,
    localResetVirtualScroll: K,
    padVirtualScroll: te,
    scrollTo: L,
    reset: U,
    refresh: D
  };
}
const Es = {
  list: ks,
  table: _s
}, Ms = ["list", "table", "__qtable"], Rs = Ce({
  name: "QVirtualScroll",
  props: {
    ...ua,
    type: {
      type: String,
      default: "list",
      validator: (e) => Ms.includes(e)
    },
    items: {
      type: Array,
      default: () => []
    },
    itemsFn: Function,
    itemsSize: Number,
    scrollTarget: _r
  },
  setup(e, { slots: t, attrs: n }) {
    let l;
    const a = J(null), o = d(() => e.itemsSize >= 0 && e.itemsFn !== void 0 ? parseInt(e.itemsSize, 10) : Array.isArray(e.items) ? e.items.length : 0), {
      virtualScrollSliceRange: r,
      localResetVirtualScroll: i,
      padVirtualScroll: c,
      onVirtualScrollEvt: s
    } = Ir({
      virtualScrollLength: o,
      getVirtualScrollTarget: h,
      getVirtualScrollEl: b
    }), u = d(() => {
      if (o.value === 0)
        return [];
      const P = (_, y) => ({
        index: r.value.from + y,
        item: _
      });
      return e.itemsFn === void 0 ? e.items.slice(r.value.from, r.value.to).map(P) : e.itemsFn(r.value.from, r.value.to - r.value.from).map(P);
    }), f = d(
      () => "q-virtual-scroll q-virtual-scroll" + (e.virtualScrollHorizontal === !0 ? "--horizontal" : "--vertical") + (e.scrollTarget !== void 0 ? "" : " scroll")
    ), S = d(() => e.scrollTarget !== void 0 ? {} : { tabindex: 0 });
    ce(o, () => {
      i();
    }), ce(() => e.scrollTarget, () => {
      g(), x();
    });
    function b() {
      return a.value.$el || a.value;
    }
    function h() {
      return l;
    }
    function x() {
      l = Cr(b(), e.scrollTarget), l.addEventListener("scroll", s, Ze.passive);
    }
    function g() {
      l !== void 0 && (l.removeEventListener("scroll", s, Ze.passive), l = void 0);
    }
    function T() {
      let P = c(
        e.type === "list" ? "div" : "tbody",
        u.value.map(t.default)
      );
      return t.before !== void 0 && (P = t.before().concat(P)), Vt(t.after, P);
    }
    return zn(() => {
      i();
    }), jt(() => {
      x();
    }), Sl(() => {
      x();
    }), xn(() => {
      g();
    }), ot(() => {
      g();
    }), () => {
      if (t.default === void 0) {
        console.error("QVirtualScroll: default scoped slot is required for rendering");
        return;
      }
      return e.type === "__qtable" ? Lr(
        { ref: a, class: "q-table__middle " + f.value },
        T()
      ) : v(Es[e.type], {
        ...n,
        ref: a,
        class: [n.class, f.value],
        ...S.value
      }, T);
    };
  }
}), Ts = Ce({
  name: "QField",
  inheritAttrs: !1,
  props: {
    ...xl,
    tag: {
      type: String,
      default: "label"
    }
  },
  emits: xa,
  setup() {
    return Ca(
      _a({ tagProp: !0 })
    );
  }
}), Ps = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
}, Os = Ce({
  name: "QChip",
  props: {
    ...rt,
    ..._n,
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    iconSelected: String,
    label: [String, Number],
    color: String,
    textColor: String,
    modelValue: {
      type: Boolean,
      default: !0
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    removeAriaLabel: String,
    tabindex: [String, Number],
    disable: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: !0
    }
  },
  emits: ["update:modelValue", "update:selected", "remove", "click"],
  setup(e, { slots: t, emit: n }) {
    const { proxy: { $q: l } } = we(), a = it(e, l), o = Cn(e, Ps), r = d(() => e.selected === !0 || e.icon !== void 0), i = d(() => e.selected === !0 ? e.iconSelected || l.iconSet.chip.selected : e.icon), c = d(() => e.iconRemove || l.iconSet.chip.remove), s = d(
      () => e.disable === !1 && (e.clickable === !0 || e.selected !== null)
    ), u = d(() => {
      const g = e.outline === !0 && e.color || e.textColor;
      return "q-chip row inline no-wrap items-center" + (e.outline === !1 && e.color !== void 0 ? ` bg-${e.color}` : "") + (g ? ` text-${g} q-chip--colored` : "") + (e.disable === !0 ? " disabled" : "") + (e.dense === !0 ? " q-chip--dense" : "") + (e.outline === !0 ? " q-chip--outline" : "") + (e.selected === !0 ? " q-chip--selected" : "") + (s.value === !0 ? " q-chip--clickable cursor-pointer non-selectable q-hoverable" : "") + (e.square === !0 ? " q-chip--square" : "") + (a.value === !0 ? " q-chip--dark q-dark" : "");
    }), f = d(() => {
      const g = e.disable === !0 ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: e.tabindex || 0 }, T = {
        ...g,
        role: "button",
        "aria-hidden": "false",
        "aria-label": e.removeAriaLabel || l.lang.label.remove
      };
      return { chip: g, remove: T };
    });
    function S(g) {
      g.keyCode === 13 && b(g);
    }
    function b(g) {
      e.disable || (n("update:selected", !e.selected), n("click", g));
    }
    function h(g) {
      (g.keyCode === void 0 || g.keyCode === 13) && (Fe(g), e.disable === !1 && (n("update:modelValue", !1), n("remove")));
    }
    function x() {
      const g = [];
      s.value === !0 && g.push(
        v("div", { class: "q-focus-helper" })
      ), r.value === !0 && g.push(
        v(pt, {
          class: "q-chip__icon q-chip__icon--left",
          name: i.value
        })
      );
      const T = e.label !== void 0 ? [v("div", { class: "ellipsis" }, [e.label])] : void 0;
      return g.push(
        v("div", {
          class: "q-chip__content col row no-wrap items-center q-anchor--skip"
        }, Ni(t.default, T))
      ), e.iconRight && g.push(
        v(pt, {
          class: "q-chip__icon q-chip__icon--right",
          name: e.iconRight
        })
      ), e.removable === !0 && g.push(
        v(pt, {
          class: "q-chip__icon q-chip__icon--remove cursor-pointer",
          name: c.value,
          ...f.value.remove,
          onClick: h,
          onKeyup: h
        })
      ), g;
    }
    return () => {
      if (e.modelValue === !1) return;
      const g = {
        class: u.value,
        style: o.value
      };
      return s.value === !0 && Object.assign(
        g,
        f.value.chip,
        { onClick: b, onKeyup: S }
      ), zi(
        "div",
        g,
        x(),
        "ripple",
        e.ripple !== !1 && e.disable !== !0,
        () => [[ir, e.ripple]]
      );
    };
  }
}), Bs = Ce({
  name: "QItem",
  props: {
    ...rt,
    ...uu,
    tag: {
      type: String,
      default: "div"
    },
    active: {
      type: Boolean,
      default: null
    },
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  emits: ["click", "keyup"],
  setup(e, { slots: t, emit: n }) {
    const { proxy: { $q: l } } = we(), a = it(e, l), { hasLink: o, linkAttrs: r, linkClass: i, linkTag: c, navigateOnClick: s } = cr(), u = J(null), f = J(null), S = d(
      () => e.clickable === !0 || o.value === !0 || e.tag === "label"
    ), b = d(
      () => e.disable !== !0 && S.value === !0
    ), h = d(
      () => "q-item q-item-type row no-wrap" + (e.dense === !0 ? " q-item--dense" : "") + (a.value === !0 ? " q-item--dark" : "") + (o.value === !0 && e.active === null ? i.value : e.active === !0 ? ` q-item--active${e.activeClass !== void 0 ? ` ${e.activeClass}` : ""}` : "") + (e.disable === !0 ? " disabled" : "") + (b.value === !0 ? " q-item--clickable q-link cursor-pointer " + (e.manualFocus === !0 ? "q-manual-focusable" : "q-focusable q-hoverable") + (e.focused === !0 ? " q-manual-focusable--focused" : "") : "")
    ), x = d(() => e.insetLevel === void 0 ? null : {
      ["padding" + (l.lang.rtl === !0 ? "Right" : "Left")]: 16 + e.insetLevel * 56 + "px"
    });
    function g(_) {
      b.value === !0 && (f.value !== null && (_.qKeyEvent !== !0 && document.activeElement === u.value ? f.value.focus() : document.activeElement === f.value && u.value.focus()), s(_));
    }
    function T(_) {
      if (b.value === !0 && It(_, [13, 32]) === !0) {
        Fe(_), _.qKeyEvent = !0;
        const y = new MouseEvent("click", _);
        y.qKeyEvent = !0, u.value.dispatchEvent(y);
      }
      n("keyup", _);
    }
    function P() {
      const _ = Zo(t.default, []);
      return b.value === !0 && _.unshift(
        v("div", { class: "q-focus-helper", tabindex: -1, ref: f })
      ), _;
    }
    return () => {
      const _ = {
        ref: u,
        class: h.value,
        style: x.value,
        role: "listitem",
        onClick: g,
        onKeyup: T
      };
      return b.value === !0 ? (_.tabindex = e.tabindex || "0", Object.assign(_, r.value)) : S.value === !0 && (_["aria-disabled"] = "true"), v(
        c.value,
        _,
        P()
      );
    };
  }
}), Vs = Ce({
  name: "QItemSection",
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  setup(e, { slots: t }) {
    const n = d(
      () => `q-item__section column q-item__section--${e.avatar === !0 || e.side === !0 || e.thumbnail === !0 ? "side" : "main"}` + (e.top === !0 ? " q-item__section--top justify-start" : " justify-center") + (e.avatar === !0 ? " q-item__section--avatar" : "") + (e.thumbnail === !0 ? " q-item__section--thumbnail" : "") + (e.noWrap === !0 ? " q-item__section--nowrap" : "")
    );
    return () => v("div", { class: n.value }, We(t.default));
  }
}), As = Ce({
  name: "QItemLabel",
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  setup(e, { slots: t }) {
    const n = d(() => parseInt(e.lines, 10)), l = d(
      () => "q-item__label" + (e.overline === !0 ? " q-item__label--overline text-overline" : "") + (e.caption === !0 ? " q-item__label--caption text-caption" : "") + (e.header === !0 ? " q-item__label--header" : "") + (n.value === 1 ? " ellipsis" : "")
    ), a = d(() => e.lines !== void 0 && n.value > 1 ? {
      overflow: "hidden",
      display: "-webkit-box",
      "-webkit-box-orient": "vertical",
      "-webkit-line-clamp": n.value
    } : null);
    return () => v("div", {
      style: a.value,
      class: l.value
    }, We(t.default));
  }
});
function jr() {
  if (window.getSelection !== void 0) {
    const e = window.getSelection();
    e.empty !== void 0 ? e.empty() : e.removeAllRanges !== void 0 && (e.removeAllRanges(), oa.is.mobile !== !0 && e.addRange(document.createRange()));
  } else document.selection !== void 0 && document.selection.empty();
}
const Ds = {
  /* SSR does not know about Element */
  target: {
    type: [Boolean, String, Element],
    default: !0
  },
  noParentEvent: Boolean
}, Nr = {
  ...Ds,
  contextMenu: Boolean
};
function zr({
  showing: e,
  avoidEmit: t,
  // required for QPopupProxy (true)
  configureAnchorEl: n
  // optional
}) {
  const { props: l, proxy: a, emit: o } = we(), r = J(null);
  let i = null;
  function c(b) {
    return r.value === null ? !1 : b === void 0 || b.touches === void 0 || b.touches.length <= 1;
  }
  const s = {};
  n === void 0 && (Object.assign(s, {
    hide(b) {
      a.hide(b);
    },
    toggle(b) {
      a.toggle(b), b.qAnchorHandled = !0;
    },
    toggleKey(b) {
      It(b, 13) === !0 && s.toggle(b);
    },
    contextClick(b) {
      a.hide(b), ct(b), De(() => {
        a.show(b), b.qAnchorHandled = !0;
      });
    },
    prevent: ct,
    mobileTouch(b) {
      if (s.mobileCleanup(b), c(b) !== !0) return;
      a.hide(b), r.value.classList.add("non-selectable");
      const h = b.target;
      tn(s, "anchor", [
        [h, "touchmove", "mobileCleanup", "passive"],
        [h, "touchend", "mobileCleanup", "passive"],
        [h, "touchcancel", "mobileCleanup", "passive"],
        [r.value, "contextmenu", "prevent", "notPassive"]
      ]), i = setTimeout(() => {
        i = null, a.show(b), b.qAnchorHandled = !0;
      }, 300);
    },
    mobileCleanup(b) {
      r.value.classList.remove("non-selectable"), i !== null && (clearTimeout(i), i = null), e.value === !0 && b !== void 0 && jr();
    }
  }), n = function(b = l.contextMenu) {
    if (l.noParentEvent === !0 || r.value === null) return;
    let h;
    b === !0 ? a.$q.platform.is.mobile === !0 ? h = [
      [r.value, "touchstart", "mobileTouch", "passive"]
    ] : h = [
      [r.value, "mousedown", "hide", "passive"],
      [r.value, "contextmenu", "contextClick", "notPassive"]
    ] : h = [
      [r.value, "click", "toggle", "passive"],
      [r.value, "keyup", "toggleKey", "passive"]
    ], tn(s, "anchor", h);
  });
  function u() {
    Ln(s, "anchor");
  }
  function f(b) {
    for (r.value = b; r.value.classList.contains("q-anchor--skip"); )
      r.value = r.value.parentNode;
    n();
  }
  function S() {
    if (l.target === !1 || l.target === "" || a.$el.parentNode === null)
      r.value = null;
    else if (l.target === !0)
      f(a.$el.parentNode);
    else {
      let b = l.target;
      if (typeof l.target == "string")
        try {
          b = document.querySelector(l.target);
        } catch {
          b = void 0;
        }
      b != null ? (r.value = b.$el || b, n()) : (r.value = null, console.error(`Anchor: target "${l.target}" not found`));
    }
  }
  return ce(() => l.contextMenu, (b) => {
    r.value !== null && (u(), n(b));
  }), ce(() => l.target, () => {
    r.value !== null && u(), S();
  }), ce(() => l.noParentEvent, (b) => {
    r.value !== null && (b === !0 ? u() : n());
  }), jt(() => {
    S(), t !== !0 && l.modelValue === !0 && r.value === null && o("update:modelValue", !1);
  }), ot(() => {
    i !== null && clearTimeout(i), u();
  }), {
    anchorEl: r,
    canShow: c,
    anchorEvents: s
  };
}
function Ls(e, t) {
  const n = J(null);
  let l;
  function a(i, c) {
    const s = `${c !== void 0 ? "add" : "remove"}EventListener`, u = c !== void 0 ? c : l;
    i !== window && i[s]("scroll", u, Ze.passive), window[s]("scroll", u, Ze.passive), l = c;
  }
  function o() {
    n.value !== null && (a(n.value), n.value = null);
  }
  const r = ce(() => e.noParentEvent, () => {
    n.value !== null && (o(), t());
  });
  return ot(r), {
    localScrollTarget: n,
    unconfigureScrollTarget: o,
    changeScrollEvent: a
  };
}
const { notPassiveCapture: ml } = Ze, un = [];
function vl(e) {
  const t = e.target;
  if (t === void 0 || t.nodeType === 8 || t.classList.contains("no-pointer-events") === !0) return;
  let n = yn.length - 1;
  for (; n >= 0; ) {
    const l = yn[n].$;
    if (l.type.name === "QTooltip") {
      n--;
      continue;
    }
    if (l.type.name !== "QDialog")
      break;
    if (l.props.seamless !== !0) return;
    n--;
  }
  for (let l = un.length - 1; l >= 0; l--) {
    const a = un[l];
    if ((a.anchorEl.value === null || a.anchorEl.value.contains(t) === !1) && (t === document.body || a.innerRef.value !== null && a.innerRef.value.contains(t) === !1))
      e.qClickOutside = !0, a.onClickOutside(e);
    else
      return;
  }
}
function Fs(e) {
  un.push(e), un.length === 1 && (document.addEventListener("mousedown", vl, ml), document.addEventListener("touchstart", vl, ml));
}
function vo(e) {
  const t = un.findIndex((n) => n === e);
  t !== -1 && (un.splice(t, 1), un.length === 0 && (document.removeEventListener("mousedown", vl, ml), document.removeEventListener("touchstart", vl, ml)));
}
let ho, go;
function bo(e) {
  const t = e.split(" ");
  return t.length !== 2 ? !1 : ["top", "center", "bottom"].includes(t[0]) !== !0 ? (console.error("Anchor/Self position must start with one of top/center/bottom"), !1) : ["left", "middle", "right", "start", "end"].includes(t[1]) !== !0 ? (console.error("Anchor/Self position must end with one of left/middle/right/start/end"), !1) : !0;
}
function $s(e) {
  return e ? !(e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number") : !0;
}
const sa = {
  "start#ltr": "left",
  "start#rtl": "right",
  "end#ltr": "right",
  "end#rtl": "left"
};
["left", "middle", "right"].forEach((e) => {
  sa[`${e}#ltr`] = e, sa[`${e}#rtl`] = e;
});
function yo(e, t) {
  const n = e.split(" ");
  return {
    vertical: n[0],
    horizontal: sa[`${n[1]}#${t === !0 ? "rtl" : "ltr"}`]
  };
}
function Hs(e, t) {
  let { top: n, left: l, right: a, bottom: o, width: r, height: i } = e.getBoundingClientRect();
  return t !== void 0 && (n -= t[1], l -= t[0], o += t[1], a += t[0], r += t[0], i += t[1]), {
    top: n,
    bottom: o,
    height: i,
    left: l,
    right: a,
    width: r,
    middle: l + (a - l) / 2,
    center: n + (o - n) / 2
  };
}
function Is(e, t, n) {
  let { top: l, left: a } = e.getBoundingClientRect();
  return l += t.top, a += t.left, n !== void 0 && (l += n[1], a += n[0]), {
    top: l,
    bottom: l + 1,
    height: 1,
    left: a,
    right: a + 1,
    width: 1,
    middle: a,
    center: l
  };
}
function js(e, t) {
  return {
    top: 0,
    center: t / 2,
    bottom: t,
    left: 0,
    middle: e / 2,
    right: e
  };
}
function po(e, t, n, l) {
  return {
    top: e[n.vertical] - t[l.vertical],
    left: e[n.horizontal] - t[l.horizontal]
  };
}
function Ur(e, t = 0) {
  if (e.targetEl === null || e.anchorEl === null || t > 5) return;
  if (e.targetEl.offsetHeight === 0 || e.targetEl.offsetWidth === 0) {
    setTimeout(() => {
      Ur(e, t + 1);
    }, 10);
    return;
  }
  const {
    targetEl: n,
    offset: l,
    anchorEl: a,
    anchorOrigin: o,
    selfOrigin: r,
    absoluteOffset: i,
    fit: c,
    cover: s,
    maxHeight: u,
    maxWidth: f
  } = e;
  if (Ge.is.ios === !0 && window.visualViewport !== void 0) {
    const F = document.body.style, { offsetLeft: A, offsetTop: U } = window.visualViewport;
    A !== ho && (F.setProperty("--q-pe-left", A + "px"), ho = A), U !== go && (F.setProperty("--q-pe-top", U + "px"), go = U);
  }
  const { scrollLeft: S, scrollTop: b } = n, h = i === void 0 ? Hs(a, s === !0 ? [0, 0] : l) : Is(a, i, l);
  Object.assign(n.style, {
    top: 0,
    left: 0,
    minWidth: null,
    minHeight: null,
    maxWidth: f,
    maxHeight: u,
    visibility: "visible"
  });
  const { offsetWidth: x, offsetHeight: g } = n, { elWidth: T, elHeight: P } = c === !0 || s === !0 ? { elWidth: Math.max(h.width, x), elHeight: s === !0 ? Math.max(h.height, g) : g } : { elWidth: x, elHeight: g };
  let _ = { maxWidth: f, maxHeight: u };
  (c === !0 || s === !0) && (_.minWidth = h.width + "px", s === !0 && (_.minHeight = h.height + "px")), Object.assign(n.style, _);
  const y = js(T, P);
  let p = po(h, y, o, r);
  if (i === void 0 || l === void 0)
    jl(p, h, y, o, r);
  else {
    const { top: F, left: A } = p;
    jl(p, h, y, o, r);
    let U = !1;
    if (p.top !== F) {
      U = !0;
      const D = 2 * l[1];
      h.center = h.top -= D, h.bottom -= D + 2;
    }
    if (p.left !== A) {
      U = !0;
      const D = 2 * l[0];
      h.middle = h.left -= D, h.right -= D + 2;
    }
    U === !0 && (p = po(h, y, o, r), jl(p, h, y, o, r));
  }
  _ = {
    top: p.top + "px",
    left: p.left + "px"
  }, p.maxHeight !== void 0 && (_.maxHeight = p.maxHeight + "px", h.height > p.maxHeight && (_.minHeight = _.maxHeight)), p.maxWidth !== void 0 && (_.maxWidth = p.maxWidth + "px", h.width > p.maxWidth && (_.minWidth = _.maxWidth)), Object.assign(n.style, _), n.scrollTop !== b && (n.scrollTop = b), n.scrollLeft !== S && (n.scrollLeft = S);
}
function jl(e, t, n, l, a) {
  const o = n.bottom, r = n.right, i = Vu(), c = window.innerHeight - i, s = document.body.clientWidth;
  if (e.top < 0 || e.top + o > c)
    if (a.vertical === "center")
      e.top = t[l.vertical] > c / 2 ? Math.max(0, c - o) : 0, e.maxHeight = Math.min(o, c);
    else if (t[l.vertical] > c / 2) {
      const u = Math.min(
        c,
        l.vertical === "center" ? t.center : l.vertical === a.vertical ? t.bottom : t.top
      );
      e.maxHeight = Math.min(o, u), e.top = Math.max(0, u - o);
    } else
      e.top = Math.max(
        0,
        l.vertical === "center" ? t.center : l.vertical === a.vertical ? t.top : t.bottom
      ), e.maxHeight = Math.min(o, c - e.top);
  if (e.left < 0 || e.left + r > s)
    if (e.maxWidth = Math.min(r, s), a.horizontal === "middle")
      e.left = t[l.horizontal] > s / 2 ? Math.max(0, s - r) : 0;
    else if (t[l.horizontal] > s / 2) {
      const u = Math.min(
        s,
        l.horizontal === "middle" ? t.middle : l.horizontal === a.horizontal ? t.right : t.left
      );
      e.maxWidth = Math.min(r, u), e.left = Math.max(0, u - e.maxWidth);
    } else
      e.left = Math.max(
        0,
        l.horizontal === "middle" ? t.middle : l.horizontal === a.horizontal ? t.left : t.right
      ), e.maxWidth = Math.min(r, s - e.left);
}
const Yr = Ce({
  name: "QMenu",
  inheritAttrs: !1,
  props: {
    ...Nr,
    ...gr,
    ...rt,
    ...pr,
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: bo
    },
    self: {
      type: String,
      validator: bo
    },
    offset: {
      type: Array,
      validator: $s
    },
    scrollTarget: _r,
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  emits: [
    ...br,
    "click",
    "escapeKey"
  ],
  setup(e, { slots: t, emit: n, attrs: l }) {
    let a = null, o, r, i;
    const c = we(), { proxy: s } = c, { $q: u } = s, f = J(null), S = J(!1), b = d(
      () => e.persistent !== !0 && e.noRouteDismiss !== !0
    ), h = it(e, u), { registerTick: x, removeTick: g } = hr(), { registerTimeout: T } = vr(), { transitionProps: P, transitionStyle: _ } = Sr(e), { localScrollTarget: y, changeScrollEvent: p, unconfigureScrollTarget: F } = Ls(e, G), { anchorEl: A, canShow: U } = zr({ showing: S }), { hide: D } = yr({
      showing: S,
      canShow: U,
      handleShow: de,
      handleHide: q,
      hideOnRouteChange: b,
      processOnMount: !0
    }), { showPortal: L, hidePortal: H, renderPortal: E } = xr(c, f, ge, "menu"), $ = {
      anchorEl: A,
      innerRef: f,
      onClickOutside(z) {
        if (e.persistent !== !0 && S.value === !0)
          return D(z), // always prevent touch event
          (z.type === "touchstart" || z.target.classList.contains("q-dialog__backdrop")) && Fe(z), !0;
      }
    }, M = d(
      () => yo(
        e.anchor || (e.cover === !0 ? "center middle" : "bottom start"),
        u.lang.rtl
      )
    ), K = d(() => e.cover === !0 ? M.value : yo(e.self || "top start", u.lang.rtl)), Q = d(
      () => (e.square === !0 ? " q-menu--square" : "") + (h.value === !0 ? " q-menu--dark q-dark" : "")
    ), te = d(() => e.autoClose === !0 ? { onClick: ie } : {}), N = d(
      () => S.value === !0 && e.persistent !== !0
    );
    ce(N, (z) => {
      z === !0 ? (Er(j), Fs($)) : (cl(j), vo($));
    });
    function Z() {
      Un(() => {
        let z = f.value;
        z && z.contains(document.activeElement) !== !0 && (z = z.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || z.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || z.querySelector("[autofocus], [data-autofocus]") || z, z.focus({ preventScroll: !0 }));
      });
    }
    function de(z) {
      if (a = e.noRefocus === !1 ? document.activeElement : null, Rr(me), L(), G(), o = void 0, z !== void 0 && (e.touchPosition || e.contextMenu)) {
        const qe = Sn(z);
        if (qe.left !== void 0) {
          const { top: pe, left: Re } = A.value.getBoundingClientRect();
          o = { left: qe.left - Re, top: qe.top - pe };
        }
      }
      r === void 0 && (r = ce(
        () => u.screen.width + "|" + u.screen.height + "|" + e.self + "|" + e.anchor + "|" + u.lang.rtl,
        X
      )), e.noFocus !== !0 && document.activeElement.blur(), x(() => {
        X(), e.noFocus !== !0 && Z();
      }), T(() => {
        u.platform.is.ios === !0 && (i = e.autoClose, f.value.click()), X(), L(!0), n("show", z);
      }, e.transitionDuration);
    }
    function q(z) {
      g(), H(), C(!0), a !== null && // menu was hidden from code or ESC plugin
      (z === void 0 || z.qClickOutside !== !0) && (((z && z.type.indexOf("key") === 0 ? a.closest('[tabindex]:not([tabindex^="-"])') : void 0) || a).focus(), a = null), T(() => {
        H(!0), n("hide", z);
      }, e.transitionDuration);
    }
    function C(z) {
      o = void 0, r !== void 0 && (r(), r = void 0), (z === !0 || S.value === !0) && (ra(me), F(), vo($), cl(j)), z !== !0 && (a = null);
    }
    function G() {
      (A.value !== null || e.scrollTarget !== void 0) && (y.value = Cr(A.value, e.scrollTarget), p(y.value, X));
    }
    function ie(z) {
      i !== !0 ? (kr(s, z), n("click", z)) : i = !1;
    }
    function me(z) {
      N.value === !0 && e.noFocus !== !0 && or(f.value, z.target) !== !0 && Z();
    }
    function j(z) {
      n("escapeKey"), D(z);
    }
    function X() {
      Ur({
        targetEl: f.value,
        offset: e.offset,
        anchorEl: A.value,
        anchorOrigin: M.value,
        selfOrigin: K.value,
        absoluteOffset: o,
        fit: e.fit,
        cover: e.cover,
        maxHeight: e.maxHeight,
        maxWidth: e.maxWidth
      });
    }
    function ge() {
      return v(
        Mt,
        P.value,
        () => S.value === !0 ? v("div", {
          role: "menu",
          ...l,
          ref: f,
          tabindex: -1,
          class: [
            "q-menu q-position-engine scroll" + Q.value,
            l.class
          ],
          style: [
            l.style,
            _.value
          ],
          ...te.value
        }, We(t.default)) : null
      );
    }
    return ot(C), Object.assign(s, { focus: Z, updatePosition: X }), E;
  }
});
function Wt(e, t) {
  if (e === t)
    return !0;
  if (e !== null && t !== null && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    let n, l;
    if (e.constructor === Array) {
      if (n = e.length, n !== t.length)
        return !1;
      for (l = n; l-- !== 0; )
        if (Wt(e[l], t[l]) !== !0)
          return !1;
      return !0;
    }
    if (e.constructor === Map) {
      if (e.size !== t.size)
        return !1;
      let o = e.entries();
      for (l = o.next(); l.done !== !0; ) {
        if (t.has(l.value[0]) !== !0)
          return !1;
        l = o.next();
      }
      for (o = e.entries(), l = o.next(); l.done !== !0; ) {
        if (Wt(l.value[1], t.get(l.value[0])) !== !0)
          return !1;
        l = o.next();
      }
      return !0;
    }
    if (e.constructor === Set) {
      if (e.size !== t.size)
        return !1;
      const o = e.entries();
      for (l = o.next(); l.done !== !0; ) {
        if (t.has(l.value[0]) !== !0)
          return !1;
        l = o.next();
      }
      return !0;
    }
    if (e.buffer != null && e.buffer.constructor === ArrayBuffer) {
      if (n = e.length, n !== t.length)
        return !1;
      for (l = n; l-- !== 0; )
        if (e[l] !== t[l])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    const a = Object.keys(e).filter((o) => e[o] !== void 0);
    if (n = a.length, n !== Object.keys(t).filter((o) => t[o] !== void 0).length)
      return !1;
    for (l = n; l-- !== 0; ) {
      const o = a[l];
      if (Wt(e[o], t[o]) !== !0)
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function qa(e) {
  return e !== null && typeof e == "object" && Array.isArray(e) !== !0;
}
function So(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function ca(e) {
  return typeof e == "number" && isFinite(e);
}
const wo = (e) => ["add", "add-unique", "toggle"].includes(e), Ns = ".*+?^${}()|[]\\", zs = Object.keys(xl);
function Nl(e, t) {
  if (typeof e == "function") return e;
  const n = e !== void 0 ? e : t;
  return (l) => l !== null && typeof l == "object" && n in l ? l[n] : l;
}
const hl = Ce({
  name: "QSelect",
  inheritAttrs: !1,
  props: {
    ...ua,
    ...qn,
    ...xl,
    // override of useFieldProps > modelValue
    modelValue: {
      required: !0
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueHtml: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsHtml: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    popupNoRouteDismiss: Boolean,
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: wo
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    disableTabSelection: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    autocomplete: String,
    transitionShow: {},
    transitionHide: {},
    transitionDuration: {},
    behavior: {
      type: String,
      validator: (e) => ["default", "menu", "dialog"].includes(e),
      default: "default"
    },
    // override of useVirtualScrollProps > virtualScrollItemSize (no default)
    virtualScrollItemSize: ua.virtualScrollItemSize.type,
    onNewValue: Function,
    onFilter: Function
  },
  emits: [
    ...xa,
    "add",
    "remove",
    "inputValue",
    "keyup",
    "keypress",
    "keydown",
    "popupShow",
    "popupHide",
    "filterAbort"
  ],
  setup(e, { slots: t, emit: n }) {
    const { proxy: l } = we(), { $q: a } = l, o = J(!1), r = J(!1), i = J(-1), c = J(""), s = J(!1), u = J(!1);
    let f = null, S = null, b, h, x, g = null, T, P, _, y;
    const p = J(null), F = J(null), A = J(null), U = J(null), D = J(null), L = Ar(e), H = Dr(B), E = d(() => Array.isArray(e.options) ? e.options.length : 0), $ = d(() => e.virtualScrollItemSize === void 0 ? e.optionsDense === !0 ? 24 : 48 : e.virtualScrollItemSize), {
      virtualScrollSliceRange: M,
      virtualScrollSliceSizeComputed: K,
      localResetVirtualScroll: Q,
      padVirtualScroll: te,
      onVirtualScrollEvt: N,
      scrollTo: Z,
      setVirtualScrollSize: de
    } = Ir({
      virtualScrollLength: E,
      getVirtualScrollTarget: Nt,
      getVirtualScrollEl: qt,
      virtualScrollItemSizeComputed: $
    }), q = _a(), C = d(() => {
      const w = e.mapOptions === !0 && e.multiple !== !0, ne = e.modelValue !== void 0 && (e.modelValue !== null || w === !0) ? e.multiple === !0 && Array.isArray(e.modelValue) ? e.modelValue : [e.modelValue] : [];
      if (e.mapOptions === !0 && Array.isArray(e.options) === !0) {
        const le = e.mapOptions === !0 && b !== void 0 ? b : [], ye = ne.map((Be) => oe(Be, le));
        return e.modelValue === null && w === !0 ? ye.filter((Be) => Be !== null) : ye;
      }
      return ne;
    }), G = d(() => {
      const w = {};
      return zs.forEach((ne) => {
        const le = e[ne];
        le !== void 0 && (w[ne] = le);
      }), w;
    }), ie = d(() => e.optionsDark === null ? q.isDark.value : e.optionsDark), me = d(() => In(C.value)), j = d(() => {
      let w = "q-field__input q-placeholder col";
      return e.hideSelected === !0 || C.value.length === 0 ? [w, e.inputClass] : (w += " q-field__input--padding", e.inputClass === void 0 ? w : [w, e.inputClass]);
    }), X = d(
      () => (e.virtualScrollHorizontal === !0 ? "q-virtual-scroll--horizontal" : "") + (e.popupContentClass ? " " + e.popupContentClass : "")
    ), ge = d(() => E.value === 0), z = d(
      () => C.value.map((w) => He.value(w)).join(", ")
    ), qe = d(() => e.displayValue !== void 0 ? e.displayValue : z.value), pe = d(() => e.optionsHtml === !0 ? () => !0 : (w) => w != null && w.html === !0), Re = d(() => e.displayValueHtml === !0 || e.displayValue === void 0 && (e.optionsHtml === !0 || C.value.some(pe.value))), je = d(() => q.focused.value === !0 ? e.tabindex : -1), ut = d(() => {
      const w = {
        tabindex: e.tabindex,
        role: "combobox",
        "aria-label": e.label,
        "aria-readonly": e.readonly === !0 ? "true" : "false",
        "aria-autocomplete": e.useInput === !0 ? "list" : "none",
        "aria-expanded": o.value === !0 ? "true" : "false",
        "aria-controls": `${q.targetUid.value}_lb`
      };
      return i.value >= 0 && (w["aria-activedescendant"] = `${q.targetUid.value}_${i.value}`), w;
    }), nt = d(() => ({
      id: `${q.targetUid.value}_lb`,
      role: "listbox",
      "aria-multiselectable": e.multiple === !0 ? "true" : "false"
    })), Qe = d(() => C.value.map((w, ne) => ({
      index: ne,
      opt: w,
      html: pe.value(w),
      selected: !0,
      removeAtIndex: Tt,
      toggleOption: lt,
      tabindex: je.value
    }))), $e = d(() => {
      if (E.value === 0)
        return [];
      const { from: w, to: ne } = M.value;
      return e.options.slice(w, ne).map((le, ye) => {
        const Be = ht.value(le) === !0, Oe = he(le) === !0, et = w + ye, Ne = {
          clickable: !0,
          active: Oe,
          activeClass: dt.value,
          manualFocus: !0,
          focused: !1,
          disable: Be,
          tabindex: -1,
          dense: e.optionsDense,
          dark: ie.value,
          role: "option",
          "aria-selected": Oe === !0 ? "true" : "false",
          id: `${q.targetUid.value}_${et}`,
          onClick: () => {
            lt(le);
          }
        };
        return Be !== !0 && (i.value === et && (Ne.focused = !0), a.platform.is.desktop === !0 && (Ne.onMousemove = () => {
          o.value === !0 && V(et);
        })), {
          index: et,
          opt: le,
          html: pe.value(le),
          label: He.value(le),
          selected: Ne.active,
          focused: Ne.focused,
          toggleOption: lt,
          setOptionIndex: V,
          itemProps: Ne
        };
      });
    }), Ct = d(() => e.dropdownIcon !== void 0 ? e.dropdownIcon : a.iconSet.arrow.dropdown), Dt = d(
      () => e.optionsCover === !1 && e.outlined !== !0 && e.standout !== !0 && e.borderless !== !0 && e.rounded !== !0
    ), dt = d(() => e.optionsSelectedClass !== void 0 ? e.optionsSelectedClass : e.color !== void 0 ? `text-${e.color}` : ""), Ue = d(() => Nl(e.optionValue, "value")), He = d(() => Nl(e.optionLabel, "label")), ht = d(() => Nl(e.optionDisable, "disable")), wt = d(() => C.value.map(Ue.value)), Lt = d(() => {
      const w = {
        onInput: B,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange: H,
        onKeydown: Je,
        onKeyup: ue,
        onKeypress: Pe,
        onFocus: Ee,
        onClick(ne) {
          h === !0 && bt(ne);
        }
      };
      return w.onCompositionstart = w.onCompositionupdate = w.onCompositionend = H, w;
    });
    ce(C, (w) => {
      b = w, e.useInput === !0 && e.fillInput === !0 && e.multiple !== !0 && q.innerLoading.value !== !0 && (r.value !== !0 && o.value !== !0 || me.value !== !0) && (x !== !0 && dn(), (r.value === !0 || o.value === !0) && se(""));
    }, { immediate: !0 }), ce(() => e.fillInput, dn), ce(o, Pl), ce(E, Bi);
    function kt(w) {
      return e.emitValue === !0 ? Ue.value(w) : w;
    }
    function ft(w) {
      if (w !== -1 && w < C.value.length)
        if (e.multiple === !0) {
          const ne = e.modelValue.slice();
          n("remove", { index: w, value: ne.splice(w, 1)[0] }), n("update:modelValue", ne);
        } else
          n("update:modelValue", null);
    }
    function Tt(w) {
      ft(w), q.focus();
    }
    function Pt(w, ne) {
      const le = kt(w);
      if (e.multiple !== !0) {
        e.fillInput === !0 && re(
          He.value(w),
          !0,
          !0
        ), n("update:modelValue", le);
        return;
      }
      if (C.value.length === 0) {
        n("add", { index: 0, value: le }), n("update:modelValue", e.multiple === !0 ? [le] : le);
        return;
      }
      if (ne === !0 && he(w) === !0 || e.maxValues !== void 0 && e.modelValue.length >= e.maxValues) return;
      const ye = e.modelValue.slice();
      n("add", { index: ye.length, value: le }), ye.push(le), n("update:modelValue", ye);
    }
    function lt(w, ne) {
      if (q.editable.value !== !0 || w === void 0 || ht.value(w) === !0) return;
      const le = Ue.value(w);
      if (e.multiple !== !0) {
        ne !== !0 && (re(
          e.fillInput === !0 ? He.value(w) : "",
          !0,
          !0
        ), gt()), F.value !== null && F.value.focus(), (C.value.length === 0 || Wt(Ue.value(C.value[0]), le) !== !0) && n("update:modelValue", e.emitValue === !0 ? le : w);
        return;
      }
      if ((h !== !0 || s.value === !0) && q.focus(), Ee(), C.value.length === 0) {
        const Oe = e.emitValue === !0 ? le : w;
        n("add", { index: 0, value: Oe }), n("update:modelValue", e.multiple === !0 ? [Oe] : Oe);
        return;
      }
      const ye = e.modelValue.slice(), Be = wt.value.findIndex((Oe) => Wt(Oe, le));
      if (Be !== -1)
        n("remove", { index: Be, value: ye.splice(Be, 1)[0] });
      else {
        if (e.maxValues !== void 0 && ye.length >= e.maxValues) return;
        const Oe = e.emitValue === !0 ? le : w;
        n("add", { index: ye.length, value: Oe }), ye.push(Oe);
      }
      n("update:modelValue", ye);
    }
    function V(w) {
      if (a.platform.is.desktop !== !0) return;
      const ne = w !== -1 && w < E.value ? w : -1;
      i.value !== ne && (i.value = ne);
    }
    function I(w = 1, ne) {
      if (o.value === !0) {
        let le = i.value;
        do
          le = fo(
            le + w,
            -1,
            E.value - 1
          );
        while (le !== -1 && le !== i.value && ht.value(e.options[le]) === !0);
        i.value !== le && (V(le), Z(le), ne !== !0 && e.useInput === !0 && e.fillInput === !0 && ee(
          le >= 0 ? He.value(e.options[le]) : T,
          !0
        ));
      }
    }
    function oe(w, ne) {
      const le = (ye) => Wt(Ue.value(ye), w);
      return e.options.find(le) || ne.find(le) || w;
    }
    function he(w) {
      const ne = Ue.value(w);
      return wt.value.find((le) => Wt(le, ne)) !== void 0;
    }
    function Ee(w) {
      e.useInput === !0 && F.value !== null && (w === void 0 || F.value === w.target && w.target.value === z.value) && F.value.select();
    }
    function Xe(w) {
      It(w, 27) === !0 && o.value === !0 && (bt(w), gt(), dn()), n("keyup", w);
    }
    function ue(w) {
      const { value: ne } = w.target;
      if (w.keyCode !== void 0) {
        Xe(w);
        return;
      }
      if (w.target.value = "", f !== null && (clearTimeout(f), f = null), S !== null && (clearTimeout(S), S = null), dn(), typeof ne == "string" && ne.length !== 0) {
        const le = ne.toLocaleLowerCase(), ye = (Oe) => {
          const et = e.options.find((Ne) => String(Oe.value(Ne)).toLocaleLowerCase() === le);
          return et === void 0 ? !1 : (C.value.indexOf(et) === -1 ? lt(et) : gt(), !0);
        }, Be = (Oe) => {
          ye(Ue) !== !0 && Oe !== !0 && ye(He) !== !0 && se(ne, !0, () => Be(!0));
        };
        Be();
      } else
        q.clearValue(w);
    }
    function Pe(w) {
      n("keypress", w);
    }
    function Je(w) {
      if (n("keydown", w), Sa(w) === !0) return;
      const ne = c.value.length !== 0 && (e.newValueMode !== void 0 || e.onNewValue !== void 0), le = w.shiftKey !== !0 && e.disableTabSelection !== !0 && e.multiple !== !0 && (i.value !== -1 || ne === !0);
      if (w.keyCode === 27) {
        ct(w);
        return;
      }
      if (w.keyCode === 9 && le === !1) {
        fe();
        return;
      }
      if (w.target === void 0 || w.target.id !== q.targetUid.value || q.editable.value !== !0) return;
      if (w.keyCode === 40 && q.innerLoading.value !== !0 && o.value === !1) {
        Fe(w), _e();
        return;
      }
      if (w.keyCode === 8 && (e.useChips === !0 || e.clearable === !0) && e.hideSelected !== !0 && c.value.length === 0) {
        e.multiple === !0 && Array.isArray(e.modelValue) === !0 ? ft(e.modelValue.length - 1) : e.multiple !== !0 && e.modelValue !== null && n("update:modelValue", null);
        return;
      }
      (w.keyCode === 35 || w.keyCode === 36) && (typeof c.value != "string" || c.value.length === 0) && (Fe(w), i.value = -1, I(w.keyCode === 36 ? 1 : -1, e.multiple)), (w.keyCode === 33 || w.keyCode === 34) && K.value !== void 0 && (Fe(w), i.value = Math.max(
        -1,
        Math.min(
          E.value,
          i.value + (w.keyCode === 33 ? -1 : 1) * K.value.view
        )
      ), I(w.keyCode === 33 ? 1 : -1, e.multiple)), (w.keyCode === 38 || w.keyCode === 40) && (Fe(w), I(w.keyCode === 38 ? -1 : 1, e.multiple));
      const ye = E.value;
      if ((_ === void 0 || y < Date.now()) && (_ = ""), ye > 0 && e.useInput !== !0 && w.key !== void 0 && w.key.length === 1 && w.altKey === !1 && w.ctrlKey === !1 && w.metaKey === !1 && (w.keyCode !== 32 || _.length !== 0)) {
        o.value !== !0 && _e(w);
        const Be = w.key.toLocaleLowerCase(), Oe = _.length === 1 && _[0] === Be;
        y = Date.now() + 1500, Oe === !1 && (Fe(w), _ += Be);
        const et = new RegExp("^" + _.split("").map((Ol) => Ns.indexOf(Ol) !== -1 ? "\\" + Ol : Ol).join(".*"), "i");
        let Ne = i.value;
        if (Oe === !0 || Ne < 0 || et.test(He.value(e.options[Ne])) !== !0)
          do
            Ne = fo(Ne + 1, -1, ye - 1);
          while (Ne !== i.value && (ht.value(e.options[Ne]) === !0 || et.test(He.value(e.options[Ne])) !== !0));
        i.value !== Ne && De(() => {
          V(Ne), Z(Ne), Ne >= 0 && e.useInput === !0 && e.fillInput === !0 && ee(He.value(e.options[Ne]), !0);
        });
        return;
      }
      if (!(w.keyCode !== 13 && (w.keyCode !== 32 || e.useInput === !0 || _ !== "") && (w.keyCode !== 9 || le === !1))) {
        if (w.keyCode !== 9 && Fe(w), i.value !== -1 && i.value < ye) {
          lt(e.options[i.value]);
          return;
        }
        if (ne === !0) {
          const Be = (Oe, et) => {
            if (et) {
              if (wo(et) !== !0) return;
            } else
              et = e.newValueMode;
            if (re("", e.multiple !== !0, !0), Oe == null) return;
            (et === "toggle" ? lt : Pt)(Oe, et === "add-unique"), e.multiple !== !0 && (F.value !== null && F.value.focus(), gt());
          };
          if (e.onNewValue !== void 0 ? n("newValue", c.value, Be) : Be(c.value), e.multiple !== !0) return;
        }
        o.value === !0 ? fe() : q.innerLoading.value !== !0 && _e();
      }
    }
    function qt() {
      return h === !0 ? D.value : A.value !== null && A.value.contentEl !== null ? A.value.contentEl : void 0;
    }
    function Nt() {
      return qt();
    }
    function Ot() {
      return e.hideSelected === !0 ? [] : t["selected-item"] !== void 0 ? Qe.value.map((w) => t["selected-item"](w)).slice() : t.selected !== void 0 ? [].concat(t.selected()) : e.useChips === !0 ? Qe.value.map((w, ne) => v(Os, {
        key: "option-" + ne,
        removable: q.editable.value === !0 && ht.value(w.opt) !== !0,
        dense: !0,
        textColor: e.color,
        tabindex: je.value,
        onRemove() {
          w.removeAtIndex(ne);
        }
      }, () => v("span", {
        class: "ellipsis",
        [w.html === !0 ? "innerHTML" : "textContent"]: He.value(w.opt)
      }))) : [
        v("span", {
          [Re.value === !0 ? "innerHTML" : "textContent"]: qe.value
        })
      ];
    }
    function zt() {
      if (ge.value === !0)
        return t["no-option"] !== void 0 ? t["no-option"]({ inputValue: c.value }) : void 0;
      const w = t.option !== void 0 ? t.option : (le) => v(Bs, {
        key: le.index,
        ...le.itemProps
      }, () => v(
        Vs,
        () => v(
          As,
          () => v("span", {
            [le.html === !0 ? "innerHTML" : "textContent"]: le.label
          })
        )
      ));
      let ne = te("div", $e.value.map(w));
      return t["before-options"] !== void 0 && (ne = t["before-options"]().concat(ne)), Vt(t["after-options"], ne);
    }
    function Jt(w, ne) {
      const le = ne === !0 ? { ...ut.value, ...q.splitAttrs.attributes.value } : void 0, ye = {
        ref: ne === !0 ? F : void 0,
        key: "i_t",
        class: j.value,
        style: e.inputStyle,
        value: c.value !== void 0 ? c.value : "",
        // required for Android in order to show ENTER key when in form
        type: "search",
        ...le,
        id: ne === !0 ? q.targetUid.value : void 0,
        maxlength: e.maxlength,
        autocomplete: e.autocomplete,
        "data-autofocus": w === !0 || e.autofocus === !0 || void 0,
        disabled: e.disable === !0,
        readonly: e.readonly === !0,
        ...Lt.value
      };
      return w !== !0 && h === !0 && (Array.isArray(ye.class) === !0 ? ye.class = [...ye.class, "no-pointer-events"] : ye.class += " no-pointer-events"), v("input", ye);
    }
    function B(w) {
      f !== null && (clearTimeout(f), f = null), S !== null && (clearTimeout(S), S = null), !(w && w.target && w.target.qComposing === !0) && (ee(w.target.value || ""), x = !0, T = c.value, q.focused.value !== !0 && (h !== !0 || s.value === !0) && q.focus(), e.onFilter !== void 0 && (f = setTimeout(() => {
        f = null, se(c.value);
      }, e.inputDebounce)));
    }
    function ee(w, ne) {
      c.value !== w && (c.value = w, ne === !0 || e.inputDebounce === 0 || e.inputDebounce === "0" ? n("inputValue", w) : S = setTimeout(() => {
        S = null, n("inputValue", w);
      }, e.inputDebounce));
    }
    function re(w, ne, le) {
      x = le !== !0, e.useInput === !0 && (ee(w, !0), (ne === !0 || le !== !0) && (T = w), ne !== !0 && se(w));
    }
    function se(w, ne, le) {
      if (e.onFilter === void 0 || ne !== !0 && q.focused.value !== !0) return;
      q.innerLoading.value === !0 ? n("filterAbort") : (q.innerLoading.value = !0, u.value = !0), w !== "" && e.multiple !== !0 && C.value.length !== 0 && x !== !0 && w === He.value(C.value[0]) && (w = "");
      const ye = setTimeout(() => {
        o.value === !0 && (o.value = !1);
      }, 10);
      g !== null && clearTimeout(g), g = ye, n(
        "filter",
        w,
        (Be, Oe) => {
          (ne === !0 || q.focused.value === !0) && g === ye && (clearTimeout(g), typeof Be == "function" && Be(), u.value = !1, De(() => {
            q.innerLoading.value = !1, q.editable.value === !0 && (ne === !0 ? o.value === !0 && gt() : o.value === !0 ? Pl(!0) : o.value = !0), typeof Oe == "function" && De(() => {
              Oe(l);
            }), typeof le == "function" && De(() => {
              le(l);
            });
          }));
        },
        () => {
          q.focused.value === !0 && g === ye && (clearTimeout(g), q.innerLoading.value = !1, u.value = !1), o.value === !0 && (o.value = !1);
        }
      );
    }
    function be() {
      return v(Yr, {
        ref: A,
        class: X.value,
        style: e.popupContentStyle,
        modelValue: o.value,
        fit: e.menuShrink !== !0,
        cover: e.optionsCover === !0 && ge.value !== !0 && e.useInput !== !0,
        anchor: e.menuAnchor,
        self: e.menuSelf,
        offset: e.menuOffset,
        dark: ie.value,
        noParentEvent: !0,
        noRefocus: !0,
        noFocus: !0,
        noRouteDismiss: e.popupNoRouteDismiss,
        square: Dt.value,
        transitionShow: e.transitionShow,
        transitionHide: e.transitionHide,
        transitionDuration: e.transitionDuration,
        separateClosePopup: !0,
        ...nt.value,
        onScrollPassive: N,
        onBeforeShow: Va,
        onBeforeHide: Ve,
        onShow: m
      }, zt);
    }
    function Ve(w) {
      Aa(w), fe();
    }
    function m() {
      de();
    }
    function k(w) {
      bt(w), F.value !== null && F.value.focus(), s.value = !0, window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    }
    function R(w) {
      bt(w), De(() => {
        s.value = !1;
      });
    }
    function Y() {
      const w = [
        v(Ts, {
          class: `col-auto ${q.fieldClass.value}`,
          ...G.value,
          for: q.targetUid.value,
          dark: ie.value,
          square: !0,
          loading: u.value,
          itemAligned: !1,
          filled: !0,
          stackLabel: c.value.length !== 0,
          ...q.splitAttrs.listeners.value,
          onFocus: k,
          onBlur: R
        }, {
          ...t,
          rawControl: () => q.getControl(!0),
          before: void 0,
          after: void 0
        })
      ];
      return o.value === !0 && w.push(
        v("div", {
          ref: D,
          class: X.value + " scroll",
          style: e.popupContentStyle,
          ...nt.value,
          onClick: ct,
          onScrollPassive: N
        }, zt())
      ), v(kl, {
        ref: U,
        modelValue: r.value,
        position: e.useInput === !0 ? "top" : void 0,
        transitionShow: P,
        transitionHide: e.transitionHide,
        transitionDuration: e.transitionDuration,
        noRouteDismiss: e.popupNoRouteDismiss,
        onBeforeShow: Va,
        onBeforeHide: W,
        onHide: Se,
        onShow: ae
      }, () => v("div", {
        class: "q-select__dialog" + (ie.value === !0 ? " q-select__dialog--dark q-dark" : "") + (s.value === !0 ? " q-select__dialog--focused" : "")
      }, w));
    }
    function W(w) {
      Aa(w), U.value !== null && U.value.__updateRefocusTarget(
        q.rootRef.value.querySelector(".q-field__native > [tabindex]:last-child")
      ), q.focused.value = !1;
    }
    function Se(w) {
      gt(), q.focused.value === !1 && n("blur", w), dn();
    }
    function ae() {
      const w = document.activeElement;
      (w === null || w.id !== q.targetUid.value) && F.value !== null && F.value !== w && F.value.focus(), de();
    }
    function fe() {
      r.value !== !0 && (i.value = -1, o.value === !0 && (o.value = !1), q.focused.value === !1 && (g !== null && (clearTimeout(g), g = null), q.innerLoading.value === !0 && (n("filterAbort"), q.innerLoading.value = !1, u.value = !1)));
    }
    function _e(w) {
      q.editable.value === !0 && (h === !0 ? (q.onControlFocusin(w), r.value = !0, De(() => {
        q.focus();
      })) : q.focus(), e.onFilter !== void 0 ? se(c.value) : (ge.value !== !0 || t["no-option"] !== void 0) && (o.value = !0));
    }
    function gt() {
      r.value = !1, fe();
    }
    function dn() {
      e.useInput === !0 && re(
        e.multiple !== !0 && e.fillInput === !0 && C.value.length !== 0 && He.value(C.value[0]) || "",
        !0,
        !0
      );
    }
    function Pl(w) {
      let ne = -1;
      if (w === !0) {
        if (C.value.length !== 0) {
          const le = Ue.value(C.value[0]);
          ne = e.options.findIndex((ye) => Wt(Ue.value(ye), le));
        }
        Q(ne);
      }
      V(ne);
    }
    function Bi(w, ne) {
      o.value === !0 && q.innerLoading.value === !1 && (Q(-1, !0), De(() => {
        o.value === !0 && q.innerLoading.value === !1 && (w > ne ? Q() : Pl(!0));
      }));
    }
    function Ba() {
      r.value === !1 && A.value !== null && A.value.updatePosition();
    }
    function Va(w) {
      w !== void 0 && bt(w), n("popupShow", w), q.hasPopupOpen = !0, q.onControlFocusin(w);
    }
    function Aa(w) {
      w !== void 0 && bt(w), n("popupHide", w), q.hasPopupOpen = !1, q.onControlFocusout(w);
    }
    function Da() {
      h = a.platform.is.mobile !== !0 && e.behavior !== "dialog" ? !1 : e.behavior !== "menu" && (e.useInput === !0 ? t["no-option"] !== void 0 || e.onFilter !== void 0 || ge.value === !1 : !0), P = a.platform.is.ios === !0 && h === !0 && e.useInput === !0 ? "fade" : e.transitionShow;
    }
    return Xo(Da), Fi(Ba), Da(), ot(() => {
      f !== null && clearTimeout(f), S !== null && clearTimeout(S);
    }), Object.assign(l, {
      showPopup: _e,
      hidePopup: gt,
      removeAtIndex: ft,
      add: Pt,
      toggleOption: lt,
      getOptionIndex: () => i.value,
      setOptionIndex: V,
      moveOptionSelection: I,
      filter: se,
      updateMenuPosition: Ba,
      updateInputValue: re,
      isOptionSelected: he,
      getEmittingOptionValue: kt,
      isOptionDisabled: (...w) => ht.value.apply(null, w) === !0,
      getOptionValue: (...w) => Ue.value.apply(null, w),
      getOptionLabel: (...w) => He.value.apply(null, w)
    }), Object.assign(q, {
      innerValue: C,
      fieldClass: d(
        () => `q-select q-field--auto-height q-select--with${e.useInput !== !0 ? "out" : ""}-input q-select--with${e.useChips !== !0 ? "out" : ""}-chips q-select--${e.multiple === !0 ? "multiple" : "single"}`
      ),
      inputRef: p,
      targetRef: F,
      hasValue: me,
      showPopup: _e,
      floatingLabel: d(
        () => e.hideSelected !== !0 && me.value === !0 || typeof c.value == "number" || c.value.length !== 0 || In(e.displayValue)
      ),
      getControlChild: () => {
        if (q.editable.value !== !1 && (r.value === !0 || ge.value !== !0 || t["no-option"] !== void 0))
          return h === !0 ? Y() : be();
        q.hasPopupOpen === !0 && (q.hasPopupOpen = !1);
      },
      controlEvents: {
        onFocusin(w) {
          q.onControlFocusin(w);
        },
        onFocusout(w) {
          q.onControlFocusout(w, () => {
            dn(), fe();
          });
        },
        onClick(w) {
          if (ct(w), h !== !0 && o.value === !0) {
            fe(), F.value !== null && F.value.focus();
            return;
          }
          _e(w);
        }
      },
      getControl: (w) => {
        const ne = Ot(), le = w === !0 || r.value !== !0 || h !== !0;
        if (e.useInput === !0)
          ne.push(Jt(w, le));
        else if (q.editable.value === !0) {
          const Be = le === !0 ? ut.value : void 0;
          ne.push(
            v("input", {
              ref: le === !0 ? F : void 0,
              key: "d_t",
              class: "q-select__focus-target",
              id: le === !0 ? q.targetUid.value : void 0,
              value: qe.value,
              readonly: !0,
              "data-autofocus": w === !0 || e.autofocus === !0 || void 0,
              ...Be,
              onKeydown: Je,
              onKeyup: Xe,
              onKeypress: Pe
            })
          ), le === !0 && typeof e.autocomplete == "string" && e.autocomplete.length !== 0 && ne.push(
            v("input", {
              class: "q-select__autocomplete-input",
              autocomplete: e.autocomplete,
              tabindex: -1,
              onKeyup: ue
            })
          );
        }
        if (L.value !== void 0 && e.disable !== !0 && wt.value.length !== 0) {
          const Be = wt.value.map((Oe) => v("option", { value: Oe, selected: !0 }));
          ne.push(
            v("select", {
              class: "hidden",
              name: L.value,
              multiple: e.multiple
            }, Be)
          );
        }
        const ye = e.useInput === !0 || le !== !0 ? void 0 : q.splitAttrs.attributes.value;
        return v("div", {
          class: "q-field__native row items-center",
          ...ye,
          ...q.splitAttrs.listeners.value
        }, ne);
      },
      getInnerAppend: () => e.loading !== !0 && u.value !== !0 && e.hideDropdownIcon !== !0 ? [
        v(pt, {
          class: "q-select__dropdown-icon" + (o.value === !0 ? " rotate-180" : ""),
          name: Ct.value
        })
      ] : null
    }), Ca(q);
  }
}), Us = {
  xs: 2,
  sm: 4,
  md: 6,
  lg: 10,
  xl: 14
};
function ko(e, t, n) {
  return {
    transform: t === !0 ? `translateX(${n.lang.rtl === !0 ? "-" : ""}100%) scale3d(${-e},1,1)` : `scale3d(${e},1,1)`
  };
}
const Ys = Ce({
  name: "QLinearProgress",
  props: {
    ...rt,
    ..._n,
    value: {
      type: Number,
      default: 0
    },
    buffer: Number,
    color: String,
    trackColor: String,
    reverse: Boolean,
    stripe: Boolean,
    indeterminate: Boolean,
    query: Boolean,
    rounded: Boolean,
    animationSpeed: {
      type: [String, Number],
      default: 2100
    },
    instantFeedback: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: n } = we(), l = it(e, n.$q), a = Cn(e, Us), o = d(() => e.indeterminate === !0 || e.query === !0), r = d(() => e.reverse !== e.query), i = d(() => ({
      ...a.value !== null ? a.value : {},
      "--q-linear-progress-speed": `${e.animationSpeed}ms`
    })), c = d(
      () => "q-linear-progress" + (e.color !== void 0 ? ` text-${e.color}` : "") + (e.reverse === !0 || e.query === !0 ? " q-linear-progress--reverse" : "") + (e.rounded === !0 ? " rounded-borders" : "")
    ), s = d(() => ko(e.buffer !== void 0 ? e.buffer : 1, r.value, n.$q)), u = d(() => `with${e.instantFeedback === !0 ? "out" : ""}-transition`), f = d(
      () => `q-linear-progress__track absolute-full q-linear-progress__track--${u.value} q-linear-progress__track--${l.value === !0 ? "dark" : "light"}` + (e.trackColor !== void 0 ? ` bg-${e.trackColor}` : "")
    ), S = d(() => ko(o.value === !0 ? 1 : e.value, r.value, n.$q)), b = d(
      () => `q-linear-progress__model absolute-full q-linear-progress__model--${u.value} q-linear-progress__model--${o.value === !0 ? "in" : ""}determinate`
    ), h = d(() => ({ width: `${e.value * 100}%` })), x = d(
      () => `q-linear-progress__stripe absolute-${e.reverse === !0 ? "right" : "left"} q-linear-progress__stripe--${u.value}`
    );
    return () => {
      const g = [
        v("div", {
          class: f.value,
          style: s.value
        }),
        v("div", {
          class: b.value,
          style: S.value
        })
      ];
      return e.stripe === !0 && o.value === !1 && g.push(
        v("div", {
          class: x.value,
          style: h.value
        })
      ), v("div", {
        class: c.value,
        style: i.value,
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 1,
        "aria-valuenow": e.indeterminate === !0 ? void 0 : e.value
      }, Vt(t.default, g));
    };
  }
});
function Kr(e, t) {
  const n = J(null), l = d(() => e.disable === !0 ? null : v("span", {
    ref: n,
    class: "no-outline",
    tabindex: -1
  }));
  function a(o) {
    const r = t.value;
    o !== void 0 && o.type.indexOf("key") === 0 ? r !== null && document.activeElement !== r && r.contains(document.activeElement) === !0 && r.focus() : n.value !== null && (o === void 0 || r !== null && r.contains(o.target) === !0) && n.value.focus();
  }
  return {
    refocusTargetEl: l,
    refocusTarget: a
  };
}
const Wr = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
}, Qr = {
  ...rt,
  ..._n,
  ...qn,
  modelValue: {
    required: !0,
    default: null
  },
  val: {},
  trueValue: { default: !0 },
  falseValue: { default: !1 },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (e) => e === "tf" || e === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
}, Xr = ["update:modelValue"];
function Jr(e, t) {
  const { props: n, slots: l, emit: a, proxy: o } = we(), { $q: r } = o, i = it(n, r), c = J(null), { refocusTargetEl: s, refocusTarget: u } = Kr(n, c), f = Cn(n, Wr), S = d(
    () => n.val !== void 0 && Array.isArray(n.modelValue)
  ), b = d(() => {
    const E = Yt(n.val);
    return S.value === !0 ? n.modelValue.findIndex(($) => Yt($) === E) : -1;
  }), h = d(() => S.value === !0 ? b.value !== -1 : Yt(n.modelValue) === Yt(n.trueValue)), x = d(() => S.value === !0 ? b.value === -1 : Yt(n.modelValue) === Yt(n.falseValue)), g = d(
    () => h.value === !1 && x.value === !1
  ), T = d(() => n.disable === !0 ? -1 : n.tabindex || 0), P = d(
    () => `q-${e} cursor-pointer no-outline row inline no-wrap items-center` + (n.disable === !0 ? " disabled" : "") + (i.value === !0 ? ` q-${e}--dark` : "") + (n.dense === !0 ? ` q-${e}--dense` : "") + (n.leftLabel === !0 ? " reverse" : "")
  ), _ = d(() => {
    const E = h.value === !0 ? "truthy" : x.value === !0 ? "falsy" : "indet", $ = n.color !== void 0 && (n.keepColor === !0 || (e === "toggle" ? h.value === !0 : x.value !== !0)) ? ` text-${n.color}` : "";
    return `q-${e}__inner relative-position non-selectable q-${e}__inner--${E}${$}`;
  }), y = d(() => {
    const E = { type: "checkbox" };
    return n.name !== void 0 && Object.assign(E, {
      // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
      ".checked": h.value,
      "^checked": h.value === !0 ? "checked" : void 0,
      name: n.name,
      value: S.value === !0 ? n.val : n.trueValue
    }), E;
  }), p = _l(y), F = d(() => {
    const E = {
      tabindex: T.value,
      role: e === "toggle" ? "switch" : "checkbox",
      "aria-label": n.label,
      "aria-checked": g.value === !0 ? "mixed" : h.value === !0 ? "true" : "false"
    };
    return n.disable === !0 && (E["aria-disabled"] = "true"), E;
  });
  function A(E) {
    E !== void 0 && (Fe(E), u(E)), n.disable !== !0 && a("update:modelValue", U(), E);
  }
  function U() {
    if (S.value === !0) {
      if (h.value === !0) {
        const E = n.modelValue.slice();
        return E.splice(b.value, 1), E;
      }
      return n.modelValue.concat([n.val]);
    }
    if (h.value === !0) {
      if (n.toggleOrder !== "ft" || n.toggleIndeterminate === !1)
        return n.falseValue;
    } else if (x.value === !0) {
      if (n.toggleOrder === "ft" || n.toggleIndeterminate === !1)
        return n.trueValue;
    } else
      return n.toggleOrder !== "ft" ? n.trueValue : n.falseValue;
    return n.indeterminateValue;
  }
  function D(E) {
    (E.keyCode === 13 || E.keyCode === 32) && Fe(E);
  }
  function L(E) {
    (E.keyCode === 13 || E.keyCode === 32) && A(E);
  }
  const H = t(h, g);
  return Object.assign(o, { toggle: A }), () => {
    const E = H();
    n.disable !== !0 && p(
      E,
      "unshift",
      ` q-${e}__native absolute q-ma-none q-pa-none`
    );
    const $ = [
      v("div", {
        class: _.value,
        style: f.value,
        "aria-hidden": "true"
      }, E)
    ];
    s.value !== null && $.push(s.value);
    const M = n.label !== void 0 ? Vt(l.default, [n.label]) : We(l.default);
    return M !== void 0 && $.push(
      v("div", {
        class: `q-${e}__label q-anchor--skip`
      }, M)
    ), v("div", {
      ref: c,
      class: P.value,
      ...F.value,
      onClick: A,
      onKeydown: D,
      onKeyup: L
    }, $);
  };
}
const Ks = () => v("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  v("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    v("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    v("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]), Fn = Ce({
  name: "QCheckbox",
  props: Qr,
  emits: Xr,
  setup(e) {
    const t = Ks();
    function n(l, a) {
      const o = d(
        () => (l.value === !0 ? e.checkedIcon : a.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || null
      );
      return () => o.value !== null ? [
        v("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          v(pt, {
            class: "q-checkbox__icon",
            name: o.value
          })
        ])
      ] : [t];
    }
    return Jr("checkbox", n);
  }
});
let On = 0;
const Ws = {
  fullscreen: Boolean,
  noRouteFullscreenExit: Boolean
}, Qs = ["update:fullscreen", "fullscreen"];
function Xs() {
  const e = we(), { props: t, emit: n, proxy: l } = e;
  let a, o;
  const r = J(!1);
  wa(e) === !0 && ce(() => l.$route.fullPath, () => {
    t.noRouteFullscreenExit !== !0 && s();
  }), ce(() => t.fullscreen, (u) => {
    r.value !== u && i();
  }), ce(r, (u) => {
    n("update:fullscreen", u), n("fullscreen", u);
  });
  function i() {
    r.value === !0 ? s() : c();
  }
  function c() {
    r.value !== !0 && (r.value = !0, o = l.$el.parentNode, o.replaceChild(a, l.$el), document.body.appendChild(l.$el), On++, On === 1 && document.body.classList.add("q-body--fullscreen-mixin"));
  }
  function s() {
    r.value === !0 && (o.replaceChild(l.$el, a), r.value = !1, On = Math.max(0, On - 1), On === 0 && (document.body.classList.remove("q-body--fullscreen-mixin"), l.$el.scrollIntoView !== void 0 && setTimeout(() => {
      l.$el.scrollIntoView();
    })));
  }
  return zn(() => {
    a = document.createElement("span");
  }), jt(() => {
    t.fullscreen === !0 && c();
  }), ot(s), Object.assign(l, {
    toggleFullscreen: i,
    setFullscreen: c,
    exitFullscreen: s
  }), {
    inFullscreen: r,
    toggleFullscreen: i
  };
}
function Js(e, t) {
  return new Date(e) - new Date(t);
}
const Zs = {
  sortMethod: Function,
  binaryStateSort: Boolean,
  columnSortOrder: {
    type: String,
    validator: (e) => e === "ad" || e === "da",
    default: "ad"
  }
};
function Gs(e, t, n, l) {
  const a = d(() => {
    const { sortBy: i } = t.value;
    return i && n.value.find((c) => c.name === i) || null;
  }), o = d(() => e.sortMethod !== void 0 ? e.sortMethod : (i, c, s) => {
    const u = n.value.find((b) => b.name === c);
    if (u === void 0 || u.field === void 0)
      return i;
    const f = s === !0 ? -1 : 1, S = typeof u.field == "function" ? (b) => u.field(b) : (b) => b[u.field];
    return i.sort((b, h) => {
      let x = S(b), g = S(h);
      return u.rawSort !== void 0 ? u.rawSort(x, g, b, h) * f : x == null ? -1 * f : g == null ? 1 * f : u.sort !== void 0 ? u.sort(x, g, b, h) * f : ca(x) === !0 && ca(g) === !0 ? (x - g) * f : So(x) === !0 && So(g) === !0 ? Js(x, g) * f : typeof x == "boolean" && typeof g == "boolean" ? (x - g) * f : ([x, g] = [x, g].map((T) => (T + "").toLocaleString().toLowerCase()), x < g ? -1 * f : x === g ? 0 : f);
    });
  });
  function r(i) {
    let c = e.columnSortOrder;
    if (qa(i) === !0)
      i.sortOrder && (c = i.sortOrder), i = i.name;
    else {
      const f = n.value.find((S) => S.name === i);
      f !== void 0 && f.sortOrder && (c = f.sortOrder);
    }
    let { sortBy: s, descending: u } = t.value;
    s !== i ? (s = i, u = c === "da") : e.binaryStateSort === !0 ? u = !u : u === !0 ? c === "ad" ? s = null : u = !1 : c === "ad" ? u = !0 : s = null, l({ sortBy: s, descending: u, page: 1 });
  }
  return {
    columnToSort: a,
    computedSortMethod: o,
    sort: r
  };
}
const ec = {
  filter: [String, Object],
  filterMethod: Function
};
function tc(e, t) {
  const n = d(() => e.filterMethod !== void 0 ? e.filterMethod : (l, a, o, r) => {
    const i = a ? a.toLowerCase() : "";
    return l.filter(
      (c) => o.some((s) => {
        const u = r(s, c) + "";
        return (u === "undefined" || u === "null" ? "" : u.toLowerCase()).indexOf(i) !== -1;
      })
    );
  });
  return ce(
    () => e.filter,
    () => {
      De(() => {
        t({ page: 1 }, !0);
      });
    },
    { deep: !0 }
  ), { computedFilterMethod: n };
}
function nc(e, t) {
  for (const n in t)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function xo(e) {
  return e.page < 1 && (e.page = 1), e.rowsPerPage !== void 0 && e.rowsPerPage < 1 && (e.rowsPerPage = 0), e;
}
const lc = {
  pagination: Object,
  rowsPerPageOptions: {
    type: Array,
    default: () => [5, 7, 10, 15, 20, 25, 50, 0]
  },
  "onUpdate:pagination": [Function, Array]
};
function ac(e, t) {
  const { props: n, emit: l } = e, a = J(
    Object.assign({
      sortBy: null,
      descending: !1,
      page: 1,
      rowsPerPage: n.rowsPerPageOptions.length !== 0 ? n.rowsPerPageOptions[0] : 5
    }, n.pagination)
  ), o = d(() => {
    const u = n["onUpdate:pagination"] !== void 0 ? { ...a.value, ...n.pagination } : a.value;
    return xo(u);
  }), r = d(() => o.value.rowsNumber !== void 0);
  function i(u) {
    c({
      pagination: u,
      filter: n.filter
    });
  }
  function c(u = {}) {
    De(() => {
      l("request", {
        pagination: u.pagination || o.value,
        filter: u.filter || n.filter,
        getCellValue: t
      });
    });
  }
  function s(u, f) {
    const S = xo({
      ...o.value,
      ...u
    });
    if (nc(o.value, S) === !0) {
      r.value === !0 && f === !0 && i(S);
      return;
    }
    if (r.value === !0) {
      i(S);
      return;
    }
    n.pagination !== void 0 && n["onUpdate:pagination"] !== void 0 ? l("update:pagination", S) : a.value = S;
  }
  return {
    innerPagination: a,
    computedPagination: o,
    isServerSide: r,
    requestServerInteraction: c,
    setPagination: s
  };
}
function oc(e, t, n, l, a, o) {
  const { props: r, emit: i, proxy: { $q: c } } = e, s = d(() => l.value === !0 ? n.value.rowsNumber || 0 : o.value), u = d(() => {
    const { page: y, rowsPerPage: p } = n.value;
    return (y - 1) * p;
  }), f = d(() => {
    const { page: y, rowsPerPage: p } = n.value;
    return y * p;
  }), S = d(() => n.value.page === 1), b = d(() => n.value.rowsPerPage === 0 ? 1 : Math.max(
    1,
    Math.ceil(s.value / n.value.rowsPerPage)
  )), h = d(() => f.value === 0 ? !0 : n.value.page >= b.value), x = d(() => (r.rowsPerPageOptions.includes(t.value.rowsPerPage) ? r.rowsPerPageOptions : [t.value.rowsPerPage].concat(r.rowsPerPageOptions)).map((p) => ({
    label: p === 0 ? c.lang.table.allRows : "" + p,
    value: p
  })));
  ce(b, (y, p) => {
    if (y === p) return;
    const F = n.value.page;
    y && !F ? a({ page: 1 }) : y < F && a({ page: y });
  });
  function g() {
    a({ page: 1 });
  }
  function T() {
    const { page: y } = n.value;
    y > 1 && a({ page: y - 1 });
  }
  function P() {
    const { page: y, rowsPerPage: p } = n.value;
    f.value > 0 && y * p < s.value && a({ page: y + 1 });
  }
  function _() {
    a({ page: b.value });
  }
  return r["onUpdate:pagination"] !== void 0 && i("update:pagination", { ...n.value }), {
    firstRowIndex: u,
    lastRowIndex: f,
    isFirstPage: S,
    isLastPage: h,
    pagesNumber: b,
    computedRowsPerPageOptions: x,
    computedRowsNumber: s,
    firstPage: g,
    prevPage: T,
    nextPage: P,
    lastPage: _
  };
}
const rc = {
  selection: {
    type: String,
    default: "none",
    validator: (e) => ["single", "multiple", "none"].includes(e)
  },
  selected: {
    type: Array,
    default: () => []
  }
}, ic = ["update:selected", "selection"];
function uc(e, t, n, l) {
  const a = d(() => {
    const h = {};
    return e.selected.map(l.value).forEach((x) => {
      h[x] = !0;
    }), h;
  }), o = d(() => e.selection !== "none"), r = d(() => e.selection === "single"), i = d(() => e.selection === "multiple"), c = d(
    () => n.value.length !== 0 && n.value.every(
      (h) => a.value[l.value(h)] === !0
    )
  ), s = d(
    () => c.value !== !0 && n.value.some((h) => a.value[l.value(h)] === !0)
  ), u = d(() => e.selected.length);
  function f(h) {
    return a.value[h] === !0;
  }
  function S() {
    t("update:selected", []);
  }
  function b(h, x, g, T) {
    t("selection", { rows: x, added: g, keys: h, evt: T });
    const P = r.value === !0 ? g === !0 ? x : [] : g === !0 ? e.selected.concat(x) : e.selected.filter(
      (_) => h.includes(l.value(_)) === !1
    );
    t("update:selected", P);
  }
  return {
    hasSelectionMode: o,
    singleSelection: r,
    multipleSelection: i,
    allRowsSelected: c,
    someRowsSelected: s,
    rowsSelectedNumber: u,
    isRowSelected: f,
    clearSelection: S,
    updateSelection: b
  };
}
function _o(e) {
  return Array.isArray(e) ? e.slice() : [];
}
const sc = {
  expanded: Array
  // v-model:expanded
}, cc = ["update:expanded"];
function dc(e, t) {
  const n = J(_o(e.expanded));
  ce(() => e.expanded, (r) => {
    n.value = _o(r);
  });
  function l(r) {
    return n.value.includes(r);
  }
  function a(r) {
    e.expanded !== void 0 ? t("update:expanded", r) : n.value = r;
  }
  function o(r, i) {
    const c = n.value.slice(), s = c.indexOf(r);
    i === !0 ? s === -1 && (c.push(r), a(c)) : s !== -1 && (c.splice(s, 1), a(c));
  }
  return {
    isRowExpanded: l,
    setExpanded: a,
    updateExpanded: o
  };
}
const fc = {
  visibleColumns: Array
};
function mc(e, t, n) {
  const l = d(() => {
    if (e.columns !== void 0)
      return e.columns;
    const i = e.rows[0];
    return i !== void 0 ? Object.keys(i).map((c) => ({
      name: c,
      label: c.toUpperCase(),
      field: c,
      align: ca(i[c]) ? "right" : "left",
      sortable: !0
    })) : [];
  }), a = d(() => {
    const { sortBy: i, descending: c } = t.value;
    return (e.visibleColumns !== void 0 ? l.value.filter((u) => u.required === !0 || e.visibleColumns.includes(u.name) === !0) : l.value).map((u) => {
      const f = u.align || "right", S = `text-${f}`;
      return {
        ...u,
        align: f,
        __iconClass: `q-table__sort-icon q-table__sort-icon--${f}`,
        __thClass: S + (u.headerClasses !== void 0 ? " " + u.headerClasses : "") + (u.sortable === !0 ? " sortable" : "") + (u.name === i ? ` sorted ${c === !0 ? "sort-desc" : ""}` : ""),
        __tdStyle: u.style !== void 0 ? typeof u.style != "function" ? () => u.style : u.style : () => null,
        __tdClass: u.classes !== void 0 ? typeof u.classes != "function" ? () => S + " " + u.classes : (b) => S + " " + u.classes(b) : () => S
      };
    });
  }), o = d(() => {
    const i = {};
    return a.value.forEach((c) => {
      i[c.name] = c;
    }), i;
  }), r = d(() => e.tableColspan !== void 0 ? e.tableColspan : a.value.length + (n.value === !0 ? 1 : 0));
  return {
    colList: l,
    computedCols: a,
    computedColsMap: o,
    computedColspan: r
  };
}
const tl = "q-table__bottom row items-center", Zr = {};
Hr.forEach((e) => {
  Zr[e] = {};
});
const vc = Ce({
  name: "QTable",
  props: {
    rows: {
      type: Array,
      required: !0
    },
    rowKey: {
      type: [String, Function],
      default: "id"
    },
    columns: Array,
    loading: Boolean,
    iconFirstPage: String,
    iconPrevPage: String,
    iconNextPage: String,
    iconLastPage: String,
    title: String,
    hideHeader: Boolean,
    grid: Boolean,
    gridHeader: Boolean,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: (e) => ["horizontal", "vertical", "cell", "none"].includes(e)
    },
    wrapCells: Boolean,
    virtualScroll: Boolean,
    virtualScrollTarget: {},
    ...Zr,
    noDataLabel: String,
    noResultsLabel: String,
    loadingLabel: String,
    selectedRowsLabel: Function,
    rowsPerPageLabel: String,
    paginationLabel: Function,
    color: {
      type: String,
      default: "grey-8"
    },
    titleClass: [String, Array, Object],
    tableStyle: [String, Array, Object],
    tableClass: [String, Array, Object],
    tableHeaderStyle: [String, Array, Object],
    tableHeaderClass: [String, Array, Object],
    cardContainerClass: [String, Array, Object],
    cardContainerStyle: [String, Array, Object],
    cardStyle: [String, Array, Object],
    cardClass: [String, Array, Object],
    hideBottom: Boolean,
    hideSelectedBanner: Boolean,
    hideNoData: Boolean,
    hidePagination: Boolean,
    onRowClick: Function,
    onRowDblclick: Function,
    onRowContextmenu: Function,
    ...rt,
    ...Ws,
    ...fc,
    ...ec,
    ...lc,
    ...sc,
    ...rc,
    ...Zs
  },
  emits: [
    "request",
    "virtualScroll",
    ...Qs,
    ...cc,
    ...ic
  ],
  setup(e, { slots: t, emit: n }) {
    const l = we(), { proxy: { $q: a } } = l, o = it(e, a), { inFullscreen: r, toggleFullscreen: i } = Xs(), c = d(() => typeof e.rowKey == "function" ? e.rowKey : (B) => B[e.rowKey]), s = J(null), u = J(null), f = d(() => e.grid !== !0 && e.virtualScroll === !0), S = d(
      () => " q-table__card" + (o.value === !0 ? " q-table__card--dark q-dark" : "") + (e.square === !0 ? " q-table--square" : "") + (e.flat === !0 ? " q-table--flat" : "") + (e.bordered === !0 ? " q-table--bordered" : "")
    ), b = d(
      () => `q-table__container q-table--${e.separator}-separator column no-wrap` + (e.grid === !0 ? " q-table--grid" : S.value) + (o.value === !0 ? " q-table--dark" : "") + (e.dense === !0 ? " q-table--dense" : "") + (e.wrapCells === !1 ? " q-table--no-wrap" : "") + (r.value === !0 ? " fullscreen scroll" : "")
    ), h = d(
      () => b.value + (e.loading === !0 ? " q-table--loading" : "")
    );
    ce(
      () => e.tableStyle + e.tableClass + e.tableHeaderStyle + e.tableHeaderClass + b.value,
      () => {
        f.value === !0 && u.value !== null && u.value.reset();
      }
    );
    const {
      innerPagination: x,
      computedPagination: g,
      isServerSide: T,
      requestServerInteraction: P,
      setPagination: _
    } = ac(l, V), { computedFilterMethod: y } = tc(e, _), { isRowExpanded: p, setExpanded: F, updateExpanded: A } = dc(e, n), U = d(() => {
      let B = e.rows;
      if (T.value === !0 || B.length === 0)
        return B;
      const { sortBy: ee, descending: re } = g.value;
      return e.filter && (B = y.value(B, e.filter, q.value, V)), ie.value !== null && (B = me.value(
        e.rows === B ? B.slice() : B,
        ee,
        re
      )), B;
    }), D = d(() => U.value.length), L = d(() => {
      let B = U.value;
      if (T.value === !0)
        return B;
      const { rowsPerPage: ee } = g.value;
      return ee !== 0 && (X.value === 0 && e.rows !== B ? B.length > ge.value && (B = B.slice(0, ge.value)) : B = B.slice(X.value, ge.value)), B;
    }), {
      hasSelectionMode: H,
      singleSelection: E,
      multipleSelection: $,
      allRowsSelected: M,
      someRowsSelected: K,
      rowsSelectedNumber: Q,
      isRowSelected: te,
      clearSelection: N,
      updateSelection: Z
    } = uc(e, n, L, c), { colList: de, computedCols: q, computedColsMap: C, computedColspan: G } = mc(e, g, H), { columnToSort: ie, computedSortMethod: me, sort: j } = Gs(e, g, de, _), {
      firstRowIndex: X,
      lastRowIndex: ge,
      isFirstPage: z,
      isLastPage: qe,
      pagesNumber: pe,
      computedRowsPerPageOptions: Re,
      computedRowsNumber: je,
      firstPage: ut,
      prevPage: nt,
      nextPage: Qe,
      lastPage: $e
    } = oc(l, x, g, T, _, D), Ct = d(() => L.value.length === 0), Dt = d(() => {
      const B = {};
      return Hr.forEach((ee) => {
        B[ee] = e[ee];
      }), B.virtualScrollItemSize === void 0 && (B.virtualScrollItemSize = e.dense === !0 ? 28 : 48), B;
    });
    function dt() {
      f.value === !0 && u.value.reset();
    }
    function Ue() {
      if (e.grid === !0)
        return Jt();
      const B = e.hideHeader !== !0 ? Ee : null;
      if (f.value === !0) {
        const re = t["top-row"], se = t["bottom-row"], be = {
          default: (Ve) => Lt(Ve.item, t.body, Ve.index)
        };
        if (re !== void 0) {
          const Ve = v("tbody", re({ cols: q.value }));
          be.before = B === null ? () => Ve : () => [B()].concat(Ve);
        } else B !== null && (be.before = B);
        return se !== void 0 && (be.after = () => v("tbody", se({ cols: q.value }))), v(Rs, {
          ref: u,
          class: e.tableClass,
          style: e.tableStyle,
          ...Dt.value,
          scrollTarget: e.virtualScrollTarget,
          items: L.value,
          type: "__qtable",
          tableColspan: G.value,
          onVirtualScroll: ht
        }, be);
      }
      const ee = [
        kt()
      ];
      return B !== null && ee.unshift(B()), Lr({
        class: ["q-table__middle scroll", e.tableClass],
        style: e.tableStyle
      }, ee);
    }
    function He(B, ee) {
      if (u.value !== null) {
        u.value.scrollTo(B, ee);
        return;
      }
      B = parseInt(B, 10);
      const re = s.value.querySelector(`tbody tr:nth-of-type(${B + 1})`);
      if (re !== null) {
        const se = s.value.querySelector(".q-table__middle.scroll"), be = re.offsetTop - e.virtualScrollStickySizeStart, Ve = be < se.scrollTop ? "decrease" : "increase";
        se.scrollTop = be, n("virtualScroll", {
          index: B,
          from: 0,
          to: x.value.rowsPerPage - 1,
          direction: Ve
        });
      }
    }
    function ht(B) {
      n("virtualScroll", B);
    }
    function wt() {
      return [
        v(Ys, {
          class: "q-table__linear-progress",
          color: e.color,
          dark: o.value,
          indeterminate: !0,
          trackColor: "transparent"
        })
      ];
    }
    function Lt(B, ee, re) {
      const se = c.value(B), be = te(se);
      if (ee !== void 0)
        return ee(
          ft({
            key: se,
            row: B,
            pageIndex: re,
            __trClass: be ? "selected" : ""
          })
        );
      const Ve = t["body-cell"], m = q.value.map((R) => {
        const Y = t[`body-cell-${R.name}`], W = Y !== void 0 ? Y : Ve;
        return W !== void 0 ? W(Tt({ key: se, row: B, pageIndex: re, col: R })) : v("td", {
          class: R.__tdClass(B),
          style: R.__tdStyle(B)
        }, V(R, B));
      });
      if (H.value === !0) {
        const R = t["body-selection"], Y = R !== void 0 ? R(Pt({ key: se, row: B, pageIndex: re })) : [
          v(Fn, {
            modelValue: be,
            color: e.color,
            dark: o.value,
            dense: e.dense,
            "onUpdate:modelValue": (W, Se) => {
              Z([se], [B], W, Se);
            }
          })
        ];
        m.unshift(
          v("td", { class: "q-table--col-auto-width" }, Y)
        );
      }
      const k = { key: se, class: { selected: be } };
      return e.onRowClick !== void 0 && (k.class["cursor-pointer"] = !0, k.onClick = (R) => {
        n("rowClick", R, B, re);
      }), e.onRowDblclick !== void 0 && (k.class["cursor-pointer"] = !0, k.onDblclick = (R) => {
        n("rowDblclick", R, B, re);
      }), e.onRowContextmenu !== void 0 && (k.class["cursor-pointer"] = !0, k.onContextmenu = (R) => {
        n("rowContextmenu", R, B, re);
      }), v("tr", k, m);
    }
    function kt() {
      const B = t.body, ee = t["top-row"], re = t["bottom-row"];
      let se = L.value.map(
        (be, Ve) => Lt(be, B, Ve)
      );
      return ee !== void 0 && (se = ee({ cols: q.value }).concat(se)), re !== void 0 && (se = se.concat(re({ cols: q.value }))), v("tbody", se);
    }
    function ft(B) {
      return lt(B), B.cols = B.cols.map(
        (ee) => _t({ ...ee }, "value", () => V(ee, B.row))
      ), B;
    }
    function Tt(B) {
      return lt(B), _t(B, "value", () => V(B.col, B.row)), B;
    }
    function Pt(B) {
      return lt(B), B;
    }
    function lt(B) {
      Object.assign(B, {
        cols: q.value,
        colsMap: C.value,
        sort: j,
        rowIndex: X.value + B.pageIndex,
        color: e.color,
        dark: o.value,
        dense: e.dense
      }), H.value === !0 && _t(
        B,
        "selected",
        () => te(B.key),
        (ee, re) => {
          Z([B.key], [B.row], ee, re);
        }
      ), _t(
        B,
        "expand",
        () => p(B.key),
        (ee) => {
          A(B.key, ee);
        }
      );
    }
    function V(B, ee) {
      const re = typeof B.field == "function" ? B.field(ee) : ee[B.field];
      return B.format !== void 0 ? B.format(re, ee) : re;
    }
    const I = d(() => ({
      pagination: g.value,
      pagesNumber: pe.value,
      isFirstPage: z.value,
      isLastPage: qe.value,
      firstPage: ut,
      prevPage: nt,
      nextPage: Qe,
      lastPage: $e,
      inFullscreen: r.value,
      toggleFullscreen: i
    }));
    function oe() {
      const B = t.top, ee = t["top-left"], re = t["top-right"], se = t["top-selection"], be = H.value === !0 && se !== void 0 && Q.value > 0, Ve = "q-table__top relative-position row items-center";
      if (B !== void 0)
        return v("div", { class: Ve }, [B(I.value)]);
      let m;
      if (be === !0 ? m = se(I.value).slice() : (m = [], ee !== void 0 ? m.push(
        v("div", { class: "q-table__control" }, [
          ee(I.value)
        ])
      ) : e.title && m.push(
        v("div", { class: "q-table__control" }, [
          v("div", {
            class: ["q-table__title", e.titleClass]
          }, e.title)
        ])
      )), re !== void 0 && (m.push(
        v("div", { class: "q-table__separator col" })
      ), m.push(
        v("div", { class: "q-table__control" }, [
          re(I.value)
        ])
      )), m.length !== 0)
        return v("div", { class: Ve }, m);
    }
    const he = d(() => K.value === !0 ? null : M.value);
    function Ee() {
      const B = Xe();
      return e.loading === !0 && t.loading === void 0 && B.push(
        v("tr", { class: "q-table__progress" }, [
          v("th", {
            class: "relative-position",
            colspan: G.value
          }, wt())
        ])
      ), v("thead", B);
    }
    function Xe() {
      const B = t.header, ee = t["header-cell"];
      if (B !== void 0)
        return B(
          ue({ header: !0 })
        ).slice();
      const re = q.value.map((se) => {
        const be = t[`header-cell-${se.name}`], Ve = be !== void 0 ? be : ee, m = ue({ col: se });
        return Ve !== void 0 ? Ve(m) : v(Ss, {
          key: se.name,
          props: m
        }, () => se.label);
      });
      if (E.value === !0 && e.grid !== !0)
        re.unshift(
          v("th", { class: "q-table--col-auto-width" }, " ")
        );
      else if ($.value === !0) {
        const se = t["header-selection"], be = se !== void 0 ? se(ue({})) : [
          v(Fn, {
            color: e.color,
            modelValue: he.value,
            dark: o.value,
            dense: e.dense,
            "onUpdate:modelValue": Pe
          })
        ];
        re.unshift(
          v("th", { class: "q-table--col-auto-width" }, be)
        );
      }
      return [
        v("tr", {
          class: e.tableHeaderClass,
          style: e.tableHeaderStyle
        }, re)
      ];
    }
    function ue(B) {
      return Object.assign(B, {
        cols: q.value,
        sort: j,
        colsMap: C.value,
        color: e.color,
        dark: o.value,
        dense: e.dense
      }), $.value === !0 && _t(
        B,
        "selected",
        () => he.value,
        Pe
      ), B;
    }
    function Pe(B) {
      K.value === !0 && (B = !1), Z(
        L.value.map(c.value),
        L.value,
        B
      );
    }
    const Je = d(() => {
      const B = [
        e.iconFirstPage || a.iconSet.table.firstPage,
        e.iconPrevPage || a.iconSet.table.prevPage,
        e.iconNextPage || a.iconSet.table.nextPage,
        e.iconLastPage || a.iconSet.table.lastPage
      ];
      return a.lang.rtl === !0 ? B.reverse() : B;
    });
    function qt() {
      if (e.hideBottom === !0) return;
      if (Ct.value === !0) {
        if (e.hideNoData === !0) return;
        const re = e.loading === !0 ? e.loadingLabel || a.lang.table.loading : e.filter ? e.noResultsLabel || a.lang.table.noResults : e.noDataLabel || a.lang.table.noData, se = t["no-data"], be = se !== void 0 ? [se({ message: re, icon: a.iconSet.table.warning, filter: e.filter })] : [
          v(pt, {
            class: "q-table__bottom-nodata-icon",
            name: a.iconSet.table.warning
          }),
          re
        ];
        return v("div", { class: tl + " q-table__bottom--nodata" }, be);
      }
      const B = t.bottom;
      if (B !== void 0)
        return v("div", { class: tl }, [B(I.value)]);
      const ee = e.hideSelectedBanner !== !0 && H.value === !0 && Q.value > 0 ? [
        v("div", { class: "q-table__control" }, [
          v("div", [
            (e.selectedRowsLabel || a.lang.table.selectedRecords)(Q.value)
          ])
        ])
      ] : [];
      if (e.hidePagination !== !0)
        return v("div", {
          class: tl + " justify-end"
        }, Ot(ee));
      if (ee.length !== 0)
        return v("div", { class: tl }, ee);
    }
    function Nt(B) {
      _({
        page: 1,
        rowsPerPage: B.value
      });
    }
    function Ot(B) {
      let ee;
      const { rowsPerPage: re } = g.value, se = e.paginationLabel || a.lang.table.pagination, be = t.pagination, Ve = e.rowsPerPageOptions.length > 1;
      if (B.push(
        v("div", { class: "q-table__separator col" })
      ), Ve === !0 && B.push(
        v("div", { class: "q-table__control" }, [
          v("span", { class: "q-table__bottom-item" }, [
            e.rowsPerPageLabel || a.lang.table.recordsPerPage
          ]),
          v(hl, {
            class: "q-table__select inline q-table__bottom-item",
            color: e.color,
            modelValue: re,
            options: Re.value,
            displayValue: re === 0 ? a.lang.table.allRows : re,
            dark: o.value,
            borderless: !0,
            dense: !0,
            optionsDense: !0,
            optionsCover: !0,
            "onUpdate:modelValue": Nt
          })
        ])
      ), be !== void 0)
        ee = be(I.value);
      else if (ee = [
        v("span", re !== 0 ? { class: "q-table__bottom-item" } : {}, [
          re ? se(X.value + 1, Math.min(ge.value, je.value), je.value) : se(1, D.value, je.value)
        ])
      ], re !== 0 && pe.value > 1) {
        const m = {
          color: e.color,
          round: !0,
          dense: !0,
          flat: !0
        };
        e.dense === !0 && (m.size = "sm"), pe.value > 2 && ee.push(
          v(Te, {
            key: "pgFirst",
            ...m,
            icon: Je.value[0],
            disable: z.value,
            onClick: ut
          })
        ), ee.push(
          v(Te, {
            key: "pgPrev",
            ...m,
            icon: Je.value[1],
            disable: z.value,
            onClick: nt
          }),
          v(Te, {
            key: "pgNext",
            ...m,
            icon: Je.value[2],
            disable: qe.value,
            onClick: Qe
          })
        ), pe.value > 2 && ee.push(
          v(Te, {
            key: "pgLast",
            ...m,
            icon: Je.value[3],
            disable: qe.value,
            onClick: $e
          })
        );
      }
      return B.push(
        v("div", { class: "q-table__control" }, ee)
      ), B;
    }
    function zt() {
      const B = e.gridHeader === !0 ? [
        v("table", { class: "q-table" }, [
          Ee()
        ])
      ] : e.loading === !0 && t.loading === void 0 ? wt() : void 0;
      return v("div", { class: "q-table__middle" }, B);
    }
    function Jt() {
      const B = t.item !== void 0 ? t.item : (ee) => {
        const re = ee.cols.map(
          (be) => v("div", { class: "q-table__grid-item-row" }, [
            v("div", { class: "q-table__grid-item-title" }, [be.label]),
            v("div", { class: "q-table__grid-item-value" }, [be.value])
          ])
        );
        if (H.value === !0) {
          const be = t["body-selection"], Ve = be !== void 0 ? be(ee) : [
            v(Fn, {
              modelValue: ee.selected,
              color: e.color,
              dark: o.value,
              dense: e.dense,
              "onUpdate:modelValue": (m, k) => {
                Z([ee.key], [ee.row], m, k);
              }
            })
          ];
          re.unshift(
            v("div", { class: "q-table__grid-item-row" }, Ve),
            v(ka, { dark: o.value })
          );
        }
        const se = {
          class: [
            "q-table__grid-item-card" + S.value,
            e.cardClass
          ],
          style: e.cardStyle
        };
        return (e.onRowClick !== void 0 || e.onRowDblclick !== void 0) && (se.class[0] += " cursor-pointer", e.onRowClick !== void 0 && (se.onClick = (be) => {
          n("RowClick", be, ee.row, ee.pageIndex);
        }), e.onRowDblclick !== void 0 && (se.onDblclick = (be) => {
          n("RowDblclick", be, ee.row, ee.pageIndex);
        })), v("div", {
          class: "q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3" + (ee.selected === !0 ? " q-table__grid-item--selected" : "")
        }, [
          v("div", se, re)
        ]);
      };
      return v("div", {
        class: [
          "q-table__grid-content row",
          e.cardContainerClass
        ],
        style: e.cardContainerStyle
      }, L.value.map((ee, re) => B(ft({
        key: c.value(ee),
        row: ee,
        pageIndex: re
      }))));
    }
    return Object.assign(l.proxy, {
      requestServerInteraction: P,
      setPagination: _,
      firstPage: ut,
      prevPage: nt,
      nextPage: Qe,
      lastPage: $e,
      isRowSelected: te,
      clearSelection: N,
      isRowExpanded: p,
      setExpanded: F,
      sort: j,
      resetVirtualScroll: dt,
      scrollTo: He,
      getCellValue: V
    }), Ii(l.proxy, {
      filteredSortedRows: () => U.value,
      computedRows: () => L.value,
      computedRowsNumber: () => je.value
    }), () => {
      const B = [oe()], ee = { ref: s, class: h.value };
      return e.grid === !0 ? B.push(zt()) : Object.assign(ee, {
        class: [ee.class, e.cardClass],
        style: e.cardStyle
      }), B.push(
        Ue(),
        qt()
      ), e.loading === !0 && t.loading !== void 0 && B.push(
        t.loading()
      ), v("div", ee, B);
    };
  }
});
function hc() {
  let e = /* @__PURE__ */ Object.create(null);
  return {
    getCache: (t, n) => e[t] === void 0 ? e[t] = typeof n == "function" ? n() : n : e[t],
    setCache(t, n) {
      e[t] = n;
    },
    hasCache(t) {
      return Object.hasOwnProperty.call(e, t);
    },
    clearCache(t) {
      t !== void 0 ? delete e[t] : e = /* @__PURE__ */ Object.create(null);
    }
  };
}
const Xt = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178
];
function gc(e, t, n) {
  return Object.prototype.toString.call(e) === "[object Date]" && (n = e.getDate(), t = e.getMonth() + 1, e = e.getFullYear()), Sc(Ea(e, t, n));
}
function Co(e, t, n) {
  return ei(pc(e, t, n));
}
function bc(e) {
  return yc(e) === 0;
}
function ol(e, t) {
  return t <= 6 ? 31 : t <= 11 || bc(e) ? 30 : 29;
}
function yc(e) {
  const t = Xt.length;
  let n = Xt[0], l, a, o, r, i;
  if (e < n || e >= Xt[t - 1])
    throw new Error("Invalid Jalaali year " + e);
  for (i = 1; i < t && (l = Xt[i], a = l - n, !(e < l)); i += 1)
    n = l;
  return r = e - n, a - r < 6 && (r = r - a + Ae(a + 4, 33) * 33), o = yt(yt(r + 1, 33) - 1, 4), o === -1 && (o = 4), o;
}
function Gr(e, t) {
  const n = Xt.length, l = e + 621;
  let a = -14, o = Xt[0], r, i, c, s, u;
  if (e < o || e >= Xt[n - 1])
    throw new Error("Invalid Jalaali year " + e);
  for (u = 1; u < n && (r = Xt[u], i = r - o, !(e < r)); u += 1)
    a = a + Ae(i, 33) * 8 + Ae(yt(i, 33), 4), o = r;
  s = e - o, a = a + Ae(s, 33) * 8 + Ae(yt(s, 33) + 3, 4), yt(i, 33) === 4 && i - s === 4 && (a += 1);
  const f = Ae(l, 4) - Ae((Ae(l, 100) + 1) * 3, 4) - 150, S = 20 + a - f;
  return t || (i - s < 6 && (s = s - i + Ae(i + 4, 33) * 33), c = yt(yt(s + 1, 33) - 1, 4), c === -1 && (c = 4)), {
    leap: c,
    gy: l,
    march: S
  };
}
function pc(e, t, n) {
  const l = Gr(e, !0);
  return Ea(l.gy, 3, l.march) + (t - 1) * 31 - Ae(t, 7) * (t - 7) + n - 1;
}
function Sc(e) {
  const t = ei(e).gy;
  let n = t - 621, l, a, o;
  const r = Gr(n, !1), i = Ea(t, 3, r.march);
  if (o = e - i, o >= 0) {
    if (o <= 185)
      return a = 1 + Ae(o, 31), l = yt(o, 31) + 1, {
        jy: n,
        jm: a,
        jd: l
      };
    o -= 186;
  } else
    n -= 1, o += 179, r.leap === 1 && (o += 1);
  return a = 7 + Ae(o, 30), l = yt(o, 30) + 1, {
    jy: n,
    jm: a,
    jd: l
  };
}
function Ea(e, t, n) {
  let l = Ae((e + Ae(t - 8, 6) + 100100) * 1461, 4) + Ae(153 * yt(t + 9, 12) + 2, 5) + n - 34840408;
  return l = l - Ae(Ae(e + 100100 + Ae(t - 8, 6), 100) * 3, 4) + 752, l;
}
function ei(e) {
  let t = 4 * e + 139361631;
  t = t + Ae(Ae(4 * e + 183187720, 146097) * 3, 4) * 4 - 3908;
  const n = Ae(yt(t, 1461), 4) * 5 + 308, l = Ae(yt(n, 153), 5) + 1, a = yt(Ae(n, 153), 12) + 1;
  return {
    gy: Ae(t, 1461) - 100100 + Ae(8 - a, 6),
    gm: a,
    gd: l
  };
}
function Ae(e, t) {
  return ~~(e / t);
}
function yt(e, t) {
  return e - ~~(e / t) * t;
}
const wc = ["gregorian", "persian"], gl = {
  // should define modelValue in the target component
  mask: {
    type: String
  },
  locale: Object,
  calendar: {
    type: String,
    validator: (e) => wc.includes(e),
    default: "gregorian"
  },
  landscape: Boolean,
  color: String,
  textColor: String,
  square: Boolean,
  flat: Boolean,
  bordered: Boolean,
  readonly: Boolean,
  disable: Boolean
}, ti = ["update:modelValue"];
function $t(e) {
  return e.year + "/" + xe(e.month) + "/" + xe(e.day);
}
function ni(e, t) {
  const n = d(() => e.disable !== !0 && e.readonly !== !0), l = d(() => n.value === !0 ? 0 : -1), a = d(() => {
    const i = [];
    return e.color !== void 0 && i.push(`bg-${e.color}`), e.textColor !== void 0 && i.push(`text-${e.textColor}`), i.join(" ");
  });
  function o() {
    return e.locale !== void 0 ? { ...t.lang.date, ...e.locale } : t.lang.date;
  }
  function r(i) {
    const c = /* @__PURE__ */ new Date(), s = i === !0 ? null : 0;
    if (e.calendar === "persian") {
      const u = gc(c);
      return {
        year: u.jy,
        month: u.jm,
        day: u.jd
      };
    }
    return {
      year: c.getFullYear(),
      month: c.getMonth() + 1,
      day: c.getDate(),
      hour: s,
      minute: s,
      second: s,
      millisecond: s
    };
  }
  return {
    editable: n,
    tabindex: l,
    headerClass: a,
    getLocale: o,
    getCurrentDate: r
  };
}
const da = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (e) => e ? `Expand "${e}"` : "Expand",
    collapse: (e) => e ? `Collapse "${e}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: !1,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (e) => e === 1 ? "1 record selected." : (e === 0 ? "No" : e) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (e, t, n) => e + "-" + t + " of " + n,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function qo() {
  const e = Array.isArray(navigator.languages) === !0 && navigator.languages.length !== 0 ? navigator.languages[0] : navigator.language;
  if (typeof e == "string")
    return e.split(/[-_]/).map((t, n) => n === 0 ? t.toLowerCase() : n > 1 || t.length < 4 ? t.toUpperCase() : t[0].toUpperCase() + t.slice(1).toLowerCase()).join("-");
}
const Kt = ji({
  __qLang: {}
}, {
  // props: object
  // __langConfig: object
  getLocale: qo,
  set(e = da, t) {
    const n = {
      ...e,
      rtl: e.rtl === !0,
      getLocale: qo
    };
    {
      if (n.set = Kt.set, Kt.__langConfig === void 0 || Kt.__langConfig.noHtmlAttrs !== !0) {
        const l = document.documentElement;
        l.setAttribute("dir", n.rtl === !0 ? "rtl" : "ltr"), l.setAttribute("lang", n.isoName);
      }
      Object.assign(Kt.__qLang, n);
    }
  },
  install({ $q: e, lang: t, ssrContext: n }) {
    e.lang = Kt.__qLang, Kt.__langConfig = e.config.lang, this.__installed === !0 ? t !== void 0 && this.set(t) : (this.props = new Proxy(this.__qLang, {
      get() {
        return Reflect.get(...arguments);
      },
      ownKeys(l) {
        return Reflect.ownKeys(l).filter((a) => a !== "set" && a !== "getLocale");
      }
    }), this.set(t || da));
  }
}), li = 864e5, kc = 36e5, fa = 6e4, ai = "YYYY-MM-DDTHH:mm:ss.SSSZ", xc = /\[((?:[^\]\\]|\\]|\\)*)\]|do|d{1,4}|Mo|M{1,4}|m{1,2}|wo|w{1,2}|Qo|Do|DDDo|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g, _c = /(\[[^\]]*\])|do|d{1,4}|Mo|M{1,4}|m{1,2}|wo|w{1,2}|Qo|Do|DDDo|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g, zl = {};
function Cc(e, t) {
  const n = "(" + t.days.join("|") + ")", l = e + n;
  if (zl[l] !== void 0)
    return zl[l];
  const a = "(" + t.daysShort.join("|") + ")", o = "(" + t.months.join("|") + ")", r = "(" + t.monthsShort.join("|") + ")", i = {};
  let c = 0;
  const s = e.replace(_c, (f) => {
    switch (c++, f) {
      case "YY":
        return i.YY = c, "(-?\\d{1,2})";
      case "YYYY":
        return i.YYYY = c, "(-?\\d{1,4})";
      case "M":
        return i.M = c, "(\\d{1,2})";
      case "Mo":
        return i.M = c++, "(\\d{1,2}(st|nd|rd|th))";
      case "MM":
        return i.M = c, "(\\d{2})";
      case "MMM":
        return i.MMM = c, r;
      case "MMMM":
        return i.MMMM = c, o;
      case "D":
        return i.D = c, "(\\d{1,2})";
      case "Do":
        return i.D = c++, "(\\d{1,2}(st|nd|rd|th))";
      case "DD":
        return i.D = c, "(\\d{2})";
      case "H":
        return i.H = c, "(\\d{1,2})";
      case "HH":
        return i.H = c, "(\\d{2})";
      case "h":
        return i.h = c, "(\\d{1,2})";
      case "hh":
        return i.h = c, "(\\d{2})";
      case "m":
        return i.m = c, "(\\d{1,2})";
      case "mm":
        return i.m = c, "(\\d{2})";
      case "s":
        return i.s = c, "(\\d{1,2})";
      case "ss":
        return i.s = c, "(\\d{2})";
      case "S":
        return i.S = c, "(\\d{1})";
      case "SS":
        return i.S = c, "(\\d{2})";
      case "SSS":
        return i.S = c, "(\\d{3})";
      case "A":
        return i.A = c, "(AM|PM)";
      case "a":
        return i.a = c, "(am|pm)";
      case "aa":
        return i.aa = c, "(a\\.m\\.|p\\.m\\.)";
      case "ddd":
        return a;
      case "dddd":
        return n;
      case "Q":
      case "d":
      case "E":
        return "(\\d{1})";
      case "do":
        return c++, "(\\d{1}(st|nd|rd|th))";
      case "Qo":
        return "(1st|2nd|3rd|4th)";
      case "DDD":
      case "DDDD":
        return "(\\d{1,3})";
      case "DDDo":
        return c++, "(\\d{1,3}(st|nd|rd|th))";
      case "w":
        return "(\\d{1,2})";
      case "wo":
        return c++, "(\\d{1,2}(st|nd|rd|th))";
      case "ww":
        return "(\\d{2})";
      case "Z":
        return i.Z = c, "(Z|[+-]\\d{2}:\\d{2})";
      case "ZZ":
        return i.ZZ = c, "(Z|[+-]\\d{2}\\d{2})";
      case "X":
        return i.X = c, "(-?\\d+)";
      case "x":
        return i.x = c, "(-?\\d{4,})";
      default:
        return c--, f[0] === "[" && (f = f.substring(1, f.length - 1)), f.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  }), u = { map: i, regex: new RegExp("^" + s) };
  return zl[l] = u, u;
}
function oi(e, t) {
  return e !== void 0 ? e : t !== void 0 ? t.date : da.date;
}
function Eo(e, t = "") {
  const n = e > 0 ? "-" : "+", l = Math.abs(e), a = Math.floor(l / 60), o = l % 60;
  return n + xe(a) + t + xe(o);
}
function An(e, t, n, l, a) {
  const o = {
    year: null,
    month: null,
    day: null,
    hour: null,
    minute: null,
    second: null,
    millisecond: null,
    timezoneOffset: null,
    dateHash: null,
    timeHash: null
  };
  if (a !== void 0 && Object.assign(o, a), e == null || e === "" || typeof e != "string")
    return o;
  t === void 0 && (t = ai);
  const r = oi(n, Kt.props), i = r.months, c = r.monthsShort, { regex: s, map: u } = Cc(t, r), f = e.match(s);
  if (f === null)
    return o;
  let S = "";
  if (u.X !== void 0 || u.x !== void 0) {
    const b = parseInt(f[u.X !== void 0 ? u.X : u.x], 10);
    if (isNaN(b) === !0 || b < 0)
      return o;
    const h = new Date(b * (u.X !== void 0 ? 1e3 : 1));
    o.year = h.getFullYear(), o.month = h.getMonth() + 1, o.day = h.getDate(), o.hour = h.getHours(), o.minute = h.getMinutes(), o.second = h.getSeconds(), o.millisecond = h.getMilliseconds();
  } else {
    if (u.YYYY !== void 0)
      o.year = parseInt(f[u.YYYY], 10);
    else if (u.YY !== void 0) {
      const b = parseInt(f[u.YY], 10);
      o.year = b < 0 ? b : 2e3 + b;
    }
    if (u.M !== void 0) {
      if (o.month = parseInt(f[u.M], 10), o.month < 1 || o.month > 12)
        return o;
    } else u.MMM !== void 0 ? o.month = c.indexOf(f[u.MMM]) + 1 : u.MMMM !== void 0 && (o.month = i.indexOf(f[u.MMMM]) + 1);
    if (u.D !== void 0) {
      if (o.day = parseInt(f[u.D], 10), o.year === null || o.month === null || o.day < 1)
        return o;
      const b = l !== "persian" ? new Date(o.year, o.month, 0).getDate() : ol(o.year, o.month);
      if (o.day > b)
        return o;
    }
    u.H !== void 0 ? o.hour = parseInt(f[u.H], 10) % 24 : u.h !== void 0 && (o.hour = parseInt(f[u.h], 10) % 12, (u.A && f[u.A] === "PM" || u.a && f[u.a] === "pm" || u.aa && f[u.aa] === "p.m.") && (o.hour += 12), o.hour = o.hour % 24), u.m !== void 0 && (o.minute = parseInt(f[u.m], 10) % 60), u.s !== void 0 && (o.second = parseInt(f[u.s], 10) % 60), u.S !== void 0 && (o.millisecond = parseInt(f[u.S], 10) * 10 ** (3 - f[u.S].length)), (u.Z !== void 0 || u.ZZ !== void 0) && (S = u.Z !== void 0 ? f[u.Z].replace(":", "") : f[u.ZZ], o.timezoneOffset = (S[0] === "+" ? -1 : 1) * (60 * S.slice(1, 3) + 1 * S.slice(3, 5)));
  }
  return o.dateHash = xe(o.year, 6) + "/" + xe(o.month) + "/" + xe(o.day), o.timeHash = xe(o.hour) + ":" + xe(o.minute) + ":" + xe(o.second) + S, o;
}
function Ul(e) {
  const t = new Date(e.getFullYear(), e.getMonth(), e.getDate());
  t.setDate(t.getDate() - (t.getDay() + 6) % 7 + 3);
  const n = new Date(t.getFullYear(), 0, 4);
  n.setDate(n.getDate() - (n.getDay() + 6) % 7 + 3);
  const l = t.getTimezoneOffset() - n.getTimezoneOffset();
  t.setHours(t.getHours() - l);
  const a = (t - n) / (li * 7);
  return 1 + Math.floor(a);
}
function Ht(e, t, n) {
  const l = new Date(e), a = `set${n === !0 ? "UTC" : ""}`;
  switch (t) {
    case "year":
    case "years":
      l[`${a}Month`](0);
    case "month":
    case "months":
      l[`${a}Date`](1);
    case "day":
    case "days":
    case "date":
      l[`${a}Hours`](0);
    case "hour":
    case "hours":
      l[`${a}Minutes`](0);
    case "minute":
    case "minutes":
      l[`${a}Seconds`](0);
    case "second":
    case "seconds":
      l[`${a}Milliseconds`](0);
  }
  return l;
}
function nl(e, t, n) {
  return (e.getTime() - e.getTimezoneOffset() * fa - (t.getTime() - t.getTimezoneOffset() * fa)) / n;
}
function ri(e, t, n = "days") {
  const l = new Date(e), a = new Date(t);
  switch (n) {
    case "years":
    case "year":
      return l.getFullYear() - a.getFullYear();
    case "months":
    case "month":
      return (l.getFullYear() - a.getFullYear()) * 12 + l.getMonth() - a.getMonth();
    case "days":
    case "day":
    case "date":
      return nl(Ht(l, "day"), Ht(a, "day"), li);
    case "hours":
    case "hour":
      return nl(Ht(l, "hour"), Ht(a, "hour"), kc);
    case "minutes":
    case "minute":
      return nl(Ht(l, "minute"), Ht(a, "minute"), fa);
    case "seconds":
    case "second":
      return nl(Ht(l, "second"), Ht(a, "second"), 1e3);
  }
}
function Yl(e) {
  return ri(e, Ht(e, "year"), "days") + 1;
}
function hn(e) {
  if (e >= 11 && e <= 13)
    return `${e}th`;
  switch (e % 10) {
    case 1:
      return `${e}st`;
    case 2:
      return `${e}nd`;
    case 3:
      return `${e}rd`;
  }
  return `${e}th`;
}
const Mo = {
  // Year: 00, 01, ..., 99
  YY(e, t, n) {
    const l = this.YYYY(e, t, n) % 100;
    return l >= 0 ? xe(l) : "-" + xe(Math.abs(l));
  },
  // Year: 1900, 1901, ..., 2099
  YYYY(e, t, n) {
    return n ?? e.getFullYear();
  },
  // Month: 1, 2, ..., 12
  M(e) {
    return e.getMonth() + 1;
  },
  // Month: 1st, 2nd, ..., 12th
  Mo(e) {
    return hn(e.getMonth() + 1);
  },
  // Month: 01, 02, ..., 12
  MM(e) {
    return xe(e.getMonth() + 1);
  },
  // Month Short Name: Jan, Feb, ...
  MMM(e, t) {
    return t.monthsShort[e.getMonth()];
  },
  // Month Name: January, February, ...
  MMMM(e, t) {
    return t.months[e.getMonth()];
  },
  // Quarter: 1, 2, 3, 4
  Q(e) {
    return Math.ceil((e.getMonth() + 1) / 3);
  },
  // Quarter: 1st, 2nd, 3rd, 4th
  Qo(e) {
    return hn(this.Q(e));
  },
  // Day of month: 1, 2, ..., 31
  D(e) {
    return e.getDate();
  },
  // Day of month: 1st, 2nd, ..., 31st
  Do(e) {
    return hn(e.getDate());
  },
  // Day of month: 01, 02, ..., 31
  DD(e) {
    return xe(e.getDate());
  },
  // Day of year: 1, 2, ..., 366
  DDD(e) {
    return Yl(e);
  },
  // Day of year: 1st, 2nd, ..., 366th
  DDDo(e) {
    return hn(Yl(e));
  },
  // Day of year: 001, 002, ..., 366
  DDDD(e) {
    return xe(Yl(e), 3);
  },
  // Day of week: 0, 1, ..., 6
  d(e) {
    return e.getDay();
  },
  // Day of week: 0th, 1st, ..., 6th
  do(e) {
    return hn(e.getDay());
  },
  // Day of week: Su, Mo, ...
  dd(e, t) {
    return t.days[e.getDay()].slice(0, 2);
  },
  // Day of week: Sun, Mon, ...
  ddd(e, t) {
    return t.daysShort[e.getDay()];
  },
  // Day of week: Sunday, Monday, ...
  dddd(e, t) {
    return t.days[e.getDay()];
  },
  // Day of ISO week: 1, 2, ..., 7
  E(e) {
    return e.getDay() || 7;
  },
  // Week of Year: 1 2 ... 52 53
  w(e) {
    return Ul(e);
  },
  // Week of Year: 1st 2nd ... 52nd 53rd
  wo(e) {
    return hn(Ul(e));
  },
  // Week of Year: 01 02 ... 52 53
  ww(e) {
    return xe(Ul(e));
  },
  // Hour: 0, 1, ... 23
  H(e) {
    return e.getHours();
  },
  // Hour: 00, 01, ..., 23
  HH(e) {
    return xe(e.getHours());
  },
  // Hour: 1, 2, ..., 12
  h(e) {
    const t = e.getHours();
    return t === 0 ? 12 : t > 12 ? t % 12 : t;
  },
  // Hour: 01, 02, ..., 12
  hh(e) {
    return xe(this.h(e));
  },
  // Minute: 0, 1, ..., 59
  m(e) {
    return e.getMinutes();
  },
  // Minute: 00, 01, ..., 59
  mm(e) {
    return xe(e.getMinutes());
  },
  // Second: 0, 1, ..., 59
  s(e) {
    return e.getSeconds();
  },
  // Second: 00, 01, ..., 59
  ss(e) {
    return xe(e.getSeconds());
  },
  // 1/10 of second: 0, 1, ..., 9
  S(e) {
    return Math.floor(e.getMilliseconds() / 100);
  },
  // 1/100 of second: 00, 01, ..., 99
  SS(e) {
    return xe(Math.floor(e.getMilliseconds() / 10));
  },
  // Millisecond: 000, 001, ..., 999
  SSS(e) {
    return xe(e.getMilliseconds(), 3);
  },
  // Meridiem: AM, PM
  A(e) {
    return e.getHours() < 12 ? "AM" : "PM";
  },
  // Meridiem: am, pm
  a(e) {
    return e.getHours() < 12 ? "am" : "pm";
  },
  // Meridiem: a.m., p.m.
  aa(e) {
    return e.getHours() < 12 ? "a.m." : "p.m.";
  },
  // Timezone: -01:00, +00:00, ... +12:00
  Z(e, t, n, l) {
    const a = l ?? e.getTimezoneOffset();
    return Eo(a, ":");
  },
  // Timezone: -0100, +0000, ... +1200
  ZZ(e, t, n, l) {
    const a = l ?? e.getTimezoneOffset();
    return Eo(a);
  },
  // Seconds timestamp: 512969520
  X(e) {
    return Math.floor(e.getTime() / 1e3);
  },
  // Milliseconds timestamp: 512969520900
  x(e) {
    return e.getTime();
  }
};
function ii(e, t, n, l, a) {
  if (e !== 0 && !e || e === 1 / 0 || e === -1 / 0) return;
  const o = new Date(e);
  if (isNaN(o)) return;
  t === void 0 && (t = ai);
  const r = oi(n, Kt.props);
  return t.replace(
    xc,
    (i, c) => i in Mo ? Mo[i](o, r, l, a) : c === void 0 ? i : c.split("\\]").join("]")
  );
}
const Gt = 20, qc = ["Calendar", "Years", "Months"], Ro = (e) => qc.includes(e), Kl = (e) => /^-?[\d]+\/[0-1]\d$/.test(e), gn = " — ";
function Ut(e) {
  return e.year + "/" + xe(e.month);
}
const To = Ce({
  name: "QDate",
  props: {
    ...gl,
    ...qn,
    ...rt,
    modelValue: {
      required: !0,
      validator: (e) => typeof e == "string" || Array.isArray(e) === !0 || Object(e) === e || e === null
    },
    multiple: Boolean,
    range: Boolean,
    title: String,
    subtitle: String,
    mask: {
      ...gl.mask,
      // this mask is forced
      // when using persian calendar
      default: "YYYY/MM/DD"
    },
    defaultYearMonth: {
      type: String,
      validator: Kl
    },
    yearsInMonthView: Boolean,
    events: [Array, Function],
    eventColor: [String, Function],
    emitImmediately: Boolean,
    options: [Array, Function],
    navigationMinYearMonth: {
      type: String,
      validator: Kl
    },
    navigationMaxYearMonth: {
      type: String,
      validator: Kl
    },
    noUnset: Boolean,
    firstDayOfWeek: [String, Number],
    todayBtn: Boolean,
    minimal: Boolean,
    defaultView: {
      type: String,
      default: "Calendar",
      validator: Ro
    }
  },
  emits: [
    ...ti,
    "rangeStart",
    "rangeEnd",
    "navigation"
  ],
  setup(e, { slots: t, emit: n }) {
    const { proxy: l } = we(), { $q: a } = l, o = it(e, a), { getCache: r } = hc(), { tabindex: i, headerClass: c, getLocale: s, getCurrentDate: u } = ni(e, a);
    let f;
    const S = Vr(e), b = _l(S), h = J(null), x = J(Tt()), g = J(s()), T = d(() => Tt()), P = d(() => s()), _ = d(() => u()), y = J(lt(x.value, g.value)), p = J(e.defaultView), F = d(() => a.lang.rtl === !0 ? "right" : "left"), A = J(F.value), U = J(F.value), D = y.value.year, L = J(D - D % Gt - (D < 0 ? Gt : 0)), H = J(null), E = d(() => {
      const m = e.landscape === !0 ? "landscape" : "portrait";
      return `q-date q-date--${m} q-date--${m}-${e.minimal === !0 ? "minimal" : "standard"}` + (o.value === !0 ? " q-date--dark q-dark" : "") + (e.bordered === !0 ? " q-date--bordered" : "") + (e.square === !0 ? " q-date--square no-border-radius" : "") + (e.flat === !0 ? " q-date--flat no-shadow" : "") + (e.disable === !0 ? " disabled" : e.readonly === !0 ? " q-date--readonly" : "");
    }), $ = d(() => e.color || "primary"), M = d(() => e.textColor || "white"), K = d(
      () => e.emitImmediately === !0 && e.multiple !== !0 && e.range !== !0
    ), Q = d(() => Array.isArray(e.modelValue) === !0 ? e.modelValue : e.modelValue !== null && e.modelValue !== void 0 ? [e.modelValue] : []), te = d(
      () => Q.value.filter((m) => typeof m == "string").map((m) => Pt(m, x.value, g.value)).filter(
        (m) => m.dateHash !== null && m.day !== null && m.month !== null && m.year !== null
      )
    ), N = d(() => {
      const m = (k) => Pt(k, x.value, g.value);
      return Q.value.filter((k) => qa(k) === !0 && k.from !== void 0 && k.to !== void 0).map((k) => ({ from: m(k.from), to: m(k.to) })).filter((k) => k.from.dateHash !== null && k.to.dateHash !== null && k.from.dateHash < k.to.dateHash);
    }), Z = d(() => e.calendar !== "persian" ? (m) => new Date(m.year, m.month - 1, m.day) : (m) => {
      const k = Co(m.year, m.month, m.day);
      return new Date(k.gy, k.gm - 1, k.gd);
    }), de = d(() => e.calendar === "persian" ? $t : (m, k, R) => ii(
      new Date(
        m.year,
        m.month - 1,
        m.day,
        m.hour,
        m.minute,
        m.second,
        m.millisecond
      ),
      k === void 0 ? x.value : k,
      R === void 0 ? g.value : R,
      m.year,
      m.timezoneOffset
    )), q = d(
      () => te.value.length + N.value.reduce(
        (m, k) => m + 1 + ri(
          Z.value(k.to),
          Z.value(k.from)
        ),
        0
      )
    ), C = d(() => {
      if (e.title !== void 0 && e.title !== null && e.title.length !== 0)
        return e.title;
      if (H.value !== null) {
        const R = H.value.init, Y = Z.value(R);
        return g.value.daysShort[Y.getDay()] + ", " + g.value.monthsShort[R.month - 1] + " " + R.day + gn + "?";
      }
      if (q.value === 0)
        return gn;
      if (q.value > 1)
        return `${q.value} ${g.value.pluralDay}`;
      const m = te.value[0], k = Z.value(m);
      return isNaN(k.valueOf()) === !0 ? gn : g.value.headerTitle !== void 0 ? g.value.headerTitle(k, m) : g.value.daysShort[k.getDay()] + ", " + g.value.monthsShort[m.month - 1] + " " + m.day;
    }), G = d(() => te.value.concat(N.value.map((k) => k.from)).sort((k, R) => k.year - R.year || k.month - R.month)[0]), ie = d(() => te.value.concat(N.value.map((k) => k.to)).sort((k, R) => R.year - k.year || R.month - k.month)[0]), me = d(() => {
      if (e.subtitle !== void 0 && e.subtitle !== null && e.subtitle.length !== 0)
        return e.subtitle;
      if (q.value === 0)
        return gn;
      if (q.value > 1) {
        const m = G.value, k = ie.value, R = g.value.monthsShort;
        return R[m.month - 1] + (m.year !== k.year ? " " + m.year + gn + R[k.month - 1] + " " : m.month !== k.month ? gn + R[k.month - 1] : "") + " " + k.year;
      }
      return te.value[0].year;
    }), j = d(() => {
      const m = [a.iconSet.datetime.arrowLeft, a.iconSet.datetime.arrowRight];
      return a.lang.rtl === !0 ? m.reverse() : m;
    }), X = d(() => e.firstDayOfWeek !== void 0 ? Number(e.firstDayOfWeek) : g.value.firstDayOfWeek), ge = d(() => {
      const m = g.value.daysShort, k = X.value;
      return k > 0 ? m.slice(k, 7).concat(m.slice(0, k)) : m;
    }), z = d(() => {
      const m = y.value;
      return e.calendar !== "persian" ? new Date(m.year, m.month, 0).getDate() : ol(m.year, m.month);
    }), qe = d(() => typeof e.eventColor == "function" ? e.eventColor : () => e.eventColor), pe = d(() => {
      if (e.navigationMinYearMonth === void 0)
        return null;
      const m = e.navigationMinYearMonth.split("/");
      return { year: parseInt(m[0], 10), month: parseInt(m[1], 10) };
    }), Re = d(() => {
      if (e.navigationMaxYearMonth === void 0)
        return null;
      const m = e.navigationMaxYearMonth.split("/");
      return { year: parseInt(m[0], 10), month: parseInt(m[1], 10) };
    }), je = d(() => {
      const m = {
        month: { prev: !0, next: !0 },
        year: { prev: !0, next: !0 }
      };
      return pe.value !== null && pe.value.year >= y.value.year && (m.year.prev = !1, pe.value.year === y.value.year && pe.value.month >= y.value.month && (m.month.prev = !1)), Re.value !== null && Re.value.year <= y.value.year && (m.year.next = !1, Re.value.year === y.value.year && Re.value.month <= y.value.month && (m.month.next = !1)), m;
    }), ut = d(() => {
      const m = {};
      return te.value.forEach((k) => {
        const R = Ut(k);
        m[R] === void 0 && (m[R] = []), m[R].push(k.day);
      }), m;
    }), nt = d(() => {
      const m = {};
      return N.value.forEach((k) => {
        const R = Ut(k.from), Y = Ut(k.to);
        if (m[R] === void 0 && (m[R] = []), m[R].push({
          from: k.from.day,
          to: R === Y ? k.to.day : void 0,
          range: k
        }), R < Y) {
          let W;
          const { year: Se, month: ae } = k.from, fe = ae < 12 ? { year: Se, month: ae + 1 } : { year: Se + 1, month: 1 };
          for (; (W = Ut(fe)) <= Y; )
            m[W] === void 0 && (m[W] = []), m[W].push({
              from: void 0,
              to: W === Y ? k.to.day : void 0,
              range: k
            }), fe.month++, fe.month > 12 && (fe.year++, fe.month = 1);
        }
      }), m;
    }), Qe = d(() => {
      if (H.value === null) return;
      const { init: m, initHash: k, final: R, finalHash: Y } = H.value, [W, Se] = k <= Y ? [m, R] : [R, m], ae = Ut(W), fe = Ut(Se);
      if (ae !== $e.value && fe !== $e.value) return;
      const _e = {};
      return ae === $e.value ? (_e.from = W.day, _e.includeFrom = !0) : _e.from = 1, fe === $e.value ? (_e.to = Se.day, _e.includeTo = !0) : _e.to = z.value, _e;
    }), $e = d(() => Ut(y.value)), Ct = d(() => {
      const m = {};
      if (e.options === void 0) {
        for (let R = 1; R <= z.value; R++)
          m[R] = !0;
        return m;
      }
      const k = typeof e.options == "function" ? e.options : (R) => e.options.includes(R);
      for (let R = 1; R <= z.value; R++) {
        const Y = $e.value + "/" + xe(R);
        m[R] = k(Y);
      }
      return m;
    }), Dt = d(() => {
      const m = {};
      if (e.events === void 0)
        for (let k = 1; k <= z.value; k++)
          m[k] = !1;
      else {
        const k = typeof e.events == "function" ? e.events : (R) => e.events.includes(R);
        for (let R = 1; R <= z.value; R++) {
          const Y = $e.value + "/" + xe(R);
          m[R] = k(Y) === !0 && qe.value(Y);
        }
      }
      return m;
    }), dt = d(() => {
      let m, k;
      const { year: R, month: Y } = y.value;
      if (e.calendar !== "persian")
        m = new Date(R, Y - 1, 1), k = new Date(R, Y - 1, 0).getDate();
      else {
        const W = Co(R, Y, 1);
        m = new Date(W.gy, W.gm - 1, W.gd);
        let Se = Y - 1, ae = R;
        Se === 0 && (Se = 12, ae--), k = ol(ae, Se);
      }
      return {
        days: m.getDay() - X.value - 1,
        endDay: k
      };
    }), Ue = d(() => {
      const m = [], { days: k, endDay: R } = dt.value, Y = k < 0 ? k + 7 : k;
      if (Y < 6)
        for (let ae = R - Y; ae <= R; ae++)
          m.push({ i: ae, fill: !0 });
      const W = m.length;
      for (let ae = 1; ae <= z.value; ae++) {
        const fe = { i: ae, event: Dt.value[ae], classes: [] };
        Ct.value[ae] === !0 && (fe.in = !0, fe.flat = !0), m.push(fe);
      }
      if (ut.value[$e.value] !== void 0 && ut.value[$e.value].forEach((ae) => {
        const fe = W + ae - 1;
        Object.assign(m[fe], {
          selected: !0,
          unelevated: !0,
          flat: !1,
          color: $.value,
          textColor: M.value
        });
      }), nt.value[$e.value] !== void 0 && nt.value[$e.value].forEach((ae) => {
        if (ae.from !== void 0) {
          const fe = W + ae.from - 1, _e = W + (ae.to || z.value) - 1;
          for (let gt = fe; gt <= _e; gt++)
            Object.assign(m[gt], {
              range: ae.range,
              unelevated: !0,
              color: $.value,
              textColor: M.value
            });
          Object.assign(m[fe], {
            rangeFrom: !0,
            flat: !1
          }), ae.to !== void 0 && Object.assign(m[_e], {
            rangeTo: !0,
            flat: !1
          });
        } else if (ae.to !== void 0) {
          const fe = W + ae.to - 1;
          for (let _e = W; _e <= fe; _e++)
            Object.assign(m[_e], {
              range: ae.range,
              unelevated: !0,
              color: $.value,
              textColor: M.value
            });
          Object.assign(m[fe], {
            flat: !1,
            rangeTo: !0
          });
        } else {
          const fe = W + z.value - 1;
          for (let _e = W; _e <= fe; _e++)
            Object.assign(m[_e], {
              range: ae.range,
              unelevated: !0,
              color: $.value,
              textColor: M.value
            });
        }
      }), Qe.value !== void 0) {
        const ae = W + Qe.value.from - 1, fe = W + Qe.value.to - 1;
        for (let _e = ae; _e <= fe; _e++)
          m[_e].color = $.value, m[_e].editRange = !0;
        Qe.value.includeFrom === !0 && (m[ae].editRangeFrom = !0), Qe.value.includeTo === !0 && (m[fe].editRangeTo = !0);
      }
      y.value.year === _.value.year && y.value.month === _.value.month && (m[W + _.value.day - 1].today = !0);
      const Se = m.length % 7;
      if (Se > 0) {
        const ae = 7 - Se;
        for (let fe = 1; fe <= ae; fe++)
          m.push({ i: fe, fill: !0 });
      }
      return m.forEach((ae) => {
        let fe = "q-date__calendar-item ";
        ae.fill === !0 ? fe += "q-date__calendar-item--fill" : (fe += `q-date__calendar-item--${ae.in === !0 ? "in" : "out"}`, ae.range !== void 0 && (fe += ` q-date__range${ae.rangeTo === !0 ? "-to" : ae.rangeFrom === !0 ? "-from" : ""}`), ae.editRange === !0 && (fe += ` q-date__edit-range${ae.editRangeFrom === !0 ? "-from" : ""}${ae.editRangeTo === !0 ? "-to" : ""}`), (ae.range !== void 0 || ae.editRange === !0) && (fe += ` text-${ae.color}`)), ae.classes = fe;
      }), m;
    }), He = d(() => e.disable === !0 ? { "aria-disabled": "true" } : {});
    ce(() => e.modelValue, (m) => {
      if (f === m)
        f = 0;
      else {
        const k = lt(x.value, g.value);
        Pe(k.year, k.month, k);
      }
    }), ce(p, () => {
      h.value !== null && l.$el.contains(document.activeElement) === !0 && h.value.focus();
    }), ce(() => y.value.year + "|" + y.value.month, () => {
      n("navigation", { year: y.value.year, month: y.value.month });
    }), ce(T, (m) => {
      B(m, g.value, "mask"), x.value = m;
    }), ce(P, (m) => {
      B(x.value, m, "locale"), g.value = m;
    });
    function ht() {
      const { year: m, month: k, day: R } = _.value, Y = {
        // contains more props than needed (hour, minute, second, millisecond)
        // but those aren't used in the processing of this "date" variable
        ...y.value,
        // overwriting with today's date
        year: m,
        month: k,
        day: R
      }, W = ut.value[Ut(Y)];
      (W === void 0 || W.includes(Y.day) === !1) && zt(Y), kt(Y.year, Y.month);
    }
    function wt(m) {
      Ro(m) === !0 && (p.value = m);
    }
    function Lt(m, k) {
      ["month", "year"].includes(m) && (m === "month" ? I : oe)(k === !0 ? -1 : 1);
    }
    function kt(m, k) {
      p.value = "Calendar", Pe(m, k);
    }
    function ft(m, k) {
      if (e.range === !1 || !m) {
        H.value = null;
        return;
      }
      const R = Object.assign({ ...y.value }, m), Y = k !== void 0 ? Object.assign({ ...y.value }, k) : R;
      H.value = {
        init: R,
        initHash: $t(R),
        final: Y,
        finalHash: $t(Y)
      }, kt(R.year, R.month);
    }
    function Tt() {
      return e.calendar === "persian" ? "YYYY/MM/DD" : e.mask;
    }
    function Pt(m, k, R) {
      return An(
        m,
        k,
        R,
        e.calendar,
        {
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        }
      );
    }
    function lt(m, k) {
      const R = Array.isArray(e.modelValue) === !0 ? e.modelValue : e.modelValue ? [e.modelValue] : [];
      if (R.length === 0)
        return V();
      const Y = R[R.length - 1], W = Pt(
        Y.from !== void 0 ? Y.from : Y,
        m,
        k
      );
      return W.dateHash === null ? V() : W;
    }
    function V() {
      let m, k;
      if (e.defaultYearMonth !== void 0) {
        const R = e.defaultYearMonth.split("/");
        m = parseInt(R[0], 10), k = parseInt(R[1], 10);
      } else {
        const R = _.value !== void 0 ? _.value : u();
        m = R.year, k = R.month;
      }
      return {
        year: m,
        month: k,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        dateHash: m + "/" + xe(k) + "/01"
      };
    }
    function I(m) {
      let k = y.value.year, R = Number(y.value.month) + m;
      R === 13 ? (R = 1, k++) : R === 0 && (R = 12, k--), Pe(k, R), K.value === !0 && qt("month");
    }
    function oe(m) {
      const k = Number(y.value.year) + m;
      Pe(k, y.value.month), K.value === !0 && qt("year");
    }
    function he(m) {
      Pe(m, y.value.month), p.value = e.defaultView === "Years" ? "Months" : "Calendar", K.value === !0 && qt("year");
    }
    function Ee(m) {
      Pe(y.value.year, m), p.value = "Calendar", K.value === !0 && qt("month");
    }
    function Xe(m, k) {
      const R = ut.value[k];
      (R !== void 0 && R.includes(m.day) === !0 ? Jt : zt)(m);
    }
    function ue(m) {
      return { year: m.year, month: m.month, day: m.day };
    }
    function Pe(m, k, R) {
      if (pe.value !== null && m <= pe.value.year && ((k < pe.value.month || m < pe.value.year) && (k = pe.value.month), m = pe.value.year), Re.value !== null && m >= Re.value.year && ((k > Re.value.month || m > Re.value.year) && (k = Re.value.month), m = Re.value.year), R !== void 0) {
        const { hour: W, minute: Se, second: ae, millisecond: fe, timezoneOffset: _e, timeHash: gt } = R;
        Object.assign(y.value, { hour: W, minute: Se, second: ae, millisecond: fe, timezoneOffset: _e, timeHash: gt });
      }
      const Y = m + "/" + xe(k) + "/01";
      Y !== y.value.dateHash && (A.value = y.value.dateHash < Y == (a.lang.rtl !== !0) ? "left" : "right", m !== y.value.year && (U.value = A.value), De(() => {
        L.value = m - m % Gt - (m < 0 ? Gt : 0), Object.assign(y.value, {
          year: m,
          month: k,
          day: 1,
          dateHash: Y
        });
      }));
    }
    function Je(m, k, R) {
      const Y = m !== null && m.length === 1 && e.multiple === !1 ? m[0] : m;
      f = Y;
      const { reason: W, details: Se } = Nt(k, R);
      n("update:modelValue", Y, W, Se);
    }
    function qt(m) {
      const k = te.value[0] !== void 0 && te.value[0].dateHash !== null ? { ...te.value[0] } : { ...y.value };
      De(() => {
        k.year = y.value.year, k.month = y.value.month;
        const R = e.calendar !== "persian" ? new Date(k.year, k.month, 0).getDate() : ol(k.year, k.month);
        k.day = Math.min(Math.max(1, k.day), R);
        const Y = Ot(k);
        f = Y;
        const { details: W } = Nt("", k);
        n("update:modelValue", Y, m, W);
      });
    }
    function Nt(m, k) {
      return k.from !== void 0 ? {
        reason: `${m}-range`,
        details: {
          ...ue(k.target),
          from: ue(k.from),
          to: ue(k.to)
        }
      } : {
        reason: `${m}-day`,
        details: ue(k)
      };
    }
    function Ot(m, k, R) {
      return m.from !== void 0 ? { from: de.value(m.from, k, R), to: de.value(m.to, k, R) } : de.value(m, k, R);
    }
    function zt(m) {
      let k;
      if (e.multiple === !0)
        if (m.from !== void 0) {
          const R = $t(m.from), Y = $t(m.to), W = te.value.filter((ae) => ae.dateHash < R || ae.dateHash > Y), Se = N.value.filter(({ from: ae, to: fe }) => fe.dateHash < R || ae.dateHash > Y);
          k = W.concat(Se).concat(m).map((ae) => Ot(ae));
        } else {
          const R = Q.value.slice();
          R.push(Ot(m)), k = R;
        }
      else
        k = Ot(m);
      Je(k, "add", m);
    }
    function Jt(m) {
      if (e.noUnset === !0) return;
      let k = null;
      if (e.multiple === !0 && Array.isArray(e.modelValue) === !0) {
        const R = Ot(m);
        m.from !== void 0 ? k = e.modelValue.filter(
          (Y) => Y.from !== void 0 ? Y.from !== R.from && Y.to !== R.to : !0
        ) : k = e.modelValue.filter((Y) => Y !== R), k.length === 0 && (k = null);
      }
      Je(k, "remove", m);
    }
    function B(m, k, R) {
      const Y = te.value.concat(N.value).map((W) => Ot(W, m, k)).filter((W) => W.from !== void 0 ? W.from.dateHash !== null && W.to.dateHash !== null : W.dateHash !== null);
      n("update:modelValue", (e.multiple === !0 ? Y : Y[0]) || null, R);
    }
    function ee() {
      if (e.minimal !== !0)
        return v("div", {
          class: "q-date__header " + c.value
        }, [
          v("div", {
            class: "relative-position"
          }, [
            v(Mt, {
              name: "q-transition--fade"
            }, () => v("div", {
              key: "h-yr-" + me.value,
              class: "q-date__header-subtitle q-date__header-link " + (p.value === "Years" ? "q-date__header-link--active" : "cursor-pointer"),
              tabindex: i.value,
              ...r("vY", {
                onClick() {
                  p.value = "Years";
                },
                onKeyup(m) {
                  m.keyCode === 13 && (p.value = "Years");
                }
              })
            }, [me.value]))
          ]),
          v("div", {
            class: "q-date__header-title relative-position flex no-wrap"
          }, [
            v("div", {
              class: "relative-position col"
            }, [
              v(Mt, {
                name: "q-transition--fade"
              }, () => v("div", {
                key: "h-sub" + C.value,
                class: "q-date__header-title-label q-date__header-link " + (p.value === "Calendar" ? "q-date__header-link--active" : "cursor-pointer"),
                tabindex: i.value,
                ...r("vC", {
                  onClick() {
                    p.value = "Calendar";
                  },
                  onKeyup(m) {
                    m.keyCode === 13 && (p.value = "Calendar");
                  }
                })
              }, [C.value]))
            ]),
            e.todayBtn === !0 ? v(Te, {
              class: "q-date__header-today self-start",
              icon: a.iconSet.datetime.today,
              flat: !0,
              size: "sm",
              round: !0,
              tabindex: i.value,
              onClick: ht
            }) : null
          ])
        ]);
    }
    function re({ label: m, type: k, key: R, dir: Y, goTo: W, boundaries: Se, cls: ae }) {
      return [
        v("div", {
          class: "row items-center q-date__arrow"
        }, [
          v(Te, {
            round: !0,
            dense: !0,
            size: "sm",
            flat: !0,
            icon: j.value[0],
            tabindex: i.value,
            disable: Se.prev === !1,
            ...r("go-#" + k, { onClick() {
              W(-1);
            } })
          })
        ]),
        v("div", {
          class: "relative-position overflow-hidden flex flex-center" + ae
        }, [
          v(Mt, {
            name: "q-transition--jump-" + Y
          }, () => v("div", { key: R }, [
            v(Te, {
              flat: !0,
              dense: !0,
              noCaps: !0,
              label: m,
              tabindex: i.value,
              ...r("view#" + k, { onClick: () => {
                p.value = k;
              } })
            })
          ]))
        ]),
        v("div", {
          class: "row items-center q-date__arrow"
        }, [
          v(Te, {
            round: !0,
            dense: !0,
            size: "sm",
            flat: !0,
            icon: j.value[1],
            tabindex: i.value,
            disable: Se.next === !1,
            ...r("go+#" + k, { onClick() {
              W(1);
            } })
          })
        ])
      ];
    }
    const se = {
      Calendar: () => [
        v("div", {
          key: "calendar-view",
          class: "q-date__view q-date__calendar"
        }, [
          v("div", {
            class: "q-date__navigation row items-center no-wrap"
          }, re({
            label: g.value.months[y.value.month - 1],
            type: "Months",
            key: y.value.month,
            dir: A.value,
            goTo: I,
            boundaries: je.value.month,
            cls: " col"
          }).concat(re({
            label: y.value.year,
            type: "Years",
            key: y.value.year,
            dir: U.value,
            goTo: oe,
            boundaries: je.value.year,
            cls: ""
          }))),
          v("div", {
            class: "q-date__calendar-weekdays row items-center no-wrap"
          }, ge.value.map((m) => v("div", { class: "q-date__calendar-item" }, [v("div", m)]))),
          v("div", {
            class: "q-date__calendar-days-container relative-position overflow-hidden"
          }, [
            v(Mt, {
              name: "q-transition--slide-" + A.value
            }, () => v("div", {
              key: $e.value,
              class: "q-date__calendar-days fit"
            }, Ue.value.map((m) => v("div", { class: m.classes }, [
              m.in === !0 ? v(
                Te,
                {
                  class: m.today === !0 ? "q-date__today" : "",
                  dense: !0,
                  flat: m.flat,
                  unelevated: m.unelevated,
                  color: m.color,
                  textColor: m.textColor,
                  label: m.i,
                  tabindex: i.value,
                  ...r("day#" + m.i, {
                    onClick: () => {
                      be(m.i);
                    },
                    onMouseover: () => {
                      Ve(m.i);
                    }
                  })
                },
                m.event !== !1 ? () => v("div", { class: "q-date__event bg-" + m.event }) : null
              ) : v("div", "" + m.i)
            ]))))
          ])
        ])
      ],
      Months() {
        const m = y.value.year === _.value.year, k = (Y) => pe.value !== null && y.value.year === pe.value.year && pe.value.month > Y || Re.value !== null && y.value.year === Re.value.year && Re.value.month < Y, R = g.value.monthsShort.map((Y, W) => {
          const Se = y.value.month === W + 1;
          return v("div", {
            class: "q-date__months-item flex flex-center"
          }, [
            v(Te, {
              class: m === !0 && _.value.month === W + 1 ? "q-date__today" : null,
              flat: Se !== !0,
              label: Y,
              unelevated: Se,
              color: Se === !0 ? $.value : null,
              textColor: Se === !0 ? M.value : null,
              tabindex: i.value,
              disable: k(W + 1),
              ...r("month#" + W, { onClick: () => {
                Ee(W + 1);
              } })
            })
          ]);
        });
        return e.yearsInMonthView === !0 && R.unshift(
          v("div", { class: "row no-wrap full-width" }, [
            re({
              label: y.value.year,
              type: "Years",
              key: y.value.year,
              dir: U.value,
              goTo: oe,
              boundaries: je.value.year,
              cls: " col"
            })
          ])
        ), v("div", {
          key: "months-view",
          class: "q-date__view q-date__months flex flex-center"
        }, R);
      },
      Years() {
        const m = L.value, k = m + Gt, R = [], Y = (W) => pe.value !== null && pe.value.year > W || Re.value !== null && Re.value.year < W;
        for (let W = m; W <= k; W++) {
          const Se = y.value.year === W;
          R.push(
            v("div", {
              class: "q-date__years-item flex flex-center"
            }, [
              v(Te, {
                key: "yr" + W,
                class: _.value.year === W ? "q-date__today" : null,
                flat: !Se,
                label: W,
                dense: !0,
                unelevated: Se,
                color: Se === !0 ? $.value : null,
                textColor: Se === !0 ? M.value : null,
                tabindex: i.value,
                disable: Y(W),
                ...r("yr#" + W, { onClick: () => {
                  he(W);
                } })
              })
            ])
          );
        }
        return v("div", {
          class: "q-date__view q-date__years flex flex-center"
        }, [
          v("div", {
            class: "col-auto"
          }, [
            v(Te, {
              round: !0,
              dense: !0,
              flat: !0,
              icon: j.value[0],
              tabindex: i.value,
              disable: Y(m),
              ...r("y-", { onClick: () => {
                L.value -= Gt;
              } })
            })
          ]),
          v("div", {
            class: "q-date__years-content col self-stretch row items-center"
          }, R),
          v("div", {
            class: "col-auto"
          }, [
            v(Te, {
              round: !0,
              dense: !0,
              flat: !0,
              icon: j.value[1],
              tabindex: i.value,
              disable: Y(k),
              ...r("y+", { onClick: () => {
                L.value += Gt;
              } })
            })
          ])
        ]);
      }
    };
    function be(m) {
      const k = { ...y.value, day: m };
      if (e.range === !1) {
        Xe(k, $e.value);
        return;
      }
      if (H.value === null) {
        const R = Ue.value.find((W) => W.fill !== !0 && W.i === m);
        if (e.noUnset !== !0 && R.range !== void 0) {
          Jt({ target: k, from: R.range.from, to: R.range.to });
          return;
        }
        if (R.selected === !0) {
          Jt(k);
          return;
        }
        const Y = $t(k);
        H.value = {
          init: k,
          initHash: Y,
          final: k,
          finalHash: Y
        }, n("rangeStart", ue(k));
      } else {
        const R = H.value.initHash, Y = $t(k), W = R <= Y ? { from: H.value.init, to: k } : { from: k, to: H.value.init };
        H.value = null, zt(R === Y ? k : { target: k, ...W }), n("rangeEnd", {
          from: ue(W.from),
          to: ue(W.to)
        });
      }
    }
    function Ve(m) {
      if (H.value !== null) {
        const k = { ...y.value, day: m };
        Object.assign(H.value, {
          final: k,
          finalHash: $t(k)
        });
      }
    }
    return Object.assign(l, {
      setToday: ht,
      setView: wt,
      offsetCalendar: Lt,
      setCalendarTo: kt,
      setEditingRange: ft
    }), () => {
      const m = [
        v("div", {
          class: "q-date__content col relative-position"
        }, [
          v(Mt, {
            name: "q-transition--fade"
          }, se[p.value])
        ])
      ], k = We(t.default);
      return k !== void 0 && m.push(
        v("div", { class: "q-date__actions" }, k)
      ), e.name !== void 0 && e.disable !== !0 && b(m, "push"), v("div", {
        class: E.value,
        ...He.value
      }, [
        ee(),
        v("div", {
          ref: h,
          class: "q-date__main col column",
          tabindex: -1
        }, m)
      ]);
    };
  }
}), Ma = {
  left: !0,
  right: !0,
  up: !0,
  down: !0,
  horizontal: !0,
  vertical: !0
}, Ec = Object.keys(Ma);
Ma.all = !0;
function Po(e) {
  const t = {};
  for (const n of Ec)
    e[n] === !0 && (t[n] = !0);
  return Object.keys(t).length === 0 ? Ma : (t.horizontal === !0 ? t.left = t.right = !0 : t.left === !0 && t.right === !0 && (t.horizontal = !0), t.vertical === !0 ? t.up = t.down = !0 : t.up === !0 && t.down === !0 && (t.vertical = !0), t.horizontal === !0 && t.vertical === !0 && (t.all = !0), t);
}
const Mc = ["INPUT", "TEXTAREA"];
function Oo(e, t) {
  return t.event === void 0 && e.target !== void 0 && e.target.draggable !== !0 && typeof t.handler == "function" && Mc.includes(e.target.nodeName.toUpperCase()) === !1 && (e.qClonedBy === void 0 || e.qClonedBy.indexOf(t.uid) === -1);
}
function Wl(e, t, n) {
  const l = Sn(e);
  let a, o = l.left - t.event.x, r = l.top - t.event.y, i = Math.abs(o), c = Math.abs(r);
  const s = t.direction;
  s.horizontal === !0 && s.vertical !== !0 ? a = o < 0 ? "left" : "right" : s.horizontal !== !0 && s.vertical === !0 ? a = r < 0 ? "up" : "down" : s.up === !0 && r < 0 ? (a = "up", i > c && (s.left === !0 && o < 0 ? a = "left" : s.right === !0 && o > 0 && (a = "right"))) : s.down === !0 && r > 0 ? (a = "down", i > c && (s.left === !0 && o < 0 ? a = "left" : s.right === !0 && o > 0 && (a = "right"))) : s.left === !0 && o < 0 ? (a = "left", i < c && (s.up === !0 && r < 0 ? a = "up" : s.down === !0 && r > 0 && (a = "down"))) : s.right === !0 && o > 0 && (a = "right", i < c && (s.up === !0 && r < 0 ? a = "up" : s.down === !0 && r > 0 && (a = "down")));
  let u = !1;
  if (a === void 0 && n === !1) {
    if (t.event.isFirst === !0 || t.event.lastDir === void 0)
      return {};
    a = t.event.lastDir, u = !0, a === "left" || a === "right" ? (l.left -= o, i = 0, o = 0) : (l.top -= r, c = 0, r = 0);
  }
  return {
    synthetic: u,
    payload: {
      evt: e,
      touch: t.event.mouse !== !0,
      mouse: t.event.mouse === !0,
      position: l,
      direction: a,
      isFirst: t.event.isFirst,
      isFinal: n === !0,
      duration: Date.now() - t.event.time,
      distance: {
        x: i,
        y: c
      },
      offset: {
        x: o,
        y: r
      },
      delta: {
        x: l.left - t.event.lastX,
        y: l.top - t.event.lastY
      }
    }
  };
}
let Rc = 0;
const Tc = pa(
  {
    name: "touch-pan",
    beforeMount(e, { value: t, modifiers: n }) {
      if (n.mouse !== !0 && Ge.has.touch !== !0) return;
      function l(o, r) {
        n.mouse === !0 && r === !0 ? Fe(o) : (n.stop === !0 && bt(o), n.prevent === !0 && ct(o));
      }
      const a = {
        uid: "qvtp_" + Rc++,
        handler: t,
        modifiers: n,
        direction: Po(n),
        noop: rr,
        mouseStart(o) {
          Oo(o, a) && Gi(o) && (tn(a, "temp", [
            [document, "mousemove", "move", "notPassiveCapture"],
            [document, "mouseup", "end", "passiveCapture"]
          ]), a.start(o, !0));
        },
        touchStart(o) {
          if (Oo(o, a)) {
            const r = o.target;
            tn(a, "temp", [
              [r, "touchmove", "move", "notPassiveCapture"],
              [r, "touchcancel", "end", "passiveCapture"],
              [r, "touchend", "end", "passiveCapture"]
            ]), a.start(o);
          }
        },
        start(o, r) {
          if (Ge.is.firefox === !0 && Vl(e, !0), a.lastEvt = o, r === !0 || n.stop === !0) {
            if (a.direction.all !== !0 && (r !== !0 || a.modifiers.mouseAllDir !== !0 && a.modifiers.mousealldir !== !0)) {
              const s = o.type.indexOf("mouse") !== -1 ? new MouseEvent(o.type, o) : new TouchEvent(o.type, o);
              o.defaultPrevented === !0 && ct(s), o.cancelBubble === !0 && bt(s), Object.assign(s, {
                qKeyEvent: o.qKeyEvent,
                qClickOutside: o.qClickOutside,
                qAnchorHandled: o.qAnchorHandled,
                qClonedBy: o.qClonedBy === void 0 ? [a.uid] : o.qClonedBy.concat(a.uid)
              }), a.initialEvent = {
                target: o.target,
                event: s
              };
            }
            bt(o);
          }
          const { left: i, top: c } = Sn(o);
          a.event = {
            x: i,
            y: c,
            time: Date.now(),
            mouse: r === !0,
            detected: !1,
            isFirst: !0,
            isFinal: !1,
            lastX: i,
            lastY: c
          };
        },
        move(o) {
          if (a.event === void 0) return;
          const r = Sn(o), i = r.left - a.event.x, c = r.top - a.event.y;
          if (i === 0 && c === 0) return;
          a.lastEvt = o;
          const s = a.event.mouse === !0, u = () => {
            l(o, s);
            let b;
            n.preserveCursor !== !0 && n.preservecursor !== !0 && (b = document.documentElement.style.cursor || "", document.documentElement.style.cursor = "grabbing"), s === !0 && document.body.classList.add("no-pointer-events--children"), document.body.classList.add("non-selectable"), jr(), a.styleCleanup = (h) => {
              if (a.styleCleanup = void 0, b !== void 0 && (document.documentElement.style.cursor = b), document.body.classList.remove("non-selectable"), s === !0) {
                const x = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                h !== void 0 ? setTimeout(() => {
                  x(), h();
                }, 50) : x();
              } else h !== void 0 && h();
            };
          };
          if (a.event.detected === !0) {
            a.event.isFirst !== !0 && l(o, a.event.mouse);
            const { payload: b, synthetic: h } = Wl(o, a, !1);
            b !== void 0 && (a.handler(b) === !1 ? a.end(o) : (a.styleCleanup === void 0 && a.event.isFirst === !0 && u(), a.event.lastX = b.position.left, a.event.lastY = b.position.top, a.event.lastDir = h === !0 ? void 0 : b.direction, a.event.isFirst = !1));
            return;
          }
          if (a.direction.all === !0 || s === !0 && (a.modifiers.mouseAllDir === !0 || a.modifiers.mousealldir === !0)) {
            u(), a.event.detected = !0, a.move(o);
            return;
          }
          const f = Math.abs(i), S = Math.abs(c);
          f !== S && (a.direction.horizontal === !0 && f > S || a.direction.vertical === !0 && f < S || a.direction.up === !0 && f < S && c < 0 || a.direction.down === !0 && f < S && c > 0 || a.direction.left === !0 && f > S && i < 0 || a.direction.right === !0 && f > S && i > 0 ? (a.event.detected = !0, a.move(o)) : a.end(o, !0));
        },
        end(o, r) {
          if (a.event !== void 0) {
            if (Ln(a, "temp"), Ge.is.firefox === !0 && Vl(e, !1), r === !0)
              a.styleCleanup !== void 0 && a.styleCleanup(), a.event.detected !== !0 && a.initialEvent !== void 0 && a.initialEvent.target.dispatchEvent(a.initialEvent.event);
            else if (a.event.detected === !0) {
              a.event.isFirst === !0 && a.handler(Wl(o === void 0 ? a.lastEvt : o, a).payload);
              const { payload: i } = Wl(o === void 0 ? a.lastEvt : o, a, !0), c = () => {
                a.handler(i);
              };
              a.styleCleanup !== void 0 ? a.styleCleanup(c) : c();
            }
            a.event = void 0, a.initialEvent = void 0, a.lastEvt = void 0;
          }
        }
      };
      if (e.__qtouchpan = a, n.mouse === !0) {
        const o = n.mouseCapture === !0 || n.mousecapture === !0 ? "Capture" : "";
        tn(a, "main", [
          [e, "mousedown", "mouseStart", `passive${o}`]
        ]);
      }
      Ge.has.touch === !0 && tn(a, "main", [
        [e, "touchstart", "touchStart", `passive${n.capture === !0 ? "Capture" : ""}`],
        [e, "touchmove", "noop", "notPassiveCapture"]
        // cannot be passive (ex: iOS scroll)
      ]);
    },
    updated(e, t) {
      const n = e.__qtouchpan;
      n !== void 0 && (t.oldValue !== t.value && (typeof value != "function" && n.end(), n.handler = t.value), n.direction = Po(t.modifiers));
    },
    beforeUnmount(e) {
      const t = e.__qtouchpan;
      t !== void 0 && (t.event !== void 0 && t.end(), Ln(t, "main"), Ln(t, "temp"), Ge.is.firefox === !0 && Vl(e, !1), t.styleCleanup !== void 0 && t.styleCleanup(), delete e.__qtouchpan);
    }
  }
);
function Pc(e, t) {
  return e.hour !== null && e.minute === null ? "minute" : "hour";
}
function Oc() {
  const e = /* @__PURE__ */ new Date();
  return {
    hour: e.getHours(),
    minute: e.getMinutes(),
    second: e.getSeconds(),
    millisecond: e.getMilliseconds()
  };
}
const Bo = Ce({
  name: "QTime",
  props: {
    ...rt,
    ...qn,
    ...gl,
    modelValue: {
      required: !0,
      validator: (e) => typeof e == "string" || e === null
    },
    mask: {
      ...gl.mask,
      default: null
    },
    format24h: {
      type: Boolean,
      default: null
    },
    defaultDate: {
      type: String,
      validator: (e) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e)
    },
    options: Function,
    hourOptions: Array,
    minuteOptions: Array,
    secondOptions: Array,
    withSeconds: Boolean,
    nowBtn: Boolean
  },
  emits: ti,
  setup(e, { slots: t, emit: n }) {
    const l = we(), { $q: a } = l.proxy, o = it(e, a), { tabindex: r, headerClass: i, getLocale: c, getCurrentDate: s } = ni(e, a), u = Vr(e), f = _l(u);
    let S, b;
    const h = J(null), x = d(() => me()), g = d(() => c()), T = d(() => j()), P = An(
      e.modelValue,
      x.value,
      // initial mask
      g.value,
      // initial locale
      e.calendar,
      T.value
    ), _ = J(Pc(P)), y = J(P), p = J(P.hour === null || P.hour < 12), F = d(
      () => `q-time q-time--${e.landscape === !0 ? "landscape" : "portrait"}` + (o.value === !0 ? " q-time--dark q-dark" : "") + (e.disable === !0 ? " disabled" : e.readonly === !0 ? " q-time--readonly" : "") + (e.bordered === !0 ? " q-time--bordered" : "") + (e.square === !0 ? " q-time--square no-border-radius" : "") + (e.flat === !0 ? " q-time--flat no-shadow" : "")
    ), A = d(() => {
      const V = y.value;
      return {
        hour: V.hour === null ? "--" : U.value === !0 ? xe(V.hour) : String(
          p.value === !0 ? V.hour === 0 ? 12 : V.hour : V.hour > 12 ? V.hour - 12 : V.hour
        ),
        minute: V.minute === null ? "--" : xe(V.minute),
        second: V.second === null ? "--" : xe(V.second)
      };
    }), U = d(() => e.format24h !== null ? e.format24h : a.lang.date.format24h), D = d(() => {
      const V = _.value === "hour", I = V === !0 ? 12 : 60, oe = y.value[_.value];
      let Ee = `rotate(${Math.round(oe * (360 / I)) - 180}deg) translateX(-50%)`;
      return V === !0 && U.value === !0 && y.value.hour >= 12 && (Ee += " scale(.7)"), { transform: Ee };
    }), L = d(() => y.value.hour !== null), H = d(() => L.value === !0 && y.value.minute !== null), E = d(() => e.hourOptions !== void 0 ? (V) => e.hourOptions.includes(V) : e.options !== void 0 ? (V) => e.options(V, null, null) : null), $ = d(() => e.minuteOptions !== void 0 ? (V) => e.minuteOptions.includes(V) : e.options !== void 0 ? (V) => e.options(y.value.hour, V, null) : null), M = d(() => e.secondOptions !== void 0 ? (V) => e.secondOptions.includes(V) : e.options !== void 0 ? (V) => e.options(y.value.hour, y.value.minute, V) : null), K = d(() => {
      if (E.value === null)
        return null;
      const V = C(0, 11, E.value), I = C(12, 11, E.value);
      return { am: V, pm: I, values: V.values.concat(I.values) };
    }), Q = d(() => $.value !== null ? C(0, 59, $.value) : null), te = d(() => M.value !== null ? C(0, 59, M.value) : null), N = d(() => {
      switch (_.value) {
        case "hour":
          return K.value;
        case "minute":
          return Q.value;
        case "second":
          return te.value;
      }
    }), Z = d(() => {
      let V, I, oe = 0, he = 1;
      const Ee = N.value !== null ? N.value.values : void 0;
      _.value === "hour" ? U.value === !0 ? (V = 0, I = 23) : (V = 0, I = 11, p.value === !1 && (oe = 12)) : (V = 0, I = 55, he = 5);
      const Xe = [];
      for (let ue = V, Pe = V; ue <= I; ue += he, Pe++) {
        const Je = ue + oe, qt = Ee !== void 0 && Ee.includes(Je) === !1, Nt = _.value === "hour" && ue === 0 ? U.value === !0 ? "00" : "12" : ue;
        Xe.push({ val: Je, index: Pe, disable: qt, label: Nt });
      }
      return Xe;
    }), de = d(() => [[
      Tc,
      z,
      void 0,
      {
        stop: !0,
        prevent: !0,
        mouse: !0
      }
    ]]);
    ce(() => e.modelValue, (V) => {
      const I = An(
        V,
        x.value,
        g.value,
        e.calendar,
        T.value
      );
      (I.dateHash !== y.value.dateHash || I.timeHash !== y.value.timeHash) && (y.value = I, I.hour === null ? _.value = "hour" : p.value = I.hour < 12);
    }), ce([x, g], () => {
      De(() => {
        Tt();
      });
    });
    function q() {
      const V = {
        ...s(),
        ...Oc()
      };
      Tt(V), Object.assign(y.value, V), _.value = "hour";
    }
    function C(V, I, oe) {
      const he = Array.apply(null, { length: I + 1 }).map((Ee, Xe) => {
        const ue = Xe + V;
        return {
          index: ue,
          val: oe(ue) === !0
          // force boolean
        };
      }).filter((Ee) => Ee.val === !0).map((Ee) => Ee.index);
      return {
        min: he[0],
        max: he[he.length - 1],
        values: he,
        threshold: I + 1
      };
    }
    function G(V, I, oe) {
      const he = Math.abs(V - I);
      return Math.min(he, oe - he);
    }
    function ie(V, { min: I, max: oe, values: he, threshold: Ee }) {
      if (V === I)
        return I;
      if (V < I || V > oe)
        return G(V, I, Ee) <= G(V, oe, Ee) ? I : oe;
      const Xe = he.findIndex((Je) => V <= Je), ue = he[Xe - 1], Pe = he[Xe];
      return V - ue <= Pe - V ? ue : Pe;
    }
    function me() {
      return e.calendar !== "persian" && e.mask !== null ? e.mask : `HH:mm${e.withSeconds === !0 ? ":ss" : ""}`;
    }
    function j() {
      if (typeof e.defaultDate != "string") {
        const V = s(!0);
        return V.dateHash = $t(V), V;
      }
      return An(e.defaultDate, "YYYY/MM/DD", void 0, e.calendar);
    }
    function X() {
      return wl(l) === !0 || N.value !== null && (N.value.values.length === 0 || _.value === "hour" && U.value !== !0 && K.value[p.value === !0 ? "am" : "pm"].values.length === 0);
    }
    function ge() {
      const V = h.value, { top: I, left: oe, width: he } = V.getBoundingClientRect(), Ee = he / 2;
      return {
        top: I + Ee,
        left: oe + Ee,
        dist: Ee * 0.7
      };
    }
    function z(V) {
      if (X() !== !0) {
        if (V.isFirst === !0) {
          S = ge(), b = pe(V.evt, S);
          return;
        }
        b = pe(V.evt, S, b), V.isFinal === !0 && (S = !1, b = null, qe());
      }
    }
    function qe() {
      _.value === "hour" ? _.value = "minute" : e.withSeconds && _.value === "minute" && (_.value = "second");
    }
    function pe(V, I, oe) {
      const he = Sn(V), Ee = Math.abs(he.top - I.top), Xe = Math.sqrt(
        Math.pow(Math.abs(he.top - I.top), 2) + Math.pow(Math.abs(he.left - I.left), 2)
      );
      let ue, Pe = Math.asin(Ee / Xe) * (180 / Math.PI);
      if (he.top < I.top ? Pe = I.left < he.left ? 90 - Pe : 270 + Pe : Pe = I.left < he.left ? Pe + 90 : 270 - Pe, _.value === "hour") {
        if (ue = Pe / 30, K.value !== null) {
          const Je = U.value !== !0 ? p.value === !0 : K.value.am.values.length !== 0 && K.value.pm.values.length !== 0 ? Xe >= I.dist : K.value.am.values.length !== 0;
          ue = ie(
            ue + (Je === !0 ? 0 : 12),
            K.value[Je === !0 ? "am" : "pm"]
          );
        } else
          ue = Math.round(ue), U.value === !0 ? Xe < I.dist ? ue < 12 && (ue += 12) : ue === 12 && (ue = 0) : p.value === !0 && ue === 12 ? ue = 0 : p.value === !1 && ue !== 12 && (ue += 12);
        U.value === !0 && (p.value = ue < 12);
      } else
        ue = Math.round(Pe / 6) % 60, _.value === "minute" && Q.value !== null ? ue = ie(ue, Q.value) : _.value === "second" && te.value !== null && (ue = ie(ue, te.value));
      return oe !== ue && ht[_.value](ue), ue;
    }
    const Re = {
      hour() {
        _.value = "hour";
      },
      minute() {
        _.value = "minute";
      },
      second() {
        _.value = "second";
      }
    };
    function je(V) {
      V.keyCode === 13 && wt();
    }
    function ut(V) {
      V.keyCode === 13 && Lt();
    }
    function nt(V) {
      X() !== !0 && (a.platform.is.desktop !== !0 && pe(V, ge()), qe());
    }
    function Qe(V) {
      X() !== !0 && pe(V, ge());
    }
    function $e(V) {
      if (V.keyCode === 13)
        _.value = "hour";
      else if ([37, 39].includes(V.keyCode)) {
        const I = V.keyCode === 37 ? -1 : 1;
        if (K.value !== null) {
          const oe = U.value === !0 ? K.value.values : K.value[p.value === !0 ? "am" : "pm"].values;
          if (oe.length === 0) return;
          if (y.value.hour === null)
            dt(oe[0]);
          else {
            const he = (oe.length + oe.indexOf(y.value.hour) + I) % oe.length;
            dt(oe[he]);
          }
        } else {
          const oe = U.value === !0 ? 24 : 12, he = U.value !== !0 && p.value === !1 ? 12 : 0, Ee = y.value.hour === null ? -I : y.value.hour;
          dt(he + (24 + Ee + I) % oe);
        }
      }
    }
    function Ct(V) {
      if (V.keyCode === 13)
        _.value = "minute";
      else if ([37, 39].includes(V.keyCode)) {
        const I = V.keyCode === 37 ? -1 : 1;
        if (Q.value !== null) {
          const oe = Q.value.values;
          if (oe.length === 0) return;
          if (y.value.minute === null)
            Ue(oe[0]);
          else {
            const he = (oe.length + oe.indexOf(y.value.minute) + I) % oe.length;
            Ue(oe[he]);
          }
        } else {
          const oe = y.value.minute === null ? -I : y.value.minute;
          Ue((60 + oe + I) % 60);
        }
      }
    }
    function Dt(V) {
      if (V.keyCode === 13)
        _.value = "second";
      else if ([37, 39].includes(V.keyCode)) {
        const I = V.keyCode === 37 ? -1 : 1;
        if (te.value !== null) {
          const oe = te.value.values;
          if (oe.length === 0) return;
          if (y.value.seconds === null)
            He(oe[0]);
          else {
            const he = (oe.length + oe.indexOf(y.value.second) + I) % oe.length;
            He(oe[he]);
          }
        } else {
          const oe = y.value.second === null ? -I : y.value.second;
          He((60 + oe + I) % 60);
        }
      }
    }
    function dt(V) {
      y.value.hour !== V && (y.value.hour = V, ft());
    }
    function Ue(V) {
      y.value.minute !== V && (y.value.minute = V, ft());
    }
    function He(V) {
      y.value.second !== V && (y.value.second = V, ft());
    }
    const ht = {
      hour: dt,
      minute: Ue,
      second: He
    };
    function wt() {
      p.value === !1 && (p.value = !0, y.value.hour !== null && (y.value.hour -= 12, ft()));
    }
    function Lt() {
      p.value === !0 && (p.value = !1, y.value.hour !== null && (y.value.hour += 12, ft()));
    }
    function kt(V) {
      const I = e.modelValue;
      _.value !== V && I !== void 0 && I !== null && I !== "" && typeof I != "string" && (_.value = V);
    }
    function ft() {
      if (E.value !== null && E.value(y.value.hour) !== !0) {
        y.value = An(), kt("hour");
        return;
      }
      if ($.value !== null && $.value(y.value.minute) !== !0) {
        y.value.minute = null, y.value.second = null, kt("minute");
        return;
      }
      if (e.withSeconds === !0 && M.value !== null && M.value(y.value.second) !== !0) {
        y.value.second = null, kt("second");
        return;
      }
      y.value.hour === null || y.value.minute === null || e.withSeconds === !0 && y.value.second === null || Tt();
    }
    function Tt(V) {
      const I = Object.assign({ ...y.value }, V), oe = e.calendar === "persian" ? xe(I.hour) + ":" + xe(I.minute) + (e.withSeconds === !0 ? ":" + xe(I.second) : "") : ii(
        new Date(
          I.year,
          I.month === null ? null : I.month - 1,
          I.day,
          I.hour,
          I.minute,
          I.second,
          I.millisecond
        ),
        x.value,
        g.value,
        I.year,
        I.timezoneOffset
      );
      I.changed = oe !== e.modelValue, n("update:modelValue", oe, I);
    }
    function Pt() {
      const V = [
        v("div", {
          class: "q-time__link " + (_.value === "hour" ? "q-time__link--active" : "cursor-pointer"),
          tabindex: r.value,
          onClick: Re.hour,
          onKeyup: $e
        }, A.value.hour),
        v("div", ":"),
        v(
          "div",
          L.value === !0 ? {
            class: "q-time__link " + (_.value === "minute" ? "q-time__link--active" : "cursor-pointer"),
            tabindex: r.value,
            onKeyup: Ct,
            onClick: Re.minute
          } : { class: "q-time__link" },
          A.value.minute
        )
      ];
      e.withSeconds === !0 && V.push(
        v("div", ":"),
        v(
          "div",
          H.value === !0 ? {
            class: "q-time__link " + (_.value === "second" ? "q-time__link--active" : "cursor-pointer"),
            tabindex: r.value,
            onKeyup: Dt,
            onClick: Re.second
          } : { class: "q-time__link" },
          A.value.second
        )
      );
      const I = [
        v("div", {
          class: "q-time__header-label row items-center no-wrap",
          dir: "ltr"
        }, V)
      ];
      return U.value === !1 && I.push(
        v("div", {
          class: "q-time__header-ampm column items-between no-wrap"
        }, [
          v("div", {
            class: "q-time__link " + (p.value === !0 ? "q-time__link--active" : "cursor-pointer"),
            tabindex: r.value,
            onClick: wt,
            onKeyup: je
          }, "AM"),
          v("div", {
            class: "q-time__link " + (p.value !== !0 ? "q-time__link--active" : "cursor-pointer"),
            tabindex: r.value,
            onClick: Lt,
            onKeyup: ut
          }, "PM")
        ])
      ), v("div", {
        class: "q-time__header flex flex-center no-wrap " + i.value
      }, I);
    }
    function lt() {
      const V = y.value[_.value];
      return v("div", {
        class: "q-time__content col relative-position"
      }, [
        v(Mt, {
          name: "q-transition--scale"
        }, () => v("div", {
          key: "clock" + _.value,
          class: "q-time__container-parent absolute-full"
        }, [
          v("div", {
            ref: h,
            class: "q-time__container-child fit overflow-hidden"
          }, [
            At(
              v("div", {
                class: "q-time__clock cursor-pointer non-selectable",
                onClick: nt,
                onMousedown: Qe
              }, [
                v("div", { class: "q-time__clock-circle fit" }, [
                  v("div", {
                    class: "q-time__clock-pointer" + (y.value[_.value] === null ? " hidden" : e.color !== void 0 ? ` text-${e.color}` : ""),
                    style: D.value
                  }),
                  Z.value.map((I) => v("div", {
                    class: `q-time__clock-position row flex-center q-time__clock-pos-${I.index}` + (I.val === V ? " q-time__clock-position--active " + i.value : I.disable === !0 ? " q-time__clock-position--disable" : "")
                  }, [v("span", I.label)]))
                ])
              ]),
              de.value
            )
          ])
        ])),
        e.nowBtn === !0 ? v(Te, {
          class: "q-time__now-button absolute",
          icon: a.iconSet.datetime.now,
          unelevated: !0,
          size: "sm",
          round: !0,
          color: e.color,
          textColor: e.textColor,
          tabindex: r.value,
          onClick: q
        }) : null
      ]);
    }
    return l.proxy.setNow = q, () => {
      const V = [lt()], I = We(t.default);
      return I !== void 0 && V.push(
        v("div", { class: "q-time__actions" }, I)
      ), e.name !== void 0 && e.disable !== !0 && f(V, "push"), v("div", {
        class: F.value,
        tabindex: -1
      }, [
        Pt(),
        v("div", { class: "q-time__main col overflow-auto" }, V)
      ]);
    };
  }
}), Ql = Ce({
  name: "QPopupProxy",
  props: {
    ...Nr,
    breakpoint: {
      type: [String, Number],
      default: 450
    }
  },
  emits: ["show", "hide"],
  setup(e, { slots: t, emit: n, attrs: l }) {
    const { proxy: a } = we(), { $q: o } = a, r = J(!1), i = J(null), c = d(() => parseInt(e.breakpoint, 10)), { canShow: s } = zr({ showing: r });
    function u() {
      return o.screen.width < c.value || o.screen.height < c.value ? "dialog" : "menu";
    }
    const f = J(u()), S = d(
      () => f.value === "menu" ? { maxHeight: "99vh" } : {}
    );
    ce(() => u(), (x) => {
      r.value !== !0 && (f.value = x);
    });
    function b(x) {
      r.value = !0, n("show", x);
    }
    function h(x) {
      r.value = !1, f.value = u(), n("hide", x);
    }
    return Object.assign(a, {
      show(x) {
        s(x) === !0 && i.value.show(x);
      },
      hide(x) {
        i.value.hide(x);
      },
      toggle(x) {
        i.value.toggle(x);
      }
    }), _t(a, "currentComponent", () => ({
      type: f.value,
      ref: i.value
    })), () => {
      const x = {
        ref: i,
        ...S.value,
        ...l,
        onShow: b,
        onHide: h
      };
      let g;
      return f.value === "dialog" ? g = kl : (g = Yr, Object.assign(x, {
        target: e.target,
        contextMenu: e.contextMenu,
        noParentEvent: !0,
        separateClosePopup: !0
      })), v(g, x, t.default);
    };
  }
}), Bc = () => v("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  v("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  v("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]), Vc = Ce({
  name: "QRadio",
  props: {
    ...rt,
    ..._n,
    ...qn,
    modelValue: { required: !0 },
    val: { required: !0 },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(e, { slots: t, emit: n }) {
    const { proxy: l } = we(), a = it(e, l.$q), o = Cn(e, Wr), r = J(null), { refocusTargetEl: i, refocusTarget: c } = Kr(e, r), s = d(() => Yt(e.modelValue) === Yt(e.val)), u = d(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (e.disable === !0 ? " disabled" : "") + (a.value === !0 ? " q-radio--dark" : "") + (e.dense === !0 ? " q-radio--dense" : "") + (e.leftLabel === !0 ? " reverse" : "")
    ), f = d(() => {
      const y = e.color !== void 0 && (e.keepColor === !0 || s.value === !0) ? ` text-${e.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${s.value === !0 ? "truthy" : "falsy"}${y}`;
    }), S = d(
      () => (s.value === !0 ? e.checkedIcon : e.uncheckedIcon) || null
    ), b = d(() => e.disable === !0 ? -1 : e.tabindex || 0), h = d(() => {
      const y = { type: "radio" };
      return e.name !== void 0 && Object.assign(y, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        ".checked": s.value === !0,
        "^checked": s.value === !0 ? "checked" : void 0,
        name: e.name,
        value: e.val
      }), y;
    }), x = _l(h);
    function g(y) {
      y !== void 0 && (Fe(y), c(y)), e.disable !== !0 && s.value !== !0 && n("update:modelValue", e.val, y);
    }
    function T(y) {
      (y.keyCode === 13 || y.keyCode === 32) && Fe(y);
    }
    function P(y) {
      (y.keyCode === 13 || y.keyCode === 32) && g(y);
    }
    Object.assign(l, { set: g });
    const _ = Bc();
    return () => {
      const y = S.value !== null ? [
        v("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          v(pt, {
            class: "q-radio__icon",
            name: S.value
          })
        ])
      ] : [_];
      e.disable !== !0 && x(
        y,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const p = [
        v("div", {
          class: f.value,
          style: o.value,
          "aria-hidden": "true"
        }, y)
      ];
      i.value !== null && p.push(i.value);
      const F = e.label !== void 0 ? Vt(t.default, [e.label]) : We(t.default);
      return F !== void 0 && p.push(
        v("div", {
          class: "q-radio__label q-anchor--skip"
        }, F)
      ), v("div", {
        ref: r,
        class: u.value,
        tabindex: b.value,
        role: "radio",
        "aria-label": e.label,
        "aria-checked": s.value === !0 ? "true" : "false",
        "aria-disabled": e.disable === !0 ? "true" : void 0,
        onClick: g,
        onKeydown: T,
        onKeyup: P
      }, p);
    };
  }
}), Ac = Ce({
  name: "QToggle",
  props: {
    ...Qr,
    icon: String,
    iconColor: String
  },
  emits: Xr,
  setup(e) {
    function t(n, l) {
      const a = d(
        () => (n.value === !0 ? e.checkedIcon : l.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || e.icon
      ), o = d(() => n.value === !0 ? e.iconColor : null);
      return () => [
        v("div", { class: "q-toggle__track" }),
        v(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          a.value !== void 0 ? [
            v(pt, {
              name: a.value,
              color: o.value
            })
          ] : void 0
        )
      ];
    }
    return Jr("toggle", t);
  }
}), ui = {
  radio: Vc,
  checkbox: Fn,
  toggle: Ac
}, Dc = Object.keys(ui);
function Xl(e, t) {
  if (typeof e == "function") return e;
  const n = e !== void 0 ? e : t;
  return (l) => l[n];
}
const Vo = Ce({
  name: "QOptionGroup",
  props: {
    ...rt,
    modelValue: {
      required: !0
    },
    options: {
      type: Array,
      validator: (e) => e.every(qa),
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    name: String,
    type: {
      type: String,
      default: "radio",
      validator: (e) => Dc.includes(e)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t, slots: n }) {
    const { proxy: { $q: l } } = we(), a = Array.isArray(e.modelValue);
    e.type === "radio" ? a === !0 && console.error("q-option-group: model should not be array") : a === !1 && console.error("q-option-group: model should be array in your case");
    const o = it(e, l), r = d(() => ui[e.type]), i = d(() => Xl(e.optionValue, "value")), c = d(() => Xl(e.optionLabel, "label")), s = d(() => Xl(e.optionDisable, "disable")), u = d(() => e.options.map((h) => ({
      val: i.value(h),
      name: h.name === void 0 ? e.name : h.name,
      disable: e.disable || s.value(h),
      leftLabel: h.leftLabel === void 0 ? e.leftLabel : h.leftLabel,
      color: h.color === void 0 ? e.color : h.color,
      checkedIcon: h.checkedIcon,
      uncheckedIcon: h.uncheckedIcon,
      dark: h.dark === void 0 ? o.value : h.dark,
      size: h.size === void 0 ? e.size : h.size,
      dense: e.dense,
      keepColor: h.keepColor === void 0 ? e.keepColor : h.keepColor
    }))), f = d(
      () => "q-option-group q-gutter-x-sm" + (e.inline === !0 ? " q-option-group--inline" : "")
    ), S = d(() => {
      const h = { role: "group" };
      return e.type === "radio" && (h.role = "radiogroup", e.disable === !0 && (h["aria-disabled"] = "true")), h;
    });
    function b(h) {
      t("update:modelValue", h);
    }
    return () => v("div", {
      class: f.value,
      ...S.value
    }, e.options.map((h, x) => {
      const g = n["label-" + x] !== void 0 ? () => n["label-" + x](h) : n.label !== void 0 ? () => n.label(h) : void 0;
      return v("div", [
        v(r.value, {
          label: g === void 0 ? c.value(h) : null,
          modelValue: e.modelValue,
          "onUpdate:modelValue": b,
          ...u.value[x]
        }, g)
      ]);
    }));
  }
});
function si(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: Lc } = Object.prototype, { getPrototypeOf: Ra } = Object, Cl = /* @__PURE__ */ ((e) => (t) => {
  const n = Lc.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Rt = (e) => (e = e.toLowerCase(), (t) => Cl(t) === e), ql = (e) => (t) => typeof t === e, { isArray: En } = Array, jn = ql("undefined");
function Fc(e) {
  return e !== null && !jn(e) && e.constructor !== null && !jn(e.constructor) && St(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const ci = Rt("ArrayBuffer");
function $c(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && ci(e.buffer), t;
}
const Hc = ql("string"), St = ql("function"), di = ql("number"), El = (e) => e !== null && typeof e == "object", Ic = (e) => e === !0 || e === !1, rl = (e) => {
  if (Cl(e) !== "object")
    return !1;
  const t = Ra(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, jc = Rt("Date"), Nc = Rt("File"), zc = Rt("Blob"), Uc = Rt("FileList"), Yc = (e) => El(e) && St(e.pipe), Kc = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || St(e.append) && ((t = Cl(e)) === "formdata" || // detect form-data instance
  t === "object" && St(e.toString) && e.toString() === "[object FormData]"));
}, Wc = Rt("URLSearchParams"), [Qc, Xc, Jc, Zc] = ["ReadableStream", "Request", "Response", "Headers"].map(Rt), Gc = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Yn(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let l, a;
  if (typeof e != "object" && (e = [e]), En(e))
    for (l = 0, a = e.length; l < a; l++)
      t.call(null, e[l], l, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), r = o.length;
    let i;
    for (l = 0; l < r; l++)
      i = o[l], t.call(null, e[i], i, e);
  }
}
function fi(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let l = n.length, a;
  for (; l-- > 0; )
    if (a = n[l], t === a.toLowerCase())
      return a;
  return null;
}
const ln = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, mi = (e) => !jn(e) && e !== ln;
function ma() {
  const { caseless: e } = mi(this) && this || {}, t = {}, n = (l, a) => {
    const o = e && fi(t, a) || a;
    rl(t[o]) && rl(l) ? t[o] = ma(t[o], l) : rl(l) ? t[o] = ma({}, l) : En(l) ? t[o] = l.slice() : t[o] = l;
  };
  for (let l = 0, a = arguments.length; l < a; l++)
    arguments[l] && Yn(arguments[l], n);
  return t;
}
const ed = (e, t, n, { allOwnKeys: l } = {}) => (Yn(t, (a, o) => {
  n && St(a) ? e[o] = si(a, n) : e[o] = a;
}, { allOwnKeys: l }), e), td = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), nd = (e, t, n, l) => {
  e.prototype = Object.create(t.prototype, l), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, ld = (e, t, n, l) => {
  let a, o, r;
  const i = {};
  if (t = t || {}, e == null) return t;
  do {
    for (a = Object.getOwnPropertyNames(e), o = a.length; o-- > 0; )
      r = a[o], (!l || l(r, e, t)) && !i[r] && (t[r] = e[r], i[r] = !0);
    e = n !== !1 && Ra(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, ad = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const l = e.indexOf(t, n);
  return l !== -1 && l === n;
}, od = (e) => {
  if (!e) return null;
  if (En(e)) return e;
  let t = e.length;
  if (!di(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, rd = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Ra(Uint8Array)), id = (e, t) => {
  const l = (e && e[Symbol.iterator]).call(e);
  let a;
  for (; (a = l.next()) && !a.done; ) {
    const o = a.value;
    t.call(e, o[0], o[1]);
  }
}, ud = (e, t) => {
  let n;
  const l = [];
  for (; (n = e.exec(t)) !== null; )
    l.push(n);
  return l;
}, sd = Rt("HTMLFormElement"), cd = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, l, a) {
    return l.toUpperCase() + a;
  }
), Ao = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), dd = Rt("RegExp"), vi = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), l = {};
  Yn(n, (a, o) => {
    let r;
    (r = t(a, o, e)) !== !1 && (l[o] = r || a);
  }), Object.defineProperties(e, l);
}, fd = (e) => {
  vi(e, (t, n) => {
    if (St(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const l = e[n];
    if (St(l)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, md = (e, t) => {
  const n = {}, l = (a) => {
    a.forEach((o) => {
      n[o] = !0;
    });
  };
  return En(e) ? l(e) : l(String(e).split(t)), n;
}, vd = () => {
}, hd = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, Jl = "abcdefghijklmnopqrstuvwxyz", Do = "0123456789", hi = {
  DIGIT: Do,
  ALPHA: Jl,
  ALPHA_DIGIT: Jl + Jl.toUpperCase() + Do
}, gd = (e = 16, t = hi.ALPHA_DIGIT) => {
  let n = "";
  const { length: l } = t;
  for (; e--; )
    n += t[Math.random() * l | 0];
  return n;
};
function bd(e) {
  return !!(e && St(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const yd = (e) => {
  const t = new Array(10), n = (l, a) => {
    if (El(l)) {
      if (t.indexOf(l) >= 0)
        return;
      if (!("toJSON" in l)) {
        t[a] = l;
        const o = En(l) ? [] : {};
        return Yn(l, (r, i) => {
          const c = n(r, a + 1);
          !jn(c) && (o[i] = c);
        }), t[a] = void 0, o;
      }
    }
    return l;
  };
  return n(e, 0);
}, pd = Rt("AsyncFunction"), Sd = (e) => e && (El(e) || St(e)) && St(e.then) && St(e.catch), gi = ((e, t) => e ? setImmediate : t ? ((n, l) => (ln.addEventListener("message", ({ source: a, data: o }) => {
  a === ln && o === n && l.length && l.shift()();
}, !1), (a) => {
  l.push(a), ln.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  St(ln.postMessage)
), wd = typeof queueMicrotask < "u" ? queueMicrotask.bind(ln) : typeof process < "u" && process.nextTick || gi, O = {
  isArray: En,
  isArrayBuffer: ci,
  isBuffer: Fc,
  isFormData: Kc,
  isArrayBufferView: $c,
  isString: Hc,
  isNumber: di,
  isBoolean: Ic,
  isObject: El,
  isPlainObject: rl,
  isReadableStream: Qc,
  isRequest: Xc,
  isResponse: Jc,
  isHeaders: Zc,
  isUndefined: jn,
  isDate: jc,
  isFile: Nc,
  isBlob: zc,
  isRegExp: dd,
  isFunction: St,
  isStream: Yc,
  isURLSearchParams: Wc,
  isTypedArray: rd,
  isFileList: Uc,
  forEach: Yn,
  merge: ma,
  extend: ed,
  trim: Gc,
  stripBOM: td,
  inherits: nd,
  toFlatObject: ld,
  kindOf: Cl,
  kindOfTest: Rt,
  endsWith: ad,
  toArray: od,
  forEachEntry: id,
  matchAll: ud,
  isHTMLForm: sd,
  hasOwnProperty: Ao,
  hasOwnProp: Ao,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: vi,
  freezeMethods: fd,
  toObjectSet: md,
  toCamelCase: cd,
  noop: vd,
  toFiniteNumber: hd,
  findKey: fi,
  global: ln,
  isContextDefined: mi,
  ALPHABET: hi,
  generateString: gd,
  isSpecCompliantForm: bd,
  toJSONObject: yd,
  isAsyncFn: pd,
  isThenable: Sd,
  setImmediate: gi,
  asap: wd
};
function ve(e, t, n, l, a) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), l && (this.request = l), a && (this.response = a, this.status = a.status ? a.status : null);
}
O.inherits(ve, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: O.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const bi = ve.prototype, yi = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  yi[e] = { value: e };
});
Object.defineProperties(ve, yi);
Object.defineProperty(bi, "isAxiosError", { value: !0 });
ve.from = (e, t, n, l, a, o) => {
  const r = Object.create(bi);
  return O.toFlatObject(e, r, function(c) {
    return c !== Error.prototype;
  }, (i) => i !== "isAxiosError"), ve.call(r, e.message, t, n, l, a), r.cause = e, r.name = e.name, o && Object.assign(r, o), r;
};
const kd = null;
function va(e) {
  return O.isPlainObject(e) || O.isArray(e);
}
function pi(e) {
  return O.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Lo(e, t, n) {
  return e ? e.concat(t).map(function(a, o) {
    return a = pi(a), !n && o ? "[" + a + "]" : a;
  }).join(n ? "." : "") : t;
}
function xd(e) {
  return O.isArray(e) && !e.some(va);
}
const _d = O.toFlatObject(O, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Ml(e, t, n) {
  if (!O.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = O.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(x, g) {
    return !O.isUndefined(g[x]);
  });
  const l = n.metaTokens, a = n.visitor || u, o = n.dots, r = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && O.isSpecCompliantForm(t);
  if (!O.isFunction(a))
    throw new TypeError("visitor must be a function");
  function s(h) {
    if (h === null) return "";
    if (O.isDate(h))
      return h.toISOString();
    if (!c && O.isBlob(h))
      throw new ve("Blob is not supported. Use a Buffer instead.");
    return O.isArrayBuffer(h) || O.isTypedArray(h) ? c && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, x, g) {
    let T = h;
    if (h && !g && typeof h == "object") {
      if (O.endsWith(x, "{}"))
        x = l ? x : x.slice(0, -2), h = JSON.stringify(h);
      else if (O.isArray(h) && xd(h) || (O.isFileList(h) || O.endsWith(x, "[]")) && (T = O.toArray(h)))
        return x = pi(x), T.forEach(function(_, y) {
          !(O.isUndefined(_) || _ === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            r === !0 ? Lo([x], y, o) : r === null ? x : x + "[]",
            s(_)
          );
        }), !1;
    }
    return va(h) ? !0 : (t.append(Lo(g, x, o), s(h)), !1);
  }
  const f = [], S = Object.assign(_d, {
    defaultVisitor: u,
    convertValue: s,
    isVisitable: va
  });
  function b(h, x) {
    if (!O.isUndefined(h)) {
      if (f.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + x.join("."));
      f.push(h), O.forEach(h, function(T, P) {
        (!(O.isUndefined(T) || T === null) && a.call(
          t,
          T,
          O.isString(P) ? P.trim() : P,
          x,
          S
        )) === !0 && b(T, x ? x.concat(P) : [P]);
      }), f.pop();
    }
  }
  if (!O.isObject(e))
    throw new TypeError("data must be an object");
  return b(e), t;
}
function Fo(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(l) {
    return t[l];
  });
}
function Ta(e, t) {
  this._pairs = [], e && Ml(e, this, t);
}
const Si = Ta.prototype;
Si.append = function(t, n) {
  this._pairs.push([t, n]);
};
Si.toString = function(t) {
  const n = t ? function(l) {
    return t.call(this, l, Fo);
  } : Fo;
  return this._pairs.map(function(a) {
    return n(a[0]) + "=" + n(a[1]);
  }, "").join("&");
};
function Cd(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function wi(e, t, n) {
  if (!t)
    return e;
  const l = n && n.encode || Cd;
  O.isFunction(n) && (n = {
    serialize: n
  });
  const a = n && n.serialize;
  let o;
  if (a ? o = a(t, n) : o = O.isURLSearchParams(t) ? t.toString() : new Ta(t, n).toString(l), o) {
    const r = e.indexOf("#");
    r !== -1 && (e = e.slice(0, r)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class $o {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, l) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: l ? l.synchronous : !1,
      runWhen: l ? l.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    O.forEach(this.handlers, function(l) {
      l !== null && t(l);
    });
  }
}
const ki = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, qd = typeof URLSearchParams < "u" ? URLSearchParams : Ta, Ed = typeof FormData < "u" ? FormData : null, Md = typeof Blob < "u" ? Blob : null, Rd = {
  isBrowser: !0,
  classes: {
    URLSearchParams: qd,
    FormData: Ed,
    Blob: Md
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Pa = typeof window < "u" && typeof document < "u", ha = typeof navigator == "object" && navigator || void 0, Td = Pa && (!ha || ["ReactNative", "NativeScript", "NS"].indexOf(ha.product) < 0), Pd = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Od = Pa && window.location.href || "http://localhost", Bd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Pa,
  hasStandardBrowserEnv: Td,
  hasStandardBrowserWebWorkerEnv: Pd,
  navigator: ha,
  origin: Od
}, Symbol.toStringTag, { value: "Module" })), at = {
  ...Bd,
  ...Rd
};
function Vd(e, t) {
  return Ml(e, new at.classes.URLSearchParams(), Object.assign({
    visitor: function(n, l, a, o) {
      return at.isNode && O.isBuffer(n) ? (this.append(l, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Ad(e) {
  return O.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Dd(e) {
  const t = {}, n = Object.keys(e);
  let l;
  const a = n.length;
  let o;
  for (l = 0; l < a; l++)
    o = n[l], t[o] = e[o];
  return t;
}
function xi(e) {
  function t(n, l, a, o) {
    let r = n[o++];
    if (r === "__proto__") return !0;
    const i = Number.isFinite(+r), c = o >= n.length;
    return r = !r && O.isArray(a) ? a.length : r, c ? (O.hasOwnProp(a, r) ? a[r] = [a[r], l] : a[r] = l, !i) : ((!a[r] || !O.isObject(a[r])) && (a[r] = []), t(n, l, a[r], o) && O.isArray(a[r]) && (a[r] = Dd(a[r])), !i);
  }
  if (O.isFormData(e) && O.isFunction(e.entries)) {
    const n = {};
    return O.forEachEntry(e, (l, a) => {
      t(Ad(l), a, n, 0);
    }), n;
  }
  return null;
}
function Ld(e, t, n) {
  if (O.isString(e))
    try {
      return (t || JSON.parse)(e), O.trim(e);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (0, JSON.stringify)(e);
}
const Kn = {
  transitional: ki,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const l = n.getContentType() || "", a = l.indexOf("application/json") > -1, o = O.isObject(t);
    if (o && O.isHTMLForm(t) && (t = new FormData(t)), O.isFormData(t))
      return a ? JSON.stringify(xi(t)) : t;
    if (O.isArrayBuffer(t) || O.isBuffer(t) || O.isStream(t) || O.isFile(t) || O.isBlob(t) || O.isReadableStream(t))
      return t;
    if (O.isArrayBufferView(t))
      return t.buffer;
    if (O.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let i;
    if (o) {
      if (l.indexOf("application/x-www-form-urlencoded") > -1)
        return Vd(t, this.formSerializer).toString();
      if ((i = O.isFileList(t)) || l.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Ml(
          i ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return o || a ? (n.setContentType("application/json", !1), Ld(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Kn.transitional, l = n && n.forcedJSONParsing, a = this.responseType === "json";
    if (O.isResponse(t) || O.isReadableStream(t))
      return t;
    if (t && O.isString(t) && (l && !this.responseType || a)) {
      const r = !(n && n.silentJSONParsing) && a;
      try {
        return JSON.parse(t);
      } catch (i) {
        if (r)
          throw i.name === "SyntaxError" ? ve.from(i, ve.ERR_BAD_RESPONSE, this, null, this.response) : i;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: at.classes.FormData,
    Blob: at.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
O.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Kn.headers[e] = {};
});
const Fd = O.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), $d = (e) => {
  const t = {};
  let n, l, a;
  return e && e.split(`
`).forEach(function(r) {
    a = r.indexOf(":"), n = r.substring(0, a).trim().toLowerCase(), l = r.substring(a + 1).trim(), !(!n || t[n] && Fd[n]) && (n === "set-cookie" ? t[n] ? t[n].push(l) : t[n] = [l] : t[n] = t[n] ? t[n] + ", " + l : l);
  }), t;
}, Ho = Symbol("internals");
function Bn(e) {
  return e && String(e).trim().toLowerCase();
}
function il(e) {
  return e === !1 || e == null ? e : O.isArray(e) ? e.map(il) : String(e);
}
function Hd(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let l;
  for (; l = n.exec(e); )
    t[l[1]] = l[2];
  return t;
}
const Id = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Zl(e, t, n, l, a) {
  if (O.isFunction(l))
    return l.call(this, t, n);
  if (a && (t = n), !!O.isString(t)) {
    if (O.isString(l))
      return t.indexOf(l) !== -1;
    if (O.isRegExp(l))
      return l.test(t);
  }
}
function jd(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, l) => n.toUpperCase() + l);
}
function Nd(e, t) {
  const n = O.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((l) => {
    Object.defineProperty(e, l + n, {
      value: function(a, o, r) {
        return this[l].call(this, t, a, o, r);
      },
      configurable: !0
    });
  });
}
class vt {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, l) {
    const a = this;
    function o(i, c, s) {
      const u = Bn(c);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const f = O.findKey(a, u);
      (!f || a[f] === void 0 || s === !0 || s === void 0 && a[f] !== !1) && (a[f || c] = il(i));
    }
    const r = (i, c) => O.forEach(i, (s, u) => o(s, u, c));
    if (O.isPlainObject(t) || t instanceof this.constructor)
      r(t, n);
    else if (O.isString(t) && (t = t.trim()) && !Id(t))
      r($d(t), n);
    else if (O.isHeaders(t))
      for (const [i, c] of t.entries())
        o(c, i, l);
    else
      t != null && o(n, t, l);
    return this;
  }
  get(t, n) {
    if (t = Bn(t), t) {
      const l = O.findKey(this, t);
      if (l) {
        const a = this[l];
        if (!n)
          return a;
        if (n === !0)
          return Hd(a);
        if (O.isFunction(n))
          return n.call(this, a, l);
        if (O.isRegExp(n))
          return n.exec(a);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Bn(t), t) {
      const l = O.findKey(this, t);
      return !!(l && this[l] !== void 0 && (!n || Zl(this, this[l], l, n)));
    }
    return !1;
  }
  delete(t, n) {
    const l = this;
    let a = !1;
    function o(r) {
      if (r = Bn(r), r) {
        const i = O.findKey(l, r);
        i && (!n || Zl(l, l[i], i, n)) && (delete l[i], a = !0);
      }
    }
    return O.isArray(t) ? t.forEach(o) : o(t), a;
  }
  clear(t) {
    const n = Object.keys(this);
    let l = n.length, a = !1;
    for (; l--; ) {
      const o = n[l];
      (!t || Zl(this, this[o], o, t, !0)) && (delete this[o], a = !0);
    }
    return a;
  }
  normalize(t) {
    const n = this, l = {};
    return O.forEach(this, (a, o) => {
      const r = O.findKey(l, o);
      if (r) {
        n[r] = il(a), delete n[o];
        return;
      }
      const i = t ? jd(o) : String(o).trim();
      i !== o && delete n[o], n[i] = il(a), l[i] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return O.forEach(this, (l, a) => {
      l != null && l !== !1 && (n[a] = t && O.isArray(l) ? l.join(", ") : l);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const l = new this(t);
    return n.forEach((a) => l.set(a)), l;
  }
  static accessor(t) {
    const l = (this[Ho] = this[Ho] = {
      accessors: {}
    }).accessors, a = this.prototype;
    function o(r) {
      const i = Bn(r);
      l[i] || (Nd(a, r), l[i] = !0);
    }
    return O.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
vt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
O.reduceDescriptors(vt.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(l) {
      this[n] = l;
    }
  };
});
O.freezeMethods(vt);
function Gl(e, t) {
  const n = this || Kn, l = t || n, a = vt.from(l.headers);
  let o = l.data;
  return O.forEach(e, function(i) {
    o = i.call(n, o, a.normalize(), t ? t.status : void 0);
  }), a.normalize(), o;
}
function _i(e) {
  return !!(e && e.__CANCEL__);
}
function Mn(e, t, n) {
  ve.call(this, e ?? "canceled", ve.ERR_CANCELED, t, n), this.name = "CanceledError";
}
O.inherits(Mn, ve, {
  __CANCEL__: !0
});
function Ci(e, t, n) {
  const l = n.config.validateStatus;
  !n.status || !l || l(n.status) ? e(n) : t(new ve(
    "Request failed with status code " + n.status,
    [ve.ERR_BAD_REQUEST, ve.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function zd(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function Ud(e, t) {
  e = e || 10;
  const n = new Array(e), l = new Array(e);
  let a = 0, o = 0, r;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const s = Date.now(), u = l[o];
    r || (r = s), n[a] = c, l[a] = s;
    let f = o, S = 0;
    for (; f !== a; )
      S += n[f++], f = f % e;
    if (a = (a + 1) % e, a === o && (o = (o + 1) % e), s - r < t)
      return;
    const b = u && s - u;
    return b ? Math.round(S * 1e3 / b) : void 0;
  };
}
function Yd(e, t) {
  let n = 0, l = 1e3 / t, a, o;
  const r = (s, u = Date.now()) => {
    n = u, a = null, o && (clearTimeout(o), o = null), e.apply(null, s);
  };
  return [(...s) => {
    const u = Date.now(), f = u - n;
    f >= l ? r(s, u) : (a = s, o || (o = setTimeout(() => {
      o = null, r(a);
    }, l - f)));
  }, () => a && r(a)];
}
const bl = (e, t, n = 3) => {
  let l = 0;
  const a = Ud(50, 250);
  return Yd((o) => {
    const r = o.loaded, i = o.lengthComputable ? o.total : void 0, c = r - l, s = a(c), u = r <= i;
    l = r;
    const f = {
      loaded: r,
      total: i,
      progress: i ? r / i : void 0,
      bytes: c,
      rate: s || void 0,
      estimated: s && i && u ? (i - r) / s : void 0,
      event: o,
      lengthComputable: i != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, n);
}, Io = (e, t) => {
  const n = e != null;
  return [(l) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: l
  }), t[1]];
}, jo = (e) => (...t) => O.asap(() => e(...t)), Kd = at.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, at.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(at.origin),
  at.navigator && /(msie|trident)/i.test(at.navigator.userAgent)
) : () => !0, Wd = at.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, l, a, o) {
      const r = [e + "=" + encodeURIComponent(t)];
      O.isNumber(n) && r.push("expires=" + new Date(n).toGMTString()), O.isString(l) && r.push("path=" + l), O.isString(a) && r.push("domain=" + a), o === !0 && r.push("secure"), document.cookie = r.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function Qd(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Xd(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function qi(e, t) {
  return e && !Qd(t) ? Xd(e, t) : t;
}
const No = (e) => e instanceof vt ? { ...e } : e;
function cn(e, t) {
  t = t || {};
  const n = {};
  function l(s, u, f, S) {
    return O.isPlainObject(s) && O.isPlainObject(u) ? O.merge.call({ caseless: S }, s, u) : O.isPlainObject(u) ? O.merge({}, u) : O.isArray(u) ? u.slice() : u;
  }
  function a(s, u, f, S) {
    if (O.isUndefined(u)) {
      if (!O.isUndefined(s))
        return l(void 0, s, f, S);
    } else return l(s, u, f, S);
  }
  function o(s, u) {
    if (!O.isUndefined(u))
      return l(void 0, u);
  }
  function r(s, u) {
    if (O.isUndefined(u)) {
      if (!O.isUndefined(s))
        return l(void 0, s);
    } else return l(void 0, u);
  }
  function i(s, u, f) {
    if (f in t)
      return l(s, u);
    if (f in e)
      return l(void 0, s);
  }
  const c = {
    url: o,
    method: o,
    data: o,
    baseURL: r,
    transformRequest: r,
    transformResponse: r,
    paramsSerializer: r,
    timeout: r,
    timeoutMessage: r,
    withCredentials: r,
    withXSRFToken: r,
    adapter: r,
    responseType: r,
    xsrfCookieName: r,
    xsrfHeaderName: r,
    onUploadProgress: r,
    onDownloadProgress: r,
    decompress: r,
    maxContentLength: r,
    maxBodyLength: r,
    beforeRedirect: r,
    transport: r,
    httpAgent: r,
    httpsAgent: r,
    cancelToken: r,
    socketPath: r,
    responseEncoding: r,
    validateStatus: i,
    headers: (s, u, f) => a(No(s), No(u), f, !0)
  };
  return O.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const f = c[u] || a, S = f(e[u], t[u], u);
    O.isUndefined(S) && f !== i || (n[u] = S);
  }), n;
}
const Ei = (e) => {
  const t = cn({}, e);
  let { data: n, withXSRFToken: l, xsrfHeaderName: a, xsrfCookieName: o, headers: r, auth: i } = t;
  t.headers = r = vt.from(r), t.url = wi(qi(t.baseURL, t.url), e.params, e.paramsSerializer), i && r.set(
    "Authorization",
    "Basic " + btoa((i.username || "") + ":" + (i.password ? unescape(encodeURIComponent(i.password)) : ""))
  );
  let c;
  if (O.isFormData(n)) {
    if (at.hasStandardBrowserEnv || at.hasStandardBrowserWebWorkerEnv)
      r.setContentType(void 0);
    else if ((c = r.getContentType()) !== !1) {
      const [s, ...u] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
      r.setContentType([s || "multipart/form-data", ...u].join("; "));
    }
  }
  if (at.hasStandardBrowserEnv && (l && O.isFunction(l) && (l = l(t)), l || l !== !1 && Kd(t.url))) {
    const s = a && o && Wd.read(o);
    s && r.set(a, s);
  }
  return t;
}, Jd = typeof XMLHttpRequest < "u", Zd = Jd && function(e) {
  return new Promise(function(n, l) {
    const a = Ei(e);
    let o = a.data;
    const r = vt.from(a.headers).normalize();
    let { responseType: i, onUploadProgress: c, onDownloadProgress: s } = a, u, f, S, b, h;
    function x() {
      b && b(), h && h(), a.cancelToken && a.cancelToken.unsubscribe(u), a.signal && a.signal.removeEventListener("abort", u);
    }
    let g = new XMLHttpRequest();
    g.open(a.method.toUpperCase(), a.url, !0), g.timeout = a.timeout;
    function T() {
      if (!g)
        return;
      const _ = vt.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), p = {
        data: !i || i === "text" || i === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: _,
        config: e,
        request: g
      };
      Ci(function(A) {
        n(A), x();
      }, function(A) {
        l(A), x();
      }, p), g = null;
    }
    "onloadend" in g ? g.onloadend = T : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(T);
    }, g.onabort = function() {
      g && (l(new ve("Request aborted", ve.ECONNABORTED, e, g)), g = null);
    }, g.onerror = function() {
      l(new ve("Network Error", ve.ERR_NETWORK, e, g)), g = null;
    }, g.ontimeout = function() {
      let y = a.timeout ? "timeout of " + a.timeout + "ms exceeded" : "timeout exceeded";
      const p = a.transitional || ki;
      a.timeoutErrorMessage && (y = a.timeoutErrorMessage), l(new ve(
        y,
        p.clarifyTimeoutError ? ve.ETIMEDOUT : ve.ECONNABORTED,
        e,
        g
      )), g = null;
    }, o === void 0 && r.setContentType(null), "setRequestHeader" in g && O.forEach(r.toJSON(), function(y, p) {
      g.setRequestHeader(p, y);
    }), O.isUndefined(a.withCredentials) || (g.withCredentials = !!a.withCredentials), i && i !== "json" && (g.responseType = a.responseType), s && ([S, h] = bl(s, !0), g.addEventListener("progress", S)), c && g.upload && ([f, b] = bl(c), g.upload.addEventListener("progress", f), g.upload.addEventListener("loadend", b)), (a.cancelToken || a.signal) && (u = (_) => {
      g && (l(!_ || _.type ? new Mn(null, e, g) : _), g.abort(), g = null);
    }, a.cancelToken && a.cancelToken.subscribe(u), a.signal && (a.signal.aborted ? u() : a.signal.addEventListener("abort", u)));
    const P = zd(a.url);
    if (P && at.protocols.indexOf(P) === -1) {
      l(new ve("Unsupported protocol " + P + ":", ve.ERR_BAD_REQUEST, e));
      return;
    }
    g.send(o || null);
  });
}, Gd = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let l = new AbortController(), a;
    const o = function(s) {
      if (!a) {
        a = !0, i();
        const u = s instanceof Error ? s : this.reason;
        l.abort(u instanceof ve ? u : new Mn(u instanceof Error ? u.message : u));
      }
    };
    let r = t && setTimeout(() => {
      r = null, o(new ve(`timeout ${t} of ms exceeded`, ve.ETIMEDOUT));
    }, t);
    const i = () => {
      e && (r && clearTimeout(r), r = null, e.forEach((s) => {
        s.unsubscribe ? s.unsubscribe(o) : s.removeEventListener("abort", o);
      }), e = null);
    };
    e.forEach((s) => s.addEventListener("abort", o));
    const { signal: c } = l;
    return c.unsubscribe = () => O.asap(i), c;
  }
}, ef = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let l = 0, a;
  for (; l < n; )
    a = l + t, yield e.slice(l, a), l = a;
}, tf = async function* (e, t) {
  for await (const n of nf(e))
    yield* ef(n, t);
}, nf = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: l } = await t.read();
      if (n)
        break;
      yield l;
    }
  } finally {
    await t.cancel();
  }
}, zo = (e, t, n, l) => {
  const a = tf(e, t);
  let o = 0, r, i = (c) => {
    r || (r = !0, l && l(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: s, value: u } = await a.next();
        if (s) {
          i(), c.close();
          return;
        }
        let f = u.byteLength;
        if (n) {
          let S = o += f;
          n(S);
        }
        c.enqueue(new Uint8Array(u));
      } catch (s) {
        throw i(s), s;
      }
    },
    cancel(c) {
      return i(c), a.return();
    }
  }, {
    highWaterMark: 2
  });
}, Rl = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Mi = Rl && typeof ReadableStream == "function", lf = Rl && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), Ri = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, af = Mi && Ri(() => {
  let e = !1;
  const t = new Request(at.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), Uo = 64 * 1024, ga = Mi && Ri(() => O.isReadableStream(new Response("").body)), yl = {
  stream: ga && ((e) => e.body)
};
Rl && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !yl[t] && (yl[t] = O.isFunction(e[t]) ? (n) => n[t]() : (n, l) => {
      throw new ve(`Response type '${t}' is not supported`, ve.ERR_NOT_SUPPORT, l);
    });
  });
})(new Response());
const of = async (e) => {
  if (e == null)
    return 0;
  if (O.isBlob(e))
    return e.size;
  if (O.isSpecCompliantForm(e))
    return (await new Request(at.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (O.isArrayBufferView(e) || O.isArrayBuffer(e))
    return e.byteLength;
  if (O.isURLSearchParams(e) && (e = e + ""), O.isString(e))
    return (await lf(e)).byteLength;
}, rf = async (e, t) => {
  const n = O.toFiniteNumber(e.getContentLength());
  return n ?? of(t);
}, uf = Rl && (async (e) => {
  let {
    url: t,
    method: n,
    data: l,
    signal: a,
    cancelToken: o,
    timeout: r,
    onDownloadProgress: i,
    onUploadProgress: c,
    responseType: s,
    headers: u,
    withCredentials: f = "same-origin",
    fetchOptions: S
  } = Ei(e);
  s = s ? (s + "").toLowerCase() : "text";
  let b = Gd([a, o && o.toAbortSignal()], r), h;
  const x = b && b.unsubscribe && (() => {
    b.unsubscribe();
  });
  let g;
  try {
    if (c && af && n !== "get" && n !== "head" && (g = await rf(u, l)) !== 0) {
      let p = new Request(t, {
        method: "POST",
        body: l,
        duplex: "half"
      }), F;
      if (O.isFormData(l) && (F = p.headers.get("content-type")) && u.setContentType(F), p.body) {
        const [A, U] = Io(
          g,
          bl(jo(c))
        );
        l = zo(p.body, Uo, A, U);
      }
    }
    O.isString(f) || (f = f ? "include" : "omit");
    const T = "credentials" in Request.prototype;
    h = new Request(t, {
      ...S,
      signal: b,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: l,
      duplex: "half",
      credentials: T ? f : void 0
    });
    let P = await fetch(h);
    const _ = ga && (s === "stream" || s === "response");
    if (ga && (i || _ && x)) {
      const p = {};
      ["status", "statusText", "headers"].forEach((D) => {
        p[D] = P[D];
      });
      const F = O.toFiniteNumber(P.headers.get("content-length")), [A, U] = i && Io(
        F,
        bl(jo(i), !0)
      ) || [];
      P = new Response(
        zo(P.body, Uo, A, () => {
          U && U(), x && x();
        }),
        p
      );
    }
    s = s || "text";
    let y = await yl[O.findKey(yl, s) || "text"](P, e);
    return !_ && x && x(), await new Promise((p, F) => {
      Ci(p, F, {
        data: y,
        headers: vt.from(P.headers),
        status: P.status,
        statusText: P.statusText,
        config: e,
        request: h
      });
    });
  } catch (T) {
    throw x && x(), T && T.name === "TypeError" && /fetch/i.test(T.message) ? Object.assign(
      new ve("Network Error", ve.ERR_NETWORK, e, h),
      {
        cause: T.cause || T
      }
    ) : ve.from(T, T && T.code, e, h);
  }
}), ba = {
  http: kd,
  xhr: Zd,
  fetch: uf
};
O.forEach(ba, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Yo = (e) => `- ${e}`, sf = (e) => O.isFunction(e) || e === null || e === !1, Ti = {
  getAdapter: (e) => {
    e = O.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, l;
    const a = {};
    for (let o = 0; o < t; o++) {
      n = e[o];
      let r;
      if (l = n, !sf(n) && (l = ba[(r = String(n)).toLowerCase()], l === void 0))
        throw new ve(`Unknown adapter '${r}'`);
      if (l)
        break;
      a[r || "#" + o] = l;
    }
    if (!l) {
      const o = Object.entries(a).map(
        ([i, c]) => `adapter ${i} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let r = t ? o.length > 1 ? `since :
` + o.map(Yo).join(`
`) : " " + Yo(o[0]) : "as no adapter specified";
      throw new ve(
        "There is no suitable adapter to dispatch the request " + r,
        "ERR_NOT_SUPPORT"
      );
    }
    return l;
  },
  adapters: ba
};
function ea(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Mn(null, e);
}
function Ko(e) {
  return ea(e), e.headers = vt.from(e.headers), e.data = Gl.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Ti.getAdapter(e.adapter || Kn.adapter)(e).then(function(l) {
    return ea(e), l.data = Gl.call(
      e,
      e.transformResponse,
      l
    ), l.headers = vt.from(l.headers), l;
  }, function(l) {
    return _i(l) || (ea(e), l && l.response && (l.response.data = Gl.call(
      e,
      e.transformResponse,
      l.response
    ), l.response.headers = vt.from(l.response.headers))), Promise.reject(l);
  });
}
const Pi = "1.7.9", Tl = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Tl[e] = function(l) {
    return typeof l === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Wo = {};
Tl.transitional = function(t, n, l) {
  function a(o, r) {
    return "[Axios v" + Pi + "] Transitional option '" + o + "'" + r + (l ? ". " + l : "");
  }
  return (o, r, i) => {
    if (t === !1)
      throw new ve(
        a(r, " has been removed" + (n ? " in " + n : "")),
        ve.ERR_DEPRECATED
      );
    return n && !Wo[r] && (Wo[r] = !0, console.warn(
      a(
        r,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(o, r, i) : !0;
  };
};
Tl.spelling = function(t) {
  return (n, l) => (console.warn(`${l} is likely a misspelling of ${t}`), !0);
};
function cf(e, t, n) {
  if (typeof e != "object")
    throw new ve("options must be an object", ve.ERR_BAD_OPTION_VALUE);
  const l = Object.keys(e);
  let a = l.length;
  for (; a-- > 0; ) {
    const o = l[a], r = t[o];
    if (r) {
      const i = e[o], c = i === void 0 || r(i, o, e);
      if (c !== !0)
        throw new ve("option " + o + " must be " + c, ve.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new ve("Unknown option " + o, ve.ERR_BAD_OPTION);
  }
}
const ul = {
  assertOptions: cf,
  validators: Tl
}, Bt = ul.validators;
class sn {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new $o(),
      response: new $o()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (l) {
      if (l instanceof Error) {
        let a = {};
        Error.captureStackTrace ? Error.captureStackTrace(a) : a = new Error();
        const o = a.stack ? a.stack.replace(/^.+\n/, "") : "";
        try {
          l.stack ? o && !String(l.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (l.stack += `
` + o) : l.stack = o;
        } catch {
        }
      }
      throw l;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = cn(this.defaults, n);
    const { transitional: l, paramsSerializer: a, headers: o } = n;
    l !== void 0 && ul.assertOptions(l, {
      silentJSONParsing: Bt.transitional(Bt.boolean),
      forcedJSONParsing: Bt.transitional(Bt.boolean),
      clarifyTimeoutError: Bt.transitional(Bt.boolean)
    }, !1), a != null && (O.isFunction(a) ? n.paramsSerializer = {
      serialize: a
    } : ul.assertOptions(a, {
      encode: Bt.function,
      serialize: Bt.function
    }, !0)), ul.assertOptions(n, {
      baseUrl: Bt.spelling("baseURL"),
      withXsrfToken: Bt.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let r = o && O.merge(
      o.common,
      o[n.method]
    );
    o && O.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete o[h];
      }
    ), n.headers = vt.concat(r, o);
    const i = [];
    let c = !0;
    this.interceptors.request.forEach(function(x) {
      typeof x.runWhen == "function" && x.runWhen(n) === !1 || (c = c && x.synchronous, i.unshift(x.fulfilled, x.rejected));
    });
    const s = [];
    this.interceptors.response.forEach(function(x) {
      s.push(x.fulfilled, x.rejected);
    });
    let u, f = 0, S;
    if (!c) {
      const h = [Ko.bind(this), void 0];
      for (h.unshift.apply(h, i), h.push.apply(h, s), S = h.length, u = Promise.resolve(n); f < S; )
        u = u.then(h[f++], h[f++]);
      return u;
    }
    S = i.length;
    let b = n;
    for (f = 0; f < S; ) {
      const h = i[f++], x = i[f++];
      try {
        b = h(b);
      } catch (g) {
        x.call(this, g);
        break;
      }
    }
    try {
      u = Ko.call(this, b);
    } catch (h) {
      return Promise.reject(h);
    }
    for (f = 0, S = s.length; f < S; )
      u = u.then(s[f++], s[f++]);
    return u;
  }
  getUri(t) {
    t = cn(this.defaults, t);
    const n = qi(t.baseURL, t.url);
    return wi(n, t.params, t.paramsSerializer);
  }
}
O.forEach(["delete", "get", "head", "options"], function(t) {
  sn.prototype[t] = function(n, l) {
    return this.request(cn(l || {}, {
      method: t,
      url: n,
      data: (l || {}).data
    }));
  };
});
O.forEach(["post", "put", "patch"], function(t) {
  function n(l) {
    return function(o, r, i) {
      return this.request(cn(i || {}, {
        method: t,
        headers: l ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: r
      }));
    };
  }
  sn.prototype[t] = n(), sn.prototype[t + "Form"] = n(!0);
});
class Oa {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const l = this;
    this.promise.then((a) => {
      if (!l._listeners) return;
      let o = l._listeners.length;
      for (; o-- > 0; )
        l._listeners[o](a);
      l._listeners = null;
    }), this.promise.then = (a) => {
      let o;
      const r = new Promise((i) => {
        l.subscribe(i), o = i;
      }).then(a);
      return r.cancel = function() {
        l.unsubscribe(o);
      }, r;
    }, t(function(o, r, i) {
      l.reason || (l.reason = new Mn(o, r, i), n(l.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (l) => {
      t.abort(l);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Oa(function(a) {
        t = a;
      }),
      cancel: t
    };
  }
}
function df(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function ff(e) {
  return O.isObject(e) && e.isAxiosError === !0;
}
const ya = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(ya).forEach(([e, t]) => {
  ya[t] = e;
});
function Oi(e) {
  const t = new sn(e), n = si(sn.prototype.request, t);
  return O.extend(n, sn.prototype, t, { allOwnKeys: !0 }), O.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(a) {
    return Oi(cn(e, a));
  }, n;
}
const Ie = Oi(Kn);
Ie.Axios = sn;
Ie.CanceledError = Mn;
Ie.CancelToken = Oa;
Ie.isCancel = _i;
Ie.VERSION = Pi;
Ie.toFormData = Ml;
Ie.AxiosError = ve;
Ie.Cancel = Ie.CanceledError;
Ie.all = function(t) {
  return Promise.all(t);
};
Ie.spread = df;
Ie.isAxiosError = ff;
Ie.mergeConfig = cn;
Ie.AxiosHeaders = vt;
Ie.formToJSON = (e) => xi(O.isHTMLForm(e) ? new FormData(e) : e);
Ie.getAdapter = Ti.getAdapter;
Ie.HttpStatusCode = ya;
Ie.default = Ie;
const mf = { class: "flex flex-col flex-nowrap gap-2 w-full" }, vf = { class: "q-table__top relative-position row items-center w-full" }, hf = { class: "flex w-full items-center gap-2 justify-between" }, gf = { class: "q-table__title" }, bf = { class: "flex items-center gap-2" }, yf = { class: "w-full flex justify-center items-center" }, pf = { class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip" }, Sf = ["onClick"], wf = { class: "q-gutter-md row items-start" }, kf = { class: "row items-center justify-end q-gutter-sm" }, xf = { class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip" }, _f = ["onClick"], Cf = { class: "q-gutter-md row items-start" }, qf = { class: "row items-center justify-end q-gutter-sm" }, Ef = { class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip" }, Mf = ["onClick"], Rf = { class: "q-gutter-md row items-start" }, Tf = { class: "row items-center justify-end q-gutter-sm" }, Pf = { class: "font-bold" }, Of = { class: "font-bold" }, Df = /* @__PURE__ */ Nn({
  __name: "AnServerDataTable",
  props: {
    columns: {
      type: Object,
      required: !0
    },
    link: {
      type: String,
      required: !0
    },
    linkParams: {
      type: Object,
      default: {}
    },
    title: {
      type: String,
      default: ""
    },
    loading: {
      type: Boolean,
      default: !1
    },
    hidePagination: {
      type: Boolean,
      default: !1
    },
    flat: {
      type: Boolean,
      default: !1
    },
    square: {
      type: Boolean,
      default: !1
    },
    hasSearch: {
      type: Boolean,
      default: !1
    },
    hasFilter: {
      type: Boolean,
      default: !1
    },
    enableRowClick: {
      type: Boolean,
      default: !1
    },
    filterModalData: {
      type: Object,
      default: {
        fields: []
      }
    },
    axiosInterceptor: {
      type: Object,
      required: !1
    },
    paginationResponseKeys: {
      type: Object,
      default: {
        count: "count",
        lastPage: "lastPage",
        next: "next",
        previous: "previous",
        results: "results"
      }
    },
    orderingKey: {
      type: String,
      default: "ordering"
    }
  },
  emits: ["openFilter", "rowClick", "getDataSuccessfuly", "getDataError"],
  setup(e, { expose: t, emit: n }) {
    const l = J(), a = n, o = e, r = Jo(), i = (T) => T.replace("filter-modal-", ""), c = {
      descending: !1,
      page: 1,
      rowsPerPage: 10,
      sortBy: null,
      rowsNumber: 10
    }, s = kn({
      dataIsLoading: !1,
      tableIsLoading: !1,
      rows: {
        [o.paginationResponseKeys.results]: []
      },
      pagination: c,
      filter: {},
      ordering: void 0,
      search: "",
      searchIsLoading: !1,
      filterIsLoading: !1
    }), u = async () => {
      o.link && (s.ordering = S(), s.tableIsLoading = !0, await x({ pagination: { page: s.pagination.page }, filter: s.filter, ordering: s.ordering, search: s.search }).then((T) => {
        s.rows = T.data, a("getDataSuccessfuly", T.data);
      }).catch((T) => {
        a("getDataError", T);
      }).finally(() => {
        var T;
        s.tableIsLoading = !1, (T = l.value) == null || T.hide();
      }));
    }, f = (T) => {
      s.pagination = {
        ...s.pagination,
        ...T.pagination
      }, u();
    }, S = () => s.pagination.sortBy ? s.pagination.descending ? "-" + s.pagination.sortBy : s.pagination.sortBy : "", b = () => {
      s.searchIsLoading = !0, g({ search: s.search }).finally(() => {
        s.searchIsLoading = !1;
      });
    }, h = () => {
      s.filterIsLoading = !0, g(s.filter).then(() => {
        var T;
        s.filterIsLoading = !1, (T = l.value) == null || T.hide();
      });
    };
    zn(() => {
      s.dataIsLoading = !0, u().finally(() => {
        s.dataIsLoading = !1;
      });
    });
    const x = (T) => (o.axiosInterceptor || Ie).get(o.link, {
      params: {
        ...T == null ? void 0 : T.pagination,
        ...T == null ? void 0 : T.filter,
        [o.orderingKey]: T == null ? void 0 : T.ordering,
        ...o.linkParams
      }
    }), g = (T) => {
      let P = {};
      return Object.keys(T).forEach((_) => {
        P[_] = (T[_] || "").toString();
      }), s.filter = P, u().finally(() => {
        s.filter = T;
      });
    };
    return t({ filter: g, fetchData: u }), (T, P) => {
      var _, y;
      return Le(), Ft(Rn, null, [
        Ke("div", mf, [
          ke(vc, Qt({
            loading: o.loading || s.tableIsLoading,
            "hide-bottom": o.hidePagination,
            flat: o.flat,
            square: o.square,
            title: o.title,
            columns: o.columns,
            rows: s.rows[o.paginationResponseKeys.results],
            pagination: s.pagination,
            "onUpdate:pagination": P[3] || (P[3] = (p) => s.pagination = p),
            onRequest: f,
            "wrap-cells": "",
            class: "w-full"
          }, { onRowClick: o.enableRowClick ? (p, F, A) => {
            a("rowClick", F, A);
          } : void 0 }), ta({
            top: Me(() => [
              Ke("div", vf, [
                Ke("div", hf, [
                  Ke("div", gf, [
                    mt(T.$slots, "title", {}, () => [
                      $i(Dn(o.title), 1)
                    ])
                  ]),
                  Ke("div", bf, [
                    o.hasSearch ? mt(T.$slots, "search-input", {
                      key: 0,
                      loading: s.searchIsLoading,
                      value: s.search,
                      search: (p) => {
                        s.search = p, b();
                      }
                    }, () => [
                      o.hasSearch ? (Le(), st(en, {
                        key: 0,
                        label: "Search",
                        dense: "",
                        modelValue: s.search,
                        "onUpdate:modelValue": [
                          P[0] || (P[0] = (p) => s.search = p),
                          b
                        ],
                        clearable: "",
                        debounce: 500,
                        class: "!items-start",
                        outlined: "",
                        loading: s.searchIsLoading
                      }, null, 8, ["modelValue", "loading"])) : ze("", !0)
                    ]) : ze("", !0),
                    o.hasFilter ? mt(T.$slots, "filter-btn", {
                      key: 1,
                      label: "Filter",
                      color: "primary",
                      click: () => {
                        var p;
                        return (p = l.value) == null ? void 0 : p.show();
                      }
                    }, () => [
                      ke(Te, {
                        label: "Filter",
                        "no-caps": "",
                        color: "primary",
                        onClick: P[1] || (P[1] = (p) => {
                          var F;
                          return (F = l.value) == null ? void 0 : F.show();
                        })
                      })
                    ]) : ze("", !0)
                  ])
                ])
              ])
            ]),
            bottom: Me(() => [
              Ke("div", yf, [
                ke(ps, {
                  modelValue: s.pagination.page,
                  "onUpdate:modelValue": [
                    P[2] || (P[2] = (p) => s.pagination.page = p),
                    u
                  ],
                  "max-pages": 6,
                  max: s.rows[o.paginationResponseKeys.lastPage],
                  "direction-links": "",
                  "boundary-links": ""
                }, null, 8, ["modelValue", "max"])
              ])
            ]),
            _: 2
          }, [
            ll(r, (p, F, A) => ({
              name: F,
              fn: Me((U) => [
                F.toString().startsWith("filter-modal-") ? ze("", !0) : mt(T.$slots, F, La(Qt({ key: 0 }, U)))
              ])
            }))
          ]), 1040, ["loading", "hide-bottom", "flat", "square", "title", "columns", "rows", "pagination"])
        ]),
        ke(Wu, Qt({
          ref_key: "filterModal",
          ref: l
        }, o.filterModalData.props, {
          "ok-label": ((_ = o.filterModalData.props) == null ? void 0 : _.okLabel) || "Filter",
          title: ((y = o.filterModalData.props) == null ? void 0 : y.title) || "Filter",
          onSubmit: h,
          "form-is-loading": s.filterIsLoading
        }), ta({
          content: Me(() => [
            (Le(!0), Ft(Rn, null, ll(o.filterModalData.fields, (p, F) => (Le(), Ft(Rn, { key: F }, [
              p.type == "text" ? (Le(), st(en, {
                key: 0,
                outlined: "",
                label: p.label,
                modelValue: s.filter[p.urlParam],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                clearable: ""
              }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : ze("", !0),
              p.type == "date-time" ? (Le(), st(en, {
                key: 1,
                outlined: "",
                label: p.label,
                modelValue: s.filter[p.urlParam],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                readonly: "",
                class: "[&>div>div:before]:!border-solid"
              }, {
                append: Me(() => [
                  Ke("div", pf, [
                    s.filter[p.urlParam] ? (Le(), Ft("button", {
                      key: 0,
                      onClick: (A) => s.filter[p.urlParam] = "",
                      class: "q-icon notranslate material-icons q-field__focusable-action",
                      tabindex: "0",
                      type: "button"
                    }, " cancel ", 8, Sf)) : ze("", !0)
                  ]),
                  ke(Te, { icon: "calendar_month" }, {
                    default: Me(() => [
                      ke(Ql, {
                        cover: "",
                        "transition-show": "scale",
                        "transition-hide": "scale",
                        class: "p-2"
                      }, {
                        default: Me(() => [
                          Ke("div", wf, [
                            ke(To, {
                              modelValue: s.filter[p.urlParam],
                              "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                              mask: "YYYY-MM-DD HH:mm"
                            }, {
                              default: Me(() => [
                                Ke("div", kf, [
                                  At(ke(Te, {
                                    label: "Close",
                                    color: "primary",
                                    flat: ""
                                  }, null, 512), [
                                    [rn]
                                  ])
                                ])
                              ]),
                              _: 2
                            }, 1032, ["modelValue", "onUpdate:modelValue"]),
                            ke(Bo, {
                              modelValue: s.filter[p.urlParam],
                              "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                              mask: "YYYY-MM-DD HH:mm"
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["label", "modelValue", "onUpdate:modelValue"])) : ze("", !0),
              p.type == "date" ? (Le(), st(en, {
                key: 2,
                outlined: "",
                label: p.label,
                modelValue: s.filter[p.urlParam],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                readonly: "",
                class: "[&>div>div:before]:!border-solid"
              }, {
                append: Me(() => [
                  Ke("div", xf, [
                    s.filter[p.urlParam] ? (Le(), Ft("button", {
                      key: 0,
                      onClick: (A) => s.filter[p.urlParam] = "",
                      class: "q-icon notranslate material-icons q-field__focusable-action",
                      tabindex: "0",
                      type: "button"
                    }, " cancel ", 8, _f)) : ze("", !0)
                  ]),
                  ke(Te, { icon: "calendar_month" }, {
                    default: Me(() => [
                      ke(Ql, {
                        cover: "",
                        "transition-show": "scale",
                        "transition-hide": "scale"
                      }, {
                        default: Me(() => [
                          Ke("div", Cf, [
                            ke(To, {
                              modelValue: s.filter[p.urlParam],
                              "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                              mask: "YYYY-MM-DD"
                            }, {
                              default: Me(() => [
                                Ke("div", qf, [
                                  At(ke(Te, {
                                    label: "Close",
                                    color: "primary",
                                    flat: ""
                                  }, null, 512), [
                                    [rn]
                                  ])
                                ])
                              ]),
                              _: 2
                            }, 1032, ["modelValue", "onUpdate:modelValue"])
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["label", "modelValue", "onUpdate:modelValue"])) : ze("", !0),
              p.type == "time" ? (Le(), st(en, {
                key: 3,
                outlined: "",
                label: p.label,
                modelValue: s.filter[p.urlParam],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                readonly: "",
                class: "[&>div>div:before]:!border-solid"
              }, {
                append: Me(() => [
                  Ke("div", Ef, [
                    s.filter[p.urlParam] ? (Le(), Ft("button", {
                      key: 0,
                      onClick: (A) => s.filter[p.urlParam] = "",
                      class: "q-icon notranslate material-icons q-field__focusable-action",
                      tabindex: "0",
                      type: "button"
                    }, " cancel ", 8, Mf)) : ze("", !0)
                  ]),
                  ke(Te, { icon: "calendar_month" }, {
                    default: Me(() => [
                      ke(Ql, {
                        cover: "",
                        "transition-show": "scale",
                        "transition-hide": "scale"
                      }, {
                        default: Me(() => [
                          Ke("div", Rf, [
                            ke(Bo, {
                              modelValue: s.filter[p.urlParam],
                              "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                              mask: "HH:mm"
                            }, {
                              default: Me(() => [
                                Ke("div", Tf, [
                                  At(ke(Te, {
                                    label: "Close",
                                    color: "primary",
                                    flat: ""
                                  }, null, 512), [
                                    [rn]
                                  ])
                                ])
                              ]),
                              _: 2
                            }, 1032, ["modelValue", "onUpdate:modelValue"])
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["label", "modelValue", "onUpdate:modelValue"])) : ze("", !0),
              p.type == "number" ? (Le(), st(en, {
                key: 4,
                outlined: "",
                type: "number",
                label: p.label,
                modelValue: s.filter[p.urlParam],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                clearable: ""
              }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : ze("", !0),
              p.type == "boolean-checkbox" ? (Le(), st(Fn, {
                key: 5,
                label: p.label,
                "model-value": s.filter[p.urlParam] ? s.filter[p.urlParam] : !1,
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A
              }, null, 8, ["label", "model-value", "onUpdate:modelValue"])) : ze("", !0),
              p.type == "checkboxs" ? (Le(), Ft(Rn, { key: 6 }, [
                Ke("div", Pf, Dn(p.label), 1),
                ke(Vo, {
                  type: "checkbox",
                  "model-value": s.filter[p.urlParam] || [],
                  "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                  options: p.choices || []
                }, null, 8, ["model-value", "onUpdate:modelValue", "options"])
              ], 64)) : ze("", !0),
              p.type == "radios" ? (Le(), Ft(Rn, { key: 7 }, [
                Ke("div", Of, Dn(p.label), 1),
                ke(Vo, {
                  type: "radio",
                  modelValue: s.filter[p.urlParam],
                  "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                  options: p.choices || []
                }, null, 8, ["modelValue", "onUpdate:modelValue", "options"])
              ], 64)) : ze("", !0),
              p.type == "select" ? (Le(), st(hl, {
                key: 8,
                outlined: "",
                label: p.label,
                modelValue: s.filter[p.urlParam],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                "emit-value": "",
                "map-options": "",
                options: p.choices || [],
                clearable: ""
              }, null, 8, ["label", "modelValue", "onUpdate:modelValue", "options"])) : ze("", !0),
              p.type == "select-multiple" ? (Le(), st(hl, {
                key: 9,
                outlined: "",
                label: p.label,
                "model-value": s.filter[p.urlParam] || [],
                "onUpdate:modelValue": (A) => s.filter[p.urlParam] = A,
                multiple: "",
                "emit-value": "",
                "map-options": "",
                options: p.choices || [],
                clearable: ""
              }, null, 8, ["label", "model-value", "onUpdate:modelValue", "options"])) : ze("", !0)
            ], 64))), 128))
          ]),
          _: 2
        }, [
          ll(r, (p, F, A) => ({
            name: i(F.toString()),
            fn: Me((U) => [
              F.toString().startsWith("filter-modal-") ? mt(T.$slots, F, La(Qt({ key: 0 }, U))) : ze("", !0)
            ])
          }))
        ]), 1040, ["ok-label", "title", "form-is-loading"])
      ], 64);
    };
  }
}), Lf = /* @__PURE__ */ Nn({
  inheritAttrs: !1,
  __name: "AnServerSelect",
  props: /* @__PURE__ */ Fa({
    link: {},
    defaultOptions: {},
    axiosInterceptor: {},
    searchParam: {},
    name: {},
    virtualScrollHorizontal: { type: Boolean },
    virtualScrollSliceSize: {},
    virtualScrollSliceRatioBefore: {},
    virtualScrollSliceRatioAfter: {},
    virtualScrollItemSize: {},
    virtualScrollStickySizeStart: {},
    virtualScrollStickySizeEnd: {},
    tableColspan: {},
    modelValue: {},
    error: { type: [Boolean, null] },
    errorMessage: {},
    noErrorIcon: { type: Boolean },
    rules: {},
    reactiveRules: { type: Boolean },
    lazyRules: { type: [Boolean, String] },
    label: {},
    stackLabel: { type: Boolean },
    hint: {},
    hideHint: { type: Boolean },
    prefix: {},
    suffix: {},
    labelColor: {},
    color: {},
    bgColor: {},
    dark: { type: [Boolean, null], default: void 0 },
    loading: { type: Boolean },
    clearable: { type: Boolean },
    clearIcon: {},
    filled: { type: Boolean },
    outlined: { type: Boolean },
    borderless: { type: Boolean },
    standout: { type: [Boolean, String] },
    labelSlot: { type: Boolean },
    bottomSlots: { type: Boolean },
    hideBottomSpace: { type: Boolean },
    counter: { type: Boolean },
    rounded: { type: Boolean },
    square: { type: Boolean },
    dense: { type: Boolean },
    itemAligned: { type: Boolean },
    disable: { type: Boolean },
    readonly: { type: Boolean },
    autofocus: { type: Boolean },
    for: {},
    multiple: { type: Boolean },
    displayValue: {},
    displayValueHtml: { type: Boolean },
    optionValue: {},
    optionLabel: {},
    optionDisable: {},
    hideSelected: { type: Boolean },
    hideDropdownIcon: { type: Boolean },
    dropdownIcon: {},
    maxValues: {},
    optionsDense: { type: Boolean },
    optionsDark: { type: [Boolean, null], default: void 0 },
    optionsSelectedClass: {},
    optionsHtml: { type: Boolean },
    optionsCover: { type: Boolean },
    menuShrink: { type: Boolean },
    menuAnchor: {},
    menuSelf: {},
    menuOffset: {},
    popupContentClass: {},
    popupContentStyle: {},
    popupNoRouteDismiss: { type: Boolean },
    useChips: { type: Boolean },
    useInput: { type: Boolean },
    maxlength: {},
    fillInput: { type: Boolean },
    newValueMode: {},
    mapOptions: { type: Boolean },
    disableTabSelection: { type: Boolean },
    emitValue: { type: Boolean },
    inputDebounce: {},
    inputClass: {},
    inputStyle: {},
    tabindex: {},
    autocomplete: {},
    transitionShow: {},
    transitionHide: {},
    transitionDuration: {},
    behavior: {},
    onVirtualScroll: {},
    "onUpdate:modelValue": {},
    onFocus: {},
    onBlur: {},
    onClear: {},
    onInputValue: {},
    onRemove: {},
    onAdd: {},
    onNewValue: {},
    onFilter: {},
    onFilterAbort: {},
    onPopupShow: {},
    onPopupHide: {}
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Fa(["update:options", "filter", "loading", "error"], ["update:modelValue"]),
  setup(e, { emit: t }) {
    const n = e, l = Hi(e, "modelValue"), a = Jo(), o = t, r = kn({
      options: n.defaultOptions || [],
      inputValue: "",
      // Track the user's input value
      isLoading: !1
    }), i = (c, s) => {
      s(() => {
      }), o("filter", c), r.isLoading = !0, o("loading", !0), (n.axiosInterceptor || Ie).get(n.link, {
        params: { [n.searchParam || "search"]: c }
        // Pass the filter value as a query parameter
      }).then((u) => {
        s(() => {
          r.options = u.data || [];
        }), o("update:options", r.options);
      }).catch((u) => {
        console.error("Error fetching filtered options:", u), o("error", u);
      }).finally(() => {
        r.isLoading = !1, o("loading", !1);
      });
    };
    return zn(() => {
      (n.axiosInterceptor || Ie).get(n.link, {
        params: { [n.searchParam || "search"]: "" }
        // Pass the filter value as a query parameter
      }).then((c) => {
        r.options = c.data || [], o("update:options", r.options);
      }).catch((c) => {
        console.error("Error fetching filtered options:", c), o("error", c);
      }).finally(() => {
        r.isLoading = !1, o("loading", !1);
      });
    }), (c, s) => (Le(), st(pl(hl), Qt(n, {
      modelValue: l.value,
      "onUpdate:modelValue": s[0] || (s[0] = (u) => l.value = u),
      options: r.options,
      onFilter: i,
      "use-input": "",
      "input-value": r.inputValue,
      loading: r.isLoading,
      "onUpdate:inputValue": s[1] || (s[1] = (u) => r.inputValue = u)
    }), ta({ _: 2 }, [
      ll(a, (u, f, S) => ({
        name: f,
        fn: Me((b) => [
          mt(c.$slots, f, Qt(b, { key: S }))
        ])
      }))
    ]), 1040, ["modelValue", "options", "input-value", "loading"]));
  }
});
export {
  Vf as AnModal,
  Wu as AnModalForm,
  Af as AnPageLoader,
  Df as AnServerDataTable,
  Lf as AnServerSelect
};
